(window.webpackJsonp = window.webpackJsonp || []).push([
    [8], {
        "+6XX": function(t, e, n) {
            var i = n("y1pI");
            t.exports = function(t) {
                return i(this.__data__, t) > -1
            }
        },
        "+K+b": function(t, e, n) {
            var i = n("JHRd");
            t.exports = function(t) {
                var e = new t.constructor(t.byteLength);
                return new i(e).set(new i(t)), e
            }
        },
        "+iFO": function(t, e, n) {
            var i = n("dTAl"),
                r = n("LcsW"),
                a = n("6sVZ");
            t.exports = function(t) {
                return "function" != typeof t.constructor || a(t) ? {} : i(r(t))
            }
        },
        "/9aa": function(t, e, n) {
            var i = n("NykK"),
                r = n("ExA7"),
                a = "[object Symbol]";
            t.exports = function(t) {
                return "symbol" == typeof t || r(t) && i(t) == a
            }
        },
        "/eQG": function(t, e, n) {
            n("v5Dd");
            var i = n("WEpk").Object;
            t.exports = function(t, e) {
                return i.getOwnPropertyDescriptor(t, e)
            }
        },
        "03A+": function(t, e, n) {
            var i = n("JTzB"),
                r = n("ExA7"),
                a = Object.prototype,
                o = a.hasOwnProperty,
                s = a.propertyIsEnumerable,
                c = i(function() {
                    return arguments
                }()) ? i : function(t) {
                    return r(t) && o.call(t, "callee") && !s.call(t, "callee")
                };
            t.exports = c
        },
        "07wX": function(t, e, n) {
            (window.__NEXT_P = window.__NEXT_P || []).push(["/game", function() {
                var t = n("OzVs");
                return {
                    page: t.default || t
                }
            }])
        },
        "0Cz8": function(t, e, n) {
            var i = n("Xi7e"),
                r = n("ebwN"),
                a = n("e4Nc"),
                o = 200;
            t.exports = function(t, e) {
                var n = this.__data__;
                if (n instanceof i) {
                    var s = n.__data__;
                    if (!r || s.length < o - 1) return s.push([t, e]), this.size = ++n.size, this;
                    n = this.__data__ = new a(s)
                }
                return n.set(t, e), this.size = n.size, this
            }
        },
        "0ycA": function(t, e) {
            t.exports = function() {
                return []
            }
        },
        "1+5i": function(t, e, n) {
            var i = n("w/wX"),
                r = n("sEf8"),
                a = n("mdPL"),
                o = a && a.isSet,
                s = o ? r(o) : i;
            t.exports = s
        },
        "2gN3": function(t, e, n) {
            var i = n("Kz5y")["__core-js_shared__"];
            t.exports = i
        },
        "3Fdi": function(t, e) {
            var n = Function.prototype.toString;
            t.exports = function(t) {
                if (null != t) {
                    try {
                        return n.call(t)
                    } catch (e) {}
                    try {
                        return t + ""
                    } catch (e) {}
                }
                return ""
            }
        },
        "4kuk": function(t, e, n) {
            var i = n("SfRM"),
                r = n("Hvzi"),
                a = n("u8Dt"),
                o = n("ekgI"),
                s = n("JSQU");

            function c(t) {
                var e = -1,
                    n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n;) {
                    var i = t[e];
                    this.set(i[0], i[1])
                }
            }
            c.prototype.clear = i, c.prototype.delete = r, c.prototype.get = a, c.prototype.has = o, c.prototype.set = s, t.exports = c
        },
        "5Tg0": function(t, e, n) {
            (function(t) {
                var i = n("Kz5y"),
                    r = e && !e.nodeType && e,
                    a = r && "object" == typeof t && t && !t.nodeType && t,
                    o = a && a.exports === r ? i.Buffer : void 0,
                    s = o ? o.allocUnsafe : void 0;
                t.exports = function(t, e) {
                    if (e) return t.slice();
                    var n = t.length,
                        i = s ? s(n) : new t.constructor(n);
                    return t.copy(i), i
                }
            }).call(this, n("YuTi")(t))
        },
        "5pKv": function(t, e) {
            t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
        },
        "6BQ9": function(t, e, n) {
            t.exports = n("uekQ")
        },
        "6CmU": function(t, e, n) {
            n("LzdP"), t.exports = n("WEpk").Date.now
        },
        "6sVZ": function(t, e) {
            var n = Object.prototype;
            t.exports = function(t) {
                var e = t && t.constructor;
                return t === ("function" == typeof e && e.prototype || n)
            }
        },
        "77Zs": function(t, e, n) {
            var i = n("Xi7e");
            t.exports = function() {
                this.__data__ = new i, this.size = 0
            }
        },
        "7GkX": function(t, e, n) {
            var i = n("b80T"),
                r = n("A90E"),
                a = n("MMmD");
            t.exports = function(t) {
                return a(t) ? i(t) : r(t)
            }
        },
        "7Ix3": function(t, e) {
            t.exports = function(t) {
                var e = [];
                if (null != t)
                    for (var n in Object(t)) e.push(n);
                return e
            }
        },
        A90E: function(t, e, n) {
            var i = n("6sVZ"),
                r = n("V6Ve"),
                a = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                if (!i(t)) return r(t);
                var e = [];
                for (var n in Object(t)) a.call(t, n) && "constructor" != n && e.push(n);
                return e
            }
        },
        AP2z: function(t, e, n) {
            var i = n("nmnc"),
                r = Object.prototype,
                a = r.hasOwnProperty,
                o = r.toString,
                s = i ? i.toStringTag : void 0;
            t.exports = function(t) {
                var e = a.call(t, s),
                    n = t[s];
                try {
                    t[s] = void 0;
                    var i = !0
                } catch (c) {}
                var r = o.call(t);
                return i && (e ? t[s] = n : delete t[s]), r
            }
        },
        B8du: function(t, e) {
            t.exports = function() {
                return !1
            }
        },
        BkRI: function(t, e, n) {
            var i = n("OBhP"),
                r = 1,
                a = 4;
            t.exports = function(t) {
                return i(t, r | a)
            }
        },
        CH3K: function(t, e) {
            t.exports = function(t, e) {
                for (var n = -1, i = e.length, r = t.length; ++n < i;) t[r + n] = e[n];
                return t
            }
        },
        Cg2A: function(t, e, n) {
            t.exports = n("6CmU")
        },
        Cwc5: function(t, e, n) {
            var i = n("NKxu"),
                r = n("Npjl");
            t.exports = function(t, e) {
                var n = r(t, e);
                return i(n) ? n : void 0
            }
        },
        DSRE: function(t, e, n) {
            (function(t) {
                var i = n("Kz5y"),
                    r = n("B8du"),
                    a = e && !e.nodeType && e,
                    o = a && "object" == typeof t && t && !t.nodeType && t,
                    s = o && o.exports === a ? i.Buffer : void 0,
                    c = (s ? s.isBuffer : void 0) || r;
                t.exports = c
            }).call(this, n("YuTi")(t))
        },
        "Dw+G": function(t, e, n) {
            var i = n("juv8"),
                r = n("mTTR");
            t.exports = function(t, e) {
                return t && i(e, r(e), t)
            }
        },
        DzJC: function(t, e, n) {
            var i = n("sEfC"),
                r = n("GoyQ"),
                a = "Expected a function";
            t.exports = function(t, e, n) {
                var o = !0,
                    s = !0;
                if ("function" != typeof t) throw new TypeError(a);
                return r(n) && (o = "leading" in n ? !!n.leading : o, s = "trailing" in n ? !!n.trailing : s), i(t, e, {
                    leading: o,
                    maxWait: e,
                    trailing: s
                })
            }
        },
        E2jh: function(t, e, n) {
            var i, r = n("2gN3"),
                a = (i = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || "")) ? "Symbol(src)_1." + i : "";
            t.exports = function(t) {
                return !!a && a in t
            }
        },
        EEGq: function(t, e, n) {
            var i = n("juv8"),
                r = n("oCl/");
            t.exports = function(t, e) {
                return i(t, r(t), e)
            }
        },
        EpBk: function(t, e) {
            t.exports = function(t) {
                var e = typeof t;
                return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
            }
        },
        ExA7: function(t, e) {
            t.exports = function(t) {
                return null != t && "object" == typeof t
            }
        },
        G6z8: function(t, e, n) {
            var i = n("fR/l"),
                r = n("oCl/"),
                a = n("mTTR");
            t.exports = function(t) {
                return i(t, a, r)
            }
        },
        Gi0A: function(t, e, n) {
            var i = n("QqLw"),
                r = n("ExA7"),
                a = "[object Map]";
            t.exports = function(t) {
                return r(t) && i(t) == a
            }
        },
        GoyQ: function(t, e) {
            t.exports = function(t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e)
            }
        },
        H8j4: function(t, e, n) {
            var i = n("QkVE");
            t.exports = function(t, e) {
                var n = i(this, t),
                    r = n.size;
                return n.set(t, e), this.size += n.size == r ? 0 : 1, this
            }
        },
        HLdI: function(t, e, n) {
            var i = n("vwuL"),
                r = n("U+KD"),
                a = n("B+OT"),
                o = n("Y7ZC"),
                s = n("93I4"),
                c = n("5K7Z");
            o(o.S, "Reflect", {
                get: function t(e, n) {
                    var o, u, l = arguments.length < 3 ? e : arguments[2];
                    return c(e) === l ? e[n] : (o = i.f(e, n)) ? a(o, "value") ? o.value : void 0 !== o.get ? o.get.call(l) : void 0 : s(u = r(e)) ? t(u, n, l) : void 0
                }
            })
        },
        HOxn: function(t, e, n) {
            var i = n("Cwc5")(n("Kz5y"), "Promise");
            t.exports = i
        },
        HlzF: function(t, e, n) {
            (function(n) {
                var i;
                /*!
                 *  howler.js v2.1.1
                 *  howlerjs.com
                 *
                 *  (c) 2013-2018, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */
                /*!
                 *  howler.js v2.1.1
                 *  howlerjs.com
                 *
                 *  (c) 2013-2018, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */
                ! function() {
                    "use strict";
                    var r = function() {
                        this.init()
                    };
                    r.prototype = {
                        init: function() {
                            var t = this || a;
                            return t._counter = 1e3, t._html5AudioPool = [], t.html5PoolSize = 10, t._codecs = {}, t._howls = [], t._muted = !1, t._volume = 1, t._canPlayEvent = "canplaythrough", t._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, t.masterGain = null, t.noAudio = !1, t.usingWebAudio = !0, t.autoSuspend = !0, t.ctx = null, t.autoUnlock = !0, t._setup(), t
                        },
                        volume: function(t) {
                            var e = this || a;
                            if (t = parseFloat(t), e.ctx || p(), void 0 !== t && t >= 0 && t <= 1) {
                                if (e._volume = t, e._muted) return e;
                                e.usingWebAudio && e.masterGain.gain.setValueAtTime(t, a.ctx.currentTime);
                                for (var n = 0; n < e._howls.length; n++)
                                    if (!e._howls[n]._webAudio)
                                        for (var i = e._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                            var o = e._howls[n]._soundById(i[r]);
                                            o && o._node && (o._node.volume = o._volume * t)
                                        }
                                return e
                            }
                            return e._volume
                        },
                        mute: function(t) {
                            var e = this || a;
                            e.ctx || p(), e._muted = t, e.usingWebAudio && e.masterGain.gain.setValueAtTime(t ? 0 : e._volume, a.ctx.currentTime);
                            for (var n = 0; n < e._howls.length; n++)
                                if (!e._howls[n]._webAudio)
                                    for (var i = e._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                        var o = e._howls[n]._soundById(i[r]);
                                        o && o._node && (o._node.muted = !!t || o._muted)
                                    }
                            return e
                        },
                        unload: function() {
                            for (var t = this || a, e = t._howls.length - 1; e >= 0; e--) t._howls[e].unload();
                            return t.usingWebAudio && t.ctx && void 0 !== t.ctx.close && (t.ctx.close(), t.ctx = null, p()), t
                        },
                        codecs: function(t) {
                            return (this || a)._codecs[t.replace(/^x-/, "")]
                        },
                        _setup: function() {
                            var t = this || a;
                            if (t.state = t.ctx && t.ctx.state || "suspended", t._autoSuspend(), !t.usingWebAudio)
                                if ("undefined" != typeof Audio) try {
                                    void 0 === (new Audio).oncanplaythrough && (t._canPlayEvent = "canplay")
                                } catch (e) {
                                    t.noAudio = !0
                                } else t.noAudio = !0;
                            try {
                                (new Audio).muted && (t.noAudio = !0)
                            } catch (e) {}
                            return t.noAudio || t._setupCodecs(), t
                        },
                        _setupCodecs: function() {
                            var t = this || a,
                                e = null;
                            try {
                                e = "undefined" != typeof Audio ? new Audio : null
                            } catch (o) {
                                return t
                            }
                            if (!e || "function" != typeof e.canPlayType) return t;
                            var n = e.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                                i = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g),
                                r = i && parseInt(i[0].split("/")[1], 10) < 33;
                            return t._codecs = {
                                mp3: !(r || !n && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
                                mpeg: !!n,
                                opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                                ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                wav: !!e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
                                aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
                                caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                                m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                                webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                                dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                                flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
                            }, t
                        },
                        _unlockAudio: function() {
                            var t = this || a,
                                e = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi|Chrome|Safari/i.test(t._navigator && t._navigator.userAgent);
                            if (!t._audioUnlocked && t.ctx && e) {
                                t._audioUnlocked = !1, t.autoUnlock = !1, t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0, t.unload()), t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
                                var n = function(e) {
                                    for (var i = 0; i < t.html5PoolSize; i++) {
                                        var r = new Audio;
                                        r._unlocked = !0, t._releaseHtml5Audio(r)
                                    }
                                    for (i = 0; i < t._howls.length; i++)
                                        if (!t._howls[i]._webAudio)
                                            for (var a = t._howls[i]._getSoundIds(), o = 0; o < a.length; o++) {
                                                var s = t._howls[i]._soundById(a[o]);
                                                s && s._node && !s._node._unlocked && (s._node._unlocked = !0, s._node.load())
                                            }
                                    t._autoResume();
                                    var c = t.ctx.createBufferSource();
                                    c.buffer = t._scratchBuffer, c.connect(t.ctx.destination), void 0 === c.start ? c.noteOn(0) : c.start(0), "function" == typeof t.ctx.resume && t.ctx.resume(), c.onended = function() {
                                        c.disconnect(0), t._audioUnlocked = !0, document.removeEventListener("touchstart", n, !0), document.removeEventListener("touchend", n, !0), document.removeEventListener("click", n, !0);
                                        for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("unlock")
                                    }
                                };
                                return document.addEventListener("touchstart", n, !0), document.addEventListener("touchend", n, !0), document.addEventListener("click", n, !0), t
                            }
                        },
                        _obtainHtml5Audio: function() {
                            var t = this || a;
                            if (t._html5AudioPool.length) return t._html5AudioPool.pop();
                            var e = (new Audio).play();
                            return e && "undefined" != typeof Promise && (e instanceof Promise || "function" == typeof e.then) && e.catch(function() {
                                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                            }), new Audio
                        },
                        _releaseHtml5Audio: function(t) {
                            var e = this || a;
                            return t._unlocked && e._html5AudioPool.push(t), e
                        },
                        _autoSuspend: function() {
                            var t = this;
                            if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && a.usingWebAudio) {
                                for (var e = 0; e < t._howls.length; e++)
                                    if (t._howls[e]._webAudio)
                                        for (var n = 0; n < t._howls[e]._sounds.length; n++)
                                            if (!t._howls[e]._sounds[n]._paused) return t;
                                return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout(function() {
                                    t.autoSuspend && (t._suspendTimer = null, t.state = "suspending", t.ctx.suspend().then(function() {
                                        t.state = "suspended", t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume())
                                    }))
                                }, 3e4), t
                            }
                        },
                        _autoResume: function() {
                            var t = this;
                            if (t.ctx && void 0 !== t.ctx.resume && a.usingWebAudio) return "running" === t.state && t._suspendTimer ? (clearTimeout(t._suspendTimer), t._suspendTimer = null) : "suspended" === t.state ? (t.ctx.resume().then(function() {
                                t.state = "running";
                                for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("resume")
                            }), t._suspendTimer && (clearTimeout(t._suspendTimer), t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0), t
                        }
                    };
                    var a = new r,
                        o = function(t) {
                            t.src && 0 !== t.src.length ? this.init(t) : console.error("An array of source files must be passed with any new Howl.")
                        };
                    o.prototype = {
                        init: function(t) {
                            var e = this;
                            return a.ctx || p(), e._autoplay = t.autoplay || !1, e._format = "string" != typeof t.format ? t.format : [t.format], e._html5 = t.html5 || !1, e._muted = t.mute || !1, e._loop = t.loop || !1, e._pool = t.pool || 5, e._preload = "boolean" != typeof t.preload || t.preload, e._rate = t.rate || 1, e._sprite = t.sprite || {}, e._src = "string" != typeof t.src ? t.src : [t.src], e._volume = void 0 !== t.volume ? t.volume : 1, e._xhrWithCredentials = t.xhrWithCredentials || !1, e._duration = 0, e._state = "unloaded", e._sounds = [], e._endTimers = {}, e._queue = [], e._playLock = !1, e._onend = t.onend ? [{
                                fn: t.onend
                            }] : [], e._onfade = t.onfade ? [{
                                fn: t.onfade
                            }] : [], e._onload = t.onload ? [{
                                fn: t.onload
                            }] : [], e._onloaderror = t.onloaderror ? [{
                                fn: t.onloaderror
                            }] : [], e._onplayerror = t.onplayerror ? [{
                                fn: t.onplayerror
                            }] : [], e._onpause = t.onpause ? [{
                                fn: t.onpause
                            }] : [], e._onplay = t.onplay ? [{
                                fn: t.onplay
                            }] : [], e._onstop = t.onstop ? [{
                                fn: t.onstop
                            }] : [], e._onmute = t.onmute ? [{
                                fn: t.onmute
                            }] : [], e._onvolume = t.onvolume ? [{
                                fn: t.onvolume
                            }] : [], e._onrate = t.onrate ? [{
                                fn: t.onrate
                            }] : [], e._onseek = t.onseek ? [{
                                fn: t.onseek
                            }] : [], e._onunlock = t.onunlock ? [{
                                fn: t.onunlock
                            }] : [], e._onresume = [], e._webAudio = a.usingWebAudio && !e._html5, void 0 !== a.ctx && a.ctx && a.autoUnlock && a._unlockAudio(), a._howls.push(e), e._autoplay && e._queue.push({
                                event: "play",
                                action: function() {
                                    e.play()
                                }
                            }), e._preload && e.load(), e
                        },
                        load: function() {
                            var t = null;
                            if (a.noAudio) this._emit("loaderror", null, "No audio support.");
                            else {
                                "string" == typeof this._src && (this._src = [this._src]);
                                for (var e = 0; e < this._src.length; e++) {
                                    var n, i;
                                    if (this._format && this._format[e]) n = this._format[e];
                                    else {
                                        if ("string" != typeof(i = this._src[e])) {
                                            this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                            continue
                                        }(n = /^data:audio\/([^;,]+);/i.exec(i)) || (n = /\.([^.]+)$/.exec(i.split("?", 1)[0])), n && (n = n[1].toLowerCase())
                                    }
                                    if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && a.codecs(n)) {
                                        t = this._src[e];
                                        break
                                    }
                                }
                                if (t) return this._src = t, this._state = "loading", "https:" === window.location.protocol && "http:" === t.slice(0, 5) && (this._html5 = !0, this._webAudio = !1), new s(this), this._webAudio && u(this), this;
                                this._emit("loaderror", null, "No codec support for selected audio sources.")
                            }
                        },
                        play: function(t, e) {
                            var n = this,
                                i = null;
                            if ("number" == typeof t) i = t, t = null;
                            else {
                                if ("string" == typeof t && "loaded" === n._state && !n._sprite[t]) return null;
                                if (void 0 === t && (t = "__default", !n._playLock)) {
                                    for (var r = 0, o = 0; o < n._sounds.length; o++) n._sounds[o]._paused && !n._sounds[o]._ended && (r++, i = n._sounds[o]._id);
                                    1 === r ? t = null : i = null
                                }
                            }
                            var s = i ? n._soundById(i) : n._inactiveSound();
                            if (!s) return null;
                            if (i && !t && (t = s._sprite || "__default"), "loaded" !== n._state) {
                                s._sprite = t, s._ended = !1;
                                var c = s._id;
                                return n._queue.push({
                                    event: "play",
                                    action: function() {
                                        n.play(c)
                                    }
                                }), c
                            }
                            if (i && !s._paused) return e || n._loadQueue("play"), s._id;
                            n._webAudio && a._autoResume();
                            var u = Math.max(0, s._seek > 0 ? s._seek : n._sprite[t][0] / 1e3),
                                l = Math.max(0, (n._sprite[t][0] + n._sprite[t][1]) / 1e3 - u),
                                h = 1e3 * l / Math.abs(s._rate),
                                d = n._sprite[t][0] / 1e3,
                                p = (n._sprite[t][0] + n._sprite[t][1]) / 1e3,
                                f = !(!s._loop && !n._sprite[t][2]);
                            s._sprite = t, s._ended = !1;
                            var m = function() {
                                s._paused = !1, s._seek = u, s._start = d, s._stop = p, s._loop = f
                            };
                            if (!(u >= p)) {
                                var v = s._node;
                                if (n._webAudio) {
                                    var g = function() {
                                        n._playLock = !1, m(), n._refreshBuffer(s);
                                        var t = s._muted || n._muted ? 0 : s._volume;
                                        v.gain.setValueAtTime(t, a.ctx.currentTime), s._playStart = a.ctx.currentTime, void 0 === v.bufferSource.start ? s._loop ? v.bufferSource.noteGrainOn(0, u, 86400) : v.bufferSource.noteGrainOn(0, u, l) : s._loop ? v.bufferSource.start(0, u, 86400) : v.bufferSource.start(0, u, l), h !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h)), e || setTimeout(function() {
                                            n._emit("play", s._id), n._loadQueue()
                                        }, 0)
                                    };
                                    "running" === a.state ? g() : (n._playLock = !0, n.once("resume", g), n._clearTimer(s._id))
                                } else {
                                    var y = function() {
                                            v.currentTime = u, v.muted = s._muted || n._muted || a._muted || v.muted, v.volume = s._volume * a.volume(), v.playbackRate = s._rate;
                                            try {
                                                var i = v.play();
                                                if (i && "undefined" != typeof Promise && (i instanceof Promise || "function" == typeof i.then) ? (n._playLock = !0, m(), i.then(function() {
                                                        n._playLock = !1, v._unlocked = !0, e || (n._emit("play", s._id), n._loadQueue())
                                                    }).catch(function() {
                                                        n._playLock = !1, n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), s._ended = !0, s._paused = !0
                                                    })) : e || (n._playLock = !1, m(), n._emit("play", s._id), n._loadQueue()), v.playbackRate = s._rate, v.paused) return void n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                                "__default" !== t || s._loop ? n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h) : (n._endTimers[s._id] = function() {
                                                    n._ended(s), v.removeEventListener("ended", n._endTimers[s._id], !1)
                                                }, v.addEventListener("ended", n._endTimers[s._id], !1))
                                            } catch (r) {
                                                n._emit("playerror", s._id, r)
                                            }
                                        },
                                        x = window && window.ejecta || !v.readyState && a._navigator.isCocoonJS;
                                    if (v.readyState >= 3 || x) y();
                                    else {
                                        n._playLock = !0;
                                        var b = function() {
                                            y(), v.removeEventListener(a._canPlayEvent, b, !1)
                                        };
                                        v.addEventListener(a._canPlayEvent, b, !1), n._clearTimer(s._id)
                                    }
                                }
                                return s._id
                            }
                            n._ended(s)
                        },
                        pause: function(t) {
                            var e = this;
                            if ("loaded" !== e._state || e._playLock) return e._queue.push({
                                event: "pause",
                                action: function() {
                                    e.pause(t)
                                }
                            }), e;
                            for (var n = e._getSoundIds(t), i = 0; i < n.length; i++) {
                                e._clearTimer(n[i]);
                                var r = e._soundById(n[i]);
                                if (r && !r._paused && (r._seek = e.seek(n[i]), r._rateSeek = 0, r._paused = !0, e._stopFade(n[i]), r._node))
                                    if (e._webAudio) {
                                        if (!r._node.bufferSource) continue;
                                        void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), e._cleanBuffer(r._node)
                                    } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
                                arguments[1] || e._emit("pause", r ? r._id : null)
                            }
                            return e
                        },
                        stop: function(t, e) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "stop",
                                action: function() {
                                    n.stop(t)
                                }
                            }), n;
                            for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
                                n._clearTimer(i[r]);
                                var a = n._soundById(i[r]);
                                a && (a._seek = a._start || 0, a._rateSeek = 0, a._paused = !0, a._ended = !0, n._stopFade(i[r]), a._node && (n._webAudio ? a._node.bufferSource && (void 0 === a._node.bufferSource.stop ? a._node.bufferSource.noteOff(0) : a._node.bufferSource.stop(0), n._cleanBuffer(a._node)) : isNaN(a._node.duration) && a._node.duration !== 1 / 0 || (a._node.currentTime = a._start || 0, a._node.pause())), e || n._emit("stop", a._id))
                            }
                            return n
                        },
                        mute: function(t, e) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "mute",
                                action: function() {
                                    n.mute(t, e)
                                }
                            }), n;
                            if (void 0 === e) {
                                if ("boolean" != typeof t) return n._muted;
                                n._muted = t
                            }
                            for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
                                var o = n._soundById(i[r]);
                                o && (o._muted = t, o._interval && n._stopFade(o._id), n._webAudio && o._node ? o._node.gain.setValueAtTime(t ? 0 : o._volume, a.ctx.currentTime) : o._node && (o._node.muted = !!a._muted || t), n._emit("mute", o._id))
                            }
                            return n
                        },
                        volume: function() {
                            var t, e, n, i = this,
                                r = arguments;
                            if (0 === r.length) return i._volume;
                            if (1 === r.length || 2 === r.length && void 0 === r[1] ? i._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0]) : r.length >= 2 && (t = parseFloat(r[0]), e = parseInt(r[1], 10)), !(void 0 !== t && t >= 0 && t <= 1)) return (n = e ? i._soundById(e) : i._sounds[0]) ? n._volume : 0;
                            if ("loaded" !== i._state || i._playLock) return i._queue.push({
                                event: "volume",
                                action: function() {
                                    i.volume.apply(i, r)
                                }
                            }), i;
                            void 0 === e && (i._volume = t), e = i._getSoundIds(e);
                            for (var o = 0; o < e.length; o++)(n = i._soundById(e[o])) && (n._volume = t, r[2] || i._stopFade(e[o]), i._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(t, a.ctx.currentTime) : n._node && !n._muted && (n._node.volume = t * a.volume()), i._emit("volume", n._id));
                            return i
                        },
                        fade: function(t, e, n, i) {
                            var r = this;
                            if ("loaded" !== r._state || r._playLock) return r._queue.push({
                                event: "fade",
                                action: function() {
                                    r.fade(t, e, n, i)
                                }
                            }), r;
                            t = parseFloat(t), e = parseFloat(e), n = parseFloat(n), r.volume(t, i);
                            for (var o = r._getSoundIds(i), s = 0; s < o.length; s++) {
                                var c = r._soundById(o[s]);
                                if (c) {
                                    if (i || r._stopFade(o[s]), r._webAudio && !c._muted) {
                                        var u = a.ctx.currentTime,
                                            l = u + n / 1e3;
                                        c._volume = t, c._node.gain.setValueAtTime(t, u), c._node.gain.linearRampToValueAtTime(e, l)
                                    }
                                    r._startFadeInterval(c, t, e, n, o[s], void 0 === i)
                                }
                            }
                            return r
                        },
                        _startFadeInterval: function(t, e, n, i, r, a) {
                            var o = this,
                                s = e,
                                c = n - e,
                                u = Math.abs(c / .01),
                                l = Math.max(4, u > 0 ? i / u : i),
                                h = Date.now();
                            t._fadeTo = n, t._interval = setInterval(function() {
                                var r = (Date.now() - h) / i;
                                h = Date.now(), s += c * r, s = Math.max(0, s), s = Math.min(1, s), s = Math.round(100 * s) / 100, o._webAudio ? t._volume = s : o.volume(s, t._id, !0), a && (o._volume = s), (n < e && s <= n || n > e && s >= n) && (clearInterval(t._interval), t._interval = null, t._fadeTo = null, o.volume(n, t._id), o._emit("fade", t._id))
                            }, l)
                        },
                        _stopFade: function(t) {
                            var e = this._soundById(t);
                            return e && e._interval && (this._webAudio && e._node.gain.cancelScheduledValues(a.ctx.currentTime), clearInterval(e._interval), e._interval = null, this.volume(e._fadeTo, t), e._fadeTo = null, this._emit("fade", t)), this
                        },
                        loop: function() {
                            var t, e, n, i = arguments;
                            if (0 === i.length) return this._loop;
                            if (1 === i.length) {
                                if ("boolean" != typeof i[0]) return !!(n = this._soundById(parseInt(i[0], 10))) && n._loop;
                                t = i[0], this._loop = t
                            } else 2 === i.length && (t = i[0], e = parseInt(i[1], 10));
                            for (var r = this._getSoundIds(e), a = 0; a < r.length; a++)(n = this._soundById(r[a])) && (n._loop = t, this._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = t, t && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop)));
                            return this
                        },
                        rate: function() {
                            var t, e, n, i = this,
                                r = arguments;
                            if (0 === r.length) e = i._sounds[0]._id;
                            else if (1 === r.length) {
                                i._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0])
                            } else 2 === r.length && (t = parseFloat(r[0]), e = parseInt(r[1], 10));
                            if ("number" != typeof t) return (n = i._soundById(e)) ? n._rate : i._rate;
                            if ("loaded" !== i._state || i._playLock) return i._queue.push({
                                event: "rate",
                                action: function() {
                                    i.rate.apply(i, r)
                                }
                            }), i;
                            void 0 === e && (i._rate = t), e = i._getSoundIds(e);
                            for (var o = 0; o < e.length; o++)
                                if (n = i._soundById(e[o])) {
                                    i.playing(e[o]) && (n._rateSeek = i.seek(e[o]), n._playStart = i._webAudio ? a.ctx.currentTime : n._playStart), n._rate = t, i._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(t, a.ctx.currentTime) : n._node && (n._node.playbackRate = t);
                                    var s = i.seek(e[o]),
                                        c = 1e3 * ((i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) / 1e3 - s) / Math.abs(n._rate);
                                    !i._endTimers[e[o]] && n._paused || (i._clearTimer(e[o]), i._endTimers[e[o]] = setTimeout(i._ended.bind(i, n), c)), i._emit("rate", n._id)
                                } return i
                        },
                        seek: function() {
                            var t, e, n = this,
                                i = arguments;
                            if (0 === i.length) e = n._sounds[0]._id;
                            else if (1 === i.length) {
                                n._getSoundIds().indexOf(i[0]) >= 0 ? e = parseInt(i[0], 10) : n._sounds.length && (e = n._sounds[0]._id, t = parseFloat(i[0]))
                            } else 2 === i.length && (t = parseFloat(i[0]), e = parseInt(i[1], 10));
                            if (void 0 === e) return n;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "seek",
                                action: function() {
                                    n.seek.apply(n, i)
                                }
                            }), n;
                            var r = n._soundById(e);
                            if (r) {
                                if (!("number" == typeof t && t >= 0)) {
                                    if (n._webAudio) {
                                        var o = n.playing(e) ? a.ctx.currentTime - r._playStart : 0,
                                            s = r._rateSeek ? r._rateSeek - r._seek : 0;
                                        return r._seek + (s + o * Math.abs(r._rate))
                                    }
                                    return r._node.currentTime
                                }
                                var c = n.playing(e);
                                c && n.pause(e, !0), r._seek = t, r._ended = !1, n._clearTimer(e), n._webAudio || !r._node || isNaN(r._node.duration) || (r._node.currentTime = t);
                                var u = function() {
                                    n._emit("seek", e), c && n.play(e, !0)
                                };
                                if (c && !n._webAudio) {
                                    var l = function() {
                                        n._playLock ? setTimeout(l, 0) : u()
                                    };
                                    setTimeout(l, 0)
                                } else u()
                            }
                            return n
                        },
                        playing: function(t) {
                            if ("number" == typeof t) {
                                var e = this._soundById(t);
                                return !!e && !e._paused
                            }
                            for (var n = 0; n < this._sounds.length; n++)
                                if (!this._sounds[n]._paused) return !0;
                            return !1
                        },
                        duration: function(t) {
                            var e = this._duration,
                                n = this._soundById(t);
                            return n && (e = this._sprite[n._sprite][1] / 1e3), e
                        },
                        state: function() {
                            return this._state
                        },
                        unload: function() {
                            for (var t = this, e = t._sounds, n = 0; n < e.length; n++) {
                                if (e[n]._paused || t.stop(e[n]._id), !t._webAudio) /MSIE |Trident\//.test(a._navigator && a._navigator.userAgent) || (e[n]._node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"), e[n]._node.removeEventListener("error", e[n]._errorFn, !1), e[n]._node.removeEventListener(a._canPlayEvent, e[n]._loadFn, !1), a._releaseHtml5Audio(e[n]._node);
                                delete e[n]._node, t._clearTimer(e[n]._id)
                            }
                            var i = a._howls.indexOf(t);
                            i >= 0 && a._howls.splice(i, 1);
                            var r = !0;
                            for (n = 0; n < a._howls.length; n++)
                                if (a._howls[n]._src === t._src || t._src.indexOf(a._howls[n]._src) >= 0) {
                                    r = !1;
                                    break
                                } return c && r && delete c[t._src], a.noAudio = !1, t._state = "unloaded", t._sounds = [], t = null, null
                        },
                        on: function(t, e, n, i) {
                            var r = this["_on" + t];
                            return "function" == typeof e && r.push(i ? {
                                id: n,
                                fn: e,
                                once: i
                            } : {
                                id: n,
                                fn: e
                            }), this
                        },
                        off: function(t, e, n) {
                            var i = this["_on" + t],
                                r = 0;
                            if ("number" == typeof e && (n = e, e = null), e || n)
                                for (r = 0; r < i.length; r++) {
                                    var a = n === i[r].id;
                                    if (e === i[r].fn && a || !e && a) {
                                        i.splice(r, 1);
                                        break
                                    }
                                } else if (t) this["_on" + t] = [];
                                else {
                                    var o = Object.keys(this);
                                    for (r = 0; r < o.length; r++) 0 === o[r].indexOf("_on") && Array.isArray(this[o[r]]) && (this[o[r]] = [])
                                } return this
                        },
                        once: function(t, e, n) {
                            return this.on(t, e, n, 1), this
                        },
                        _emit: function(t, e, n) {
                            for (var i = this["_on" + t], r = i.length - 1; r >= 0; r--) i[r].id && i[r].id !== e && "load" !== t || (setTimeout(function(t) {
                                t.call(this, e, n)
                            }.bind(this, i[r].fn), 0), i[r].once && this.off(t, i[r].fn, i[r].id));
                            return this._loadQueue(t), this
                        },
                        _loadQueue: function(t) {
                            if (this._queue.length > 0) {
                                var e = this._queue[0];
                                e.event === t && (this._queue.shift(), this._loadQueue()), t || e.action()
                            }
                            return this
                        },
                        _ended: function(t) {
                            var e = t._sprite;
                            if (!this._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop) return setTimeout(this._ended.bind(this, t), 100), this;
                            var n = !(!t._loop && !this._sprite[e][2]);
                            if (this._emit("end", t._id), !this._webAudio && n && this.stop(t._id, !0).play(t._id), this._webAudio && n) {
                                this._emit("play", t._id), t._seek = t._start || 0, t._rateSeek = 0, t._playStart = a.ctx.currentTime;
                                var i = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
                                this._endTimers[t._id] = setTimeout(this._ended.bind(this, t), i)
                            }
                            return this._webAudio && !n && (t._paused = !0, t._ended = !0, t._seek = t._start || 0, t._rateSeek = 0, this._clearTimer(t._id), this._cleanBuffer(t._node), a._autoSuspend()), this._webAudio || n || this.stop(t._id, !0), this
                        },
                        _clearTimer: function(t) {
                            if (this._endTimers[t]) {
                                if ("function" != typeof this._endTimers[t]) clearTimeout(this._endTimers[t]);
                                else {
                                    var e = this._soundById(t);
                                    e && e._node && e._node.removeEventListener("ended", this._endTimers[t], !1)
                                }
                                delete this._endTimers[t]
                            }
                            return this
                        },
                        _soundById: function(t) {
                            for (var e = 0; e < this._sounds.length; e++)
                                if (t === this._sounds[e]._id) return this._sounds[e];
                            return null
                        },
                        _inactiveSound: function() {
                            this._drain();
                            for (var t = 0; t < this._sounds.length; t++)
                                if (this._sounds[t]._ended) return this._sounds[t].reset();
                            return new s(this)
                        },
                        _drain: function() {
                            var t = this._pool,
                                e = 0,
                                n = 0;
                            if (!(this._sounds.length < t)) {
                                for (n = 0; n < this._sounds.length; n++) this._sounds[n]._ended && e++;
                                for (n = this._sounds.length - 1; n >= 0; n--) {
                                    if (e <= t) return;
                                    this._sounds[n]._ended && (this._webAudio && this._sounds[n]._node && this._sounds[n]._node.disconnect(0), this._sounds.splice(n, 1), e--)
                                }
                            }
                        },
                        _getSoundIds: function(t) {
                            if (void 0 === t) {
                                for (var e = [], n = 0; n < this._sounds.length; n++) e.push(this._sounds[n]._id);
                                return e
                            }
                            return [t]
                        },
                        _refreshBuffer: function(t) {
                            return t._node.bufferSource = a.ctx.createBufferSource(), t._node.bufferSource.buffer = c[this._src], t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node), t._node.bufferSource.loop = t._loop, t._loop && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop || 0), t._node.bufferSource.playbackRate.setValueAtTime(t._rate, a.ctx.currentTime), this
                        },
                        _cleanBuffer: function(t) {
                            var e = a._navigator && a._navigator.vendor.indexOf("Apple") >= 0;
                            if (a._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null, t.bufferSource.disconnect(0), e)) try {
                                t.bufferSource.buffer = a._scratchBuffer
                            } catch (n) {}
                            return t.bufferSource = null, this
                        }
                    };
                    var s = function(t) {
                        this._parent = t, this.init()
                    };
                    s.prototype = {
                        init: function() {
                            var t = this._parent;
                            return this._muted = t._muted, this._loop = t._loop, this._volume = t._volume, this._rate = t._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++a._counter, t._sounds.push(this), this.create(), this
                        },
                        create: function() {
                            var t = this._parent,
                                e = a._muted || this._muted || this._parent._muted ? 0 : this._volume;
                            return t._webAudio ? (this._node = void 0 === a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(), this._node.gain.setValueAtTime(e, a.ctx.currentTime), this._node.paused = !0, this._node.connect(a.masterGain)) : (this._node = a._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(a._canPlayEvent, this._loadFn, !1), this._node.src = t._src, this._node.preload = "auto", this._node.volume = e * a.volume(), this._node.load()), this
                        },
                        reset: function() {
                            var t = this._parent;
                            return this._muted = t._muted, this._loop = t._loop, this._volume = t._volume, this._rate = t._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++a._counter, this
                        },
                        _errorListener: function() {
                            this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1)
                        },
                        _loadListener: function() {
                            var t = this._parent;
                            t._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(t._sprite).length && (t._sprite = {
                                __default: [0, 1e3 * t._duration]
                            }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue()), this._node.removeEventListener(a._canPlayEvent, this._loadFn, !1)
                        }
                    };
                    var c = {},
                        u = function(t) {
                            var e = t._src;
                            if (c[e]) return t._duration = c[e].duration, void d(t);
                            if (/^data:[^;]+;base64,/.test(e)) {
                                for (var n = atob(e.split(",")[1]), i = new Uint8Array(n.length), r = 0; r < n.length; ++r) i[r] = n.charCodeAt(r);
                                h(i.buffer, t)
                            } else {
                                var a = new XMLHttpRequest;
                                a.open("GET", e, !0), a.withCredentials = t._xhrWithCredentials, a.responseType = "arraybuffer", a.onload = function() {
                                    var e = (a.status + "")[0];
                                    "0" === e || "2" === e || "3" === e ? h(a.response, t) : t._emit("loaderror", null, "Failed loading audio file with status: " + a.status + ".")
                                }, a.onerror = function() {
                                    t._webAudio && (t._html5 = !0, t._webAudio = !1, t._sounds = [], delete c[e], t.load())
                                }, l(a)
                            }
                        },
                        l = function(t) {
                            try {
                                t.send()
                            } catch (e) {
                                t.onerror()
                            }
                        },
                        h = function(t, e) {
                            var n = function() {
                                    e._emit("loaderror", null, "Decoding audio data failed.")
                                },
                                i = function(t) {
                                    t && e._sounds.length > 0 ? (c[e._src] = t, d(e, t)) : n()
                                };
                            "undefined" != typeof Promise && 1 === a.ctx.decodeAudioData.length ? a.ctx.decodeAudioData(t).then(i).catch(n) : a.ctx.decodeAudioData(t, i, n)
                        },
                        d = function(t, e) {
                            e && !t._duration && (t._duration = e.duration), 0 === Object.keys(t._sprite).length && (t._sprite = {
                                __default: [0, 1e3 * t._duration]
                            }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue())
                        },
                        p = function() {
                            if (a.usingWebAudio) {
                                try {
                                    "undefined" != typeof AudioContext ? a.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? a.ctx = new webkitAudioContext : a.usingWebAudio = !1
                                } catch (r) {
                                    a.usingWebAudio = !1
                                }
                                a.ctx || (a.usingWebAudio = !1);
                                var t = /iP(hone|od|ad)/.test(a._navigator && a._navigator.platform),
                                    e = a._navigator && a._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                    n = e ? parseInt(e[1], 10) : null;
                                if (t && n && n < 9) {
                                    var i = /safari/.test(a._navigator && a._navigator.userAgent.toLowerCase());
                                    (a._navigator && a._navigator.standalone && !i || a._navigator && !a._navigator.standalone && !i) && (a.usingWebAudio = !1)
                                }
                                a.usingWebAudio && (a.masterGain = void 0 === a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(), a.masterGain.gain.setValueAtTime(a._muted ? 0 : 1, a.ctx.currentTime), a.masterGain.connect(a.ctx.destination)), a._setup()
                            }
                        };
                    void 0 === (i = function() {
                        return {
                            Howler: a,
                            Howl: o
                        }
                    }.apply(e, [])) || (t.exports = i), e.Howler = a, e.Howl = o, "undefined" != typeof window ? (window.HowlerGlobal = r, window.Howler = a, window.Howl = o, window.Sound = s) : void 0 !== n && (n.HowlerGlobal = r, n.Howler = a, n.Howl = o, n.Sound = s)
                }(),
                /*!
                 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
                 *  
                 *  howler.js v2.1.1
                 *  howlerjs.com
                 *
                 *  (c) 2013-2018, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */
                function() {
                    "use strict";
                    var t;
                    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t) {
                        if (!this.ctx || !this.ctx.listener) return this;
                        for (var e = this._howls.length - 1; e >= 0; e--) this._howls[e].stereo(t);
                        return this
                    }, HowlerGlobal.prototype.pos = function(t, e, n) {
                        return this.ctx && this.ctx.listener ? (e = "number" != typeof e ? this._pos[1] : e, n = "number" != typeof n ? this._pos[2] : n, "number" != typeof t ? this._pos : (this._pos = [t, e, n], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, .1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, .1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, .1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this
                    }, HowlerGlobal.prototype.orientation = function(t, e, n, i, r, a) {
                        if (!this.ctx || !this.ctx.listener) return this;
                        var o = this._orientation;
                        return e = "number" != typeof e ? o[1] : e, n = "number" != typeof n ? o[2] : n, i = "number" != typeof i ? o[3] : i, r = "number" != typeof r ? o[4] : r, a = "number" != typeof a ? o[5] : a, "number" != typeof t ? o : (this._orientation = [t, e, n, i, r, a], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), this.ctx.listener.upX.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.upY.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.upZ.setTargetAtTime(n, Howler.ctx.currentTime, .1)) : this.ctx.listener.setOrientation(t, e, n, i, r, a), this)
                    }, Howl.prototype.init = (t = Howl.prototype.init, function(e) {
                        return this._orientation = e.orientation || [1, 0, 0], this._stereo = e.stereo || null, this._pos = e.pos || null, this._pannerAttr = {
                            coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : 360,
                            coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : 360,
                            coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : 0,
                            distanceModel: void 0 !== e.distanceModel ? e.distanceModel : "inverse",
                            maxDistance: void 0 !== e.maxDistance ? e.maxDistance : 1e4,
                            panningModel: void 0 !== e.panningModel ? e.panningModel : "HRTF",
                            refDistance: void 0 !== e.refDistance ? e.refDistance : 1,
                            rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : 1
                        }, this._onstereo = e.onstereo ? [{
                            fn: e.onstereo
                        }] : [], this._onpos = e.onpos ? [{
                            fn: e.onpos
                        }] : [], this._onorientation = e.onorientation ? [{
                            fn: e.onorientation
                        }] : [], t.call(this, e)
                    }), Howl.prototype.stereo = function(t, n) {
                        var i = this;
                        if (!i._webAudio) return i;
                        if ("loaded" !== i._state) return i._queue.push({
                            event: "stereo",
                            action: function() {
                                i.stereo(t, n)
                            }
                        }), i;
                        var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                        if (void 0 === n) {
                            if ("number" != typeof t) return i._stereo;
                            i._stereo = t, i._pos = [t, 0, 0]
                        }
                        for (var a = i._getSoundIds(n), o = 0; o < a.length; o++) {
                            var s = i._soundById(a[o]);
                            if (s) {
                                if ("number" != typeof t) return s._stereo;
                                s._stereo = t, s._pos = [t, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || e(s, r), "spatial" === r ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(t, 0, 0) : s._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)), i._emit("stereo", s._id)
                            }
                        }
                        return i
                    }, Howl.prototype.pos = function(t, n, i, r) {
                        var a = this;
                        if (!a._webAudio) return a;
                        if ("loaded" !== a._state) return a._queue.push({
                            event: "pos",
                            action: function() {
                                a.pos(t, n, i, r)
                            }
                        }), a;
                        if (n = "number" != typeof n ? 0 : n, i = "number" != typeof i ? -.5 : i, void 0 === r) {
                            if ("number" != typeof t) return a._pos;
                            a._pos = [t, n, i]
                        }
                        for (var o = a._getSoundIds(r), s = 0; s < o.length; s++) {
                            var c = a._soundById(o[s]);
                            if (c) {
                                if ("number" != typeof t) return c._pos;
                                c._pos = [t, n, i], c._node && (c._panner && !c._panner.pan || e(c, "spatial"), void 0 !== c._panner.positionX ? (c._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), c._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), c._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setPosition(t, n, i)), a._emit("pos", c._id)
                            }
                        }
                        return a
                    }, Howl.prototype.orientation = function(t, n, i, r) {
                        var a = this;
                        if (!a._webAudio) return a;
                        if ("loaded" !== a._state) return a._queue.push({
                            event: "orientation",
                            action: function() {
                                a.orientation(t, n, i, r)
                            }
                        }), a;
                        if (n = "number" != typeof n ? a._orientation[1] : n, i = "number" != typeof i ? a._orientation[2] : i, void 0 === r) {
                            if ("number" != typeof t) return a._orientation;
                            a._orientation = [t, n, i]
                        }
                        for (var o = a._getSoundIds(r), s = 0; s < o.length; s++) {
                            var c = a._soundById(o[s]);
                            if (c) {
                                if ("number" != typeof t) return c._orientation;
                                c._orientation = [t, n, i], c._node && (c._panner || (c._pos || (c._pos = a._pos || [0, 0, -.5]), e(c, "spatial")), void 0 !== c._panner.orientationX ? (c._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime), c._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), c._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setOrientation(t, n, i)), a._emit("orientation", c._id)
                            }
                        }
                        return a
                    }, Howl.prototype.pannerAttr = function() {
                        var t, n, i, r = arguments;
                        if (!this._webAudio) return this;
                        if (0 === r.length) return this._pannerAttr;
                        if (1 === r.length) {
                            if ("object" != typeof r[0]) return (i = this._soundById(parseInt(r[0], 10))) ? i._pannerAttr : this._pannerAttr;
                            t = r[0], void 0 === n && (t.pannerAttr || (t.pannerAttr = {
                                coneInnerAngle: t.coneInnerAngle,
                                coneOuterAngle: t.coneOuterAngle,
                                coneOuterGain: t.coneOuterGain,
                                distanceModel: t.distanceModel,
                                maxDistance: t.maxDistance,
                                refDistance: t.refDistance,
                                rolloffFactor: t.rolloffFactor,
                                panningModel: t.panningModel
                            }), this._pannerAttr = {
                                coneInnerAngle: void 0 !== t.pannerAttr.coneInnerAngle ? t.pannerAttr.coneInnerAngle : this._coneInnerAngle,
                                coneOuterAngle: void 0 !== t.pannerAttr.coneOuterAngle ? t.pannerAttr.coneOuterAngle : this._coneOuterAngle,
                                coneOuterGain: void 0 !== t.pannerAttr.coneOuterGain ? t.pannerAttr.coneOuterGain : this._coneOuterGain,
                                distanceModel: void 0 !== t.pannerAttr.distanceModel ? t.pannerAttr.distanceModel : this._distanceModel,
                                maxDistance: void 0 !== t.pannerAttr.maxDistance ? t.pannerAttr.maxDistance : this._maxDistance,
                                refDistance: void 0 !== t.pannerAttr.refDistance ? t.pannerAttr.refDistance : this._refDistance,
                                rolloffFactor: void 0 !== t.pannerAttr.rolloffFactor ? t.pannerAttr.rolloffFactor : this._rolloffFactor,
                                panningModel: void 0 !== t.pannerAttr.panningModel ? t.pannerAttr.panningModel : this._panningModel
                            })
                        } else 2 === r.length && (t = r[0], n = parseInt(r[1], 10));
                        for (var a = this._getSoundIds(n), o = 0; o < a.length; o++)
                            if (i = this._soundById(a[o])) {
                                var s = i._pannerAttr;
                                s = {
                                    coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : s.coneInnerAngle,
                                    coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : s.coneOuterAngle,
                                    coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : s.coneOuterGain,
                                    distanceModel: void 0 !== t.distanceModel ? t.distanceModel : s.distanceModel,
                                    maxDistance: void 0 !== t.maxDistance ? t.maxDistance : s.maxDistance,
                                    refDistance: void 0 !== t.refDistance ? t.refDistance : s.refDistance,
                                    rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : s.rolloffFactor,
                                    panningModel: void 0 !== t.panningModel ? t.panningModel : s.panningModel
                                };
                                var c = i._panner;
                                c ? (c.coneInnerAngle = s.coneInnerAngle, c.coneOuterAngle = s.coneOuterAngle, c.coneOuterGain = s.coneOuterGain, c.distanceModel = s.distanceModel, c.maxDistance = s.maxDistance, c.refDistance = s.refDistance, c.rolloffFactor = s.rolloffFactor, c.panningModel = s.panningModel) : (i._pos || (i._pos = this._pos || [0, 0, -.5]), e(i, "spatial"))
                            } return this
                    }, Sound.prototype.init = function(t) {
                        return function() {
                            var e = this._parent;
                            this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, t.call(this), this._stereo ? e.stereo(this._stereo) : this._pos && e.pos(this._pos[0], this._pos[1], this._pos[2], this._id)
                        }
                    }(Sound.prototype.init), Sound.prototype.reset = function(t) {
                        return function() {
                            var e = this._parent;
                            return this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, this._stereo ? e.stereo(this._stereo) : this._pos ? e.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, e._refreshBuffer(this)), t.call(this)
                        }
                    }(Sound.prototype.reset);
                    var e = function(t, e) {
                        "spatial" === (e = e || "spatial") ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, void 0 !== t._panner.positionX ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), void 0 !== t._panner.orientationX ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
                    }
                }()
            }).call(this, n("yLpj"))
        },
        Hvzi: function(t, e) {
            t.exports = function(t) {
                var e = this.has(t) && delete this.__data__[t];
                return this.size -= e ? 1 : 0, e
            }
        },
        JHRd: function(t, e, n) {
            var i = n("Kz5y").Uint8Array;
            t.exports = i
        },
        JHgL: function(t, e, n) {
            var i = n("QkVE");
            t.exports = function(t) {
                return i(this, t).get(t)
            }
        },
        JSQU: function(t, e, n) {
            var i = n("YESw"),
                r = "__lodash_hash_undefined__";
            t.exports = function(t, e) {
                var n = this.__data__;
                return this.size += this.has(t) ? 0 : 1, n[t] = i && void 0 === e ? r : e, this
            }
        },
        JTzB: function(t, e, n) {
            var i = n("NykK"),
                r = n("ExA7"),
                a = "[object Arguments]";
            t.exports = function(t) {
                return r(t) && i(t) == a
            }
        },
        "Jo+v": function(t, e, n) {
            t.exports = n("/eQG")
        },
        KMkd: function(t, e) {
            t.exports = function() {
                this.__data__ = [], this.size = 0
            }
        },
        KfNM: function(t, e) {
            var n = Object.prototype.toString;
            t.exports = function(t) {
                return n.call(t)
            }
        },
        Kz5y: function(t, e, n) {
            var i = n("WFqU"),
                r = "object" == typeof self && self && self.Object === Object && self,
                a = i || r || Function("return this")();
            t.exports = a
        },
        L8xA: function(t, e) {
            t.exports = function(t) {
                var e = this.__data__,
                    n = e.delete(t);
                return this.size = e.size, n
            }
        },
        LXxW: function(t, e) {
            t.exports = function(t, e) {
                for (var n = -1, i = null == t ? 0 : t.length, r = 0, a = []; ++n < i;) {
                    var o = t[n];
                    e(o, n, t) && (a[r++] = o)
                }
                return a
            }
        },
        LcsW: function(t, e, n) {
            var i = n("kekF")(Object.getPrototypeOf, Object);
            t.exports = i
        },
        LzdP: function(t, e, n) {
            var i = n("Y7ZC");
            i(i.S, "Date", {
                now: function() {
                    return (new Date).getTime()
                }
            })
        },
        MMmD: function(t, e, n) {
            var i = n("lSCD"),
                r = n("shjB");
            t.exports = function(t) {
                return null != t && r(t.length) && !i(t)
            }
        },
        MrPd: function(t, e, n) {
            var i = n("hypo"),
                r = n("ljhN"),
                a = Object.prototype.hasOwnProperty;
            t.exports = function(t, e, n) {
                var o = t[e];
                a.call(t, e) && r(o, n) && (void 0 !== n || e in t) || i(t, e, n)
            }
        },
        MvSz: function(t, e, n) {
            var i = n("LXxW"),
                r = n("0ycA"),
                a = Object.prototype.propertyIsEnumerable,
                o = Object.getOwnPropertySymbols,
                s = o ? function(t) {
                    return null == t ? [] : (t = Object(t), i(o(t), function(e) {
                        return a.call(t, e)
                    }))
                } : r;
            t.exports = s
        },
        MyG3: function(t, e, n) {
            "use strict";
            n.d(e, "c", function() {
                return s
            }), n.d(e, "a", function() {
                return r
            }), n.d(e, "d", function() {
                return a
            }), n.d(e, "b", function() {
                return o
            });
            var i = n("NzGn"),
                r = function(t, e, n, i) {
                    1e3 != t.code && console.log(t), i.setState({
                        isConnected: !1
                    })
                },
                a = function(t, e, n, i) {},
                o = function(t) {
                    console.log(t)
                },
                s = function(t, e, n, r) {
                    try {
                        var a = JSON.parse(t.data);
                        i.a[a.t](a, e, n, r)
                    } catch (o) {
                        console.error(o)
                    }
                }
        },
        NKxu: function(t, e, n) {
            var i = n("lSCD"),
                r = n("E2jh"),
                a = n("GoyQ"),
                o = n("3Fdi"),
                s = /^\[object .+?Constructor\]$/,
                c = Function.prototype,
                u = Object.prototype,
                l = c.toString,
                h = u.hasOwnProperty,
                d = RegExp("^" + l.call(h).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            t.exports = function(t) {
                return !(!a(t) || r(t)) && (i(t) ? d : s).test(o(t))
            }
        },
        Npjl: function(t, e) {
            t.exports = function(t, e) {
                return null == t ? void 0 : t[e]
            }
        },
        NykK: function(t, e, n) {
            var i = n("nmnc"),
                r = n("AP2z"),
                a = n("KfNM"),
                o = "[object Null]",
                s = "[object Undefined]",
                c = i ? i.toStringTag : void 0;
            t.exports = function(t) {
                return null == t ? void 0 === t ? s : o : c && c in Object(t) ? r(t) : a(t)
            }
        },
        NzGn: function(t, e, n) {
            "use strict";
            var i = n("6BQ9"),
                r = n.n(i),
                a = n("Cg2A"),
                o = n.n(a),
                s = n("0iUn"),
                c = n("sLSF"),
                u = n("Womt"),
                l = n("MI3g"),
                h = n("a7VT"),
                d = n("Tit0"),
                p = function(t) {
                    function e(t, n, i, r, a, o) {
                        var c;
                        return Object(s.default)(this, e), (c = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o))).syncPositions = [], c
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            for (var e, n = t - Math.max(100, this.manager.ping / 2 + 50) - this.manager.serverTimeOffset, i = null, r = null, a = !1, o = 0; o < this.syncPositions.length; o++)
                                if (!a && n - this.syncPositions[o].t < 400 && this.syncPositions[o].t < n) {
                                    if (0 == o) return this.setPosition(this.syncPositions[0].x, this.syncPositions[0].y), void this.setRotation(this.syncPositions[0].r);
                                    r = this.syncPositions[o], i = this.syncPositions[o - 1], e = o, a = !0
                                } if (i && r) {
                                var s = (n - r.t) / (i.t - r.t);
                                this.setPosition(r.x + s * (i.x - r.x), r.y + s * (i.y - r.y));
                                var c = Math.atan2(Math.sin(i.r - r.r), Math.cos(i.r - r.r));
                                this.setRotation(r.r + c * s), this.manager.renderDelays.unshift(t - r.recieved - (i.recieved - r.recieved) * s), this.manager.renderDelays.length > 10 && (this.manager.renderDelays.length = 10), e && (this.syncPositions.length = e + 1)
                            }
                        }
                    }, {
                        key: "updateAttributes",
                        value: function(t) {
                            console.log(t);
                            var e = o()();
                            if (this.syncPositions.length && e - this.syncPositions[0].recieved > 400 && (this.syncPositions = []), this.syncPositions.unshift({
                                    x: Number(t.x),
                                    y: Number(t.y),
                                    t: Number(t.time),
                                    r: Number(t.rotation),
                                    recieved: e
                                }), Boolean(t.teleport))
                                for (var n = 0; n < this.syncPositions.length; n++) e - this.syncPositions[n].recieved <= this.manager.renderDelay() && (this.syncPositions[n].x = Number(t.x), this.syncPositions[n].y = Number(t.y), this.syncPositions[n].r = Number(t.rotation))
                        }
                    }]), e
                }(function() {
                    function t(e, n, i, r, a, o) {
                        Object(s.default)(this, t), this.manager = e, this.position = {
                            x: n,
                            y: i
                        }, this.rotation = r, this.radius = a, this.id = o, this.syncPositions = []
                    }
                    return Object(c.default)(t, [{
                        key: "destroy",
                        value: function() {
                            this.mesh && (this.manager.scene.remove(this.mesh), this.mesh.geometry.dispose(), this.mesh.material.dispose(), this.mesh = void 0)
                        }
                    }, {
                        key: "tick",
                        value: function(t) {}
                    }, {
                        key: "setPosition",
                        value: function(t, e) {
                            this.position.x = t, this.position.y = e, this.mesh && this.mesh.position.set(t, 0, e)
                        }
                    }, {
                        key: "setRotation",
                        value: function(t) {
                            this.rotation = t, this.mesh && this.mesh.rotation.set(0, -1 * t, 0)
                        }
                    }, {
                        key: "updateAttributes",
                        value: function(t) {
                            this.setPosition(Number(t.x), Number(t.y)), this.setRotation(Number(t.rotation))
                        }
                    }, {
                        key: "rotateAroundWorldAxis",
                        value: function(t, e, n) {
                            var i = new u.f;
                            i.makeRotationAxis(e.normalize(), n), i.multiply(t.matrix), t.matrix = i, t.setRotationFromMatrix(t.matrix)
                        }
                    }]), t
                }()),
                f = function() {
                    function t(e, n) {
                        Object(s.default)(this, t), this.manager = e;
                        var i = new u.a(1, 1, 1),
                            r = new u.h({
                                map: this.manager.textures.groundColor
                            });
                        this.mesh = new u.g(i, r), this.mesh.position.set(0, -50, 0), this.mesh.scale.set(n, 1, n), this.manager.scene.add(this.mesh)
                    }
                    return Object(c.default)(t, [{
                        key: "updateScale",
                        value: function(t) {
                            this.mesh.scale.set(t, 1, t)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.mesh && (this.manager.scene.remove(this.mesh), this.mesh.geometry.dispose(), this.mesh.material.dispose(), this.mesh = void 0)
                        }
                    }]), t
                }(),
                m = function() {
                    function t(e, n) {
                        Object(s.default)(this, t), this.manager = e, this.size = Number(n.size), this.bg = new f(e, this.size), this.updateUI()
                    }
                    return Object(c.default)(t, [{
                        key: "updateAttributes",
                        value: function(t) {
                            var e = Number(t.size);
                            e && this.size != e && (this.size = e, this.bg.updateScale(e), this.updateUI())
                        }
                    }, {
                        key: "updateUI",
                        value: function() {
                            var t = window.innerWidth,
                                e = t / 2,
                                n = (window.innerHeight, new u.o(this.size / 2, 0, 0));
                            n.project(this.manager.camera);
                            var i = n.x * e + e,
                                r = -n.x * e + e,
                                a = document.getElementById("rightUI");
                            a && (a.style.right = t - i - 200 - 50 + "px");
                            var o = document.getElementById("logContainer");
                            o && (o.style.left = r - 300 - 30 + "px")
                        }
                    }]), t
                }(),
                v = n("AT/M"),
                g = n("Jo+v"),
                y = n.n(g),
                x = n("j+vE"),
                b = n.n(x);

            function _(t, e, n) {
                return (_ = "undefined" != typeof Reflect && b.a ? b.a : function(t, e, n) {
                    var i = function(t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Object(h.default)(t)););
                        return t
                    }(t, e);
                    if (i) {
                        var r = y()(i, e);
                        return r.get ? r.get.call(n) : r.value
                    }
                })(t, e, n || t)
            }
            var w = function() {
                    function t(e, n, i, r, a, o, c, l, h, d) {
                        Object(s.default)(this, t), this.max = e, this.value = n, this.scene = a, this.x = o, this.y = c, this.z = l, this.width = i, this.height = r;
                        var p = new u.a(1, 1, 1);
                        this.bgMaterial = new u.h({
                            color: h
                        }), this.bg = new u.g(p, this.bgMaterial), this.bg.position.set(o, c, l), this.bg.scale.set(i, 1, r), this.scene.add(this.bg);
                        p = new u.a(1, 1, 1);
                        this.barMaterial = new u.h({
                            color: d
                        }), this.bar = new u.g(p, this.barMaterial), this.bar.position.set(o, c, l), this.bar.scale.set(i, 1, r), this.scene.add(this.bar)
                    }
                    return Object(c.default)(t, [{
                        key: "updateValue",
                        value: function(t) {
                            var e = t / this.max * this.width;
                            this.bar.scale.set(e || 1e-4, 1, this.height)
                        }
                    }, {
                        key: "updatePosition",
                        value: function(t, e) {
                            this.x = t, this.z = e, this.bg.position.set(t, this.y, e), this.bar.position.set(t, this.y, e)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.bg && (this.scene.remove(this.bg), this.bg.geometry && (this.bg.geometry.dispose(), this.bg.material.dispose()), this.bg = void 0), this.bar && (this.scene.remove(this.bar), this.bar.geometry && (this.bar.geometry.dispose(), this.bar.material.dispose()), this.bar = void 0)
                        }
                    }, {
                        key: "goInvisible",
                        value: function() {
                            this.bgMaterial.visible = !1, this.barMaterial.visible = !1
                        }
                    }, {
                        key: "goVisible",
                        value: function() {
                            this.bgMaterial.visible = !0, this.barMaterial.visible = !0
                        }
                    }]), t
                }(),
                M = n("KsUC"),
                T = function() {
                    function t(e, n, i, r, a, o) {
                        Object(s.default)(this, t), this.healthBarOffsetZ = -12, this.healthBar = new w(M.maxHealth, M.maxHealth, 50, 10, o, e + i, r, n + a, 1118481, 7714101), this.shieldBar = new w(M.maxShield, M.maxShield, 50, 10, o, e + i, r, n + a + this.healthBarOffsetZ, 1118481, 3500725), this.offsetX = i, this.offsetY = r, this.offsetZ = a
                    }
                    return Object(c.default)(t, [{
                        key: "updateHealth",
                        value: function(t) {
                            this.healthBar.updateValue(t)
                        }
                    }, {
                        key: "updateShields",
                        value: function(t) {
                            this.shieldBar.updateValue(t)
                        }
                    }, {
                        key: "updatePosition",
                        value: function(t, e) {
                            this.healthBar.updatePosition(t + this.offsetX, e + this.offsetZ), this.shieldBar.updatePosition(t + this.offsetX, e + this.offsetZ + this.healthBarOffsetZ)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.healthBar.destroy(), this.shieldBar.destroy()
                        }
                    }, {
                        key: "goInvisible",
                        value: function() {
                            this.healthBar.goInvisible(), this.shieldBar.goInvisible()
                        }
                    }, {
                        key: "goVisible",
                        value: function() {
                            this.healthBar.goVisible(), this.shieldBar.goVisible()
                        }
                    }]), t
                }(),
                S = function() {
                    function t(e, n) {
                        Object(s.default)(this, t), this.manager = e, this.position = {
                            x: n.x,
                            y: n.y
                        }, this.rotation = n.rotation || 0, null != n.speed && null != n.speed || (n.speed = .5), this.velocity = {
                            x: Math.cos(this.rotation) * n.speed,
                            y: Math.sin(this.rotation) * n.speed
                        }, this.drag = n.drag || 1, this.scale = n.scale || 5, this.lifespan = n.lifespan || 100, this.createdAt = performance.now(), this.opacity = n.opacity || 1, this.fadeTime = Math.min(this.lifespan, n.fadeTime || 50), this.sprite = this.manager.particleBucket.getObject(), this.sprite.material.color = new u.b(r()(n.color) || 11184810), this.sprite.material.opacity = this.opacity, this.sprite.scale.set(n.scale, n.scale, n.scale), this.sprite.position.set(n.x, -20, n.y), this.sprite.rotation.set(-Math.PI / 2, 0, -1 * this.rotation), this.manager.particles.push(this)
                    }
                    return Object(c.default)(t, [{
                        key: "tick",
                        value: function(t) {
                            this.createdAt + this.lifespan <= this.manager.tickStartTime ? this.destroy() : (this.velocity.x = this.velocity.x * this.drag, this.velocity.y = this.velocity.y * this.drag, this.position.x += this.velocity.x * this.manager.deltaTime, this.position.y += this.velocity.y * this.manager.deltaTime, this.sprite.position.set(this.position.x, -20, this.position.y), this.createdAt + this.lifespan - this.fadeTime < this.manager.tickStartTime && (this.sprite.material.opacity = Math.max(0, 1 - (this.manager.tickStartTime - (this.createdAt + this.lifespan - this.fadeTime)) / this.fadeTime)))
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            var t = this.manager.particles.indexOf(this); - 1 != t && this.manager.particles.splice(t, 1), this.sprite && (this.manager.particleBucket.returnObject(this.sprite), this.sprite = void 0)
                        }
                    }]), t
                }(),
                E = n("KsUC"),
                A = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var u;
                        return Object(s.default)(this, e), (u = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o))).name = c, u.manager.ui.addToLog(c + " joined the game."), u.health = E.maxHealth, u.shield = E.maxShield, u.engineDown = !1, u.engineUp = !1, u.engineLeft = !1, u.engineRight = !1, u.engineDownParticleCreated = 0, u.engineUpParticleCreated = 0, u.engineLeftParticleCreated = 0, u.engineRightParticleCreated = 0, u.particleCreateDelay = 80, u.loadMesh(), u.healthBars = new T(n, i, 0, 1, -45, t.scene), u.abilityObjects = [], u
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "loadMesh",
                        value: function() {
                            var t = new u.c(this.radius, this.radius, 15, 32);
                            this.material = this.material(), this.mesh = new u.g(t, this.material), this.mesh.position.set(this.position.x, 0, this.position.y), this.manager.scene.add(this.mesh), t = new u.j(2.5 * this.radius, 2.5 * this.radius);
                            var e = new u.h({
                                map: this.manager.textures.shipGunColor,
                                transparent: !0
                            });
                            this.gunMesh = new u.g(t, e), this.gunMesh.position.set(this.position.x, 20, this.position.y), this.gunMesh.rotation.set(-Math.PI / 2, 0, 0), this.manager.scene.add(this.gunMesh)
                        }
                    }, {
                        key: "updateAttributes",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "updateAttributes", this).call(this, t);
                            var n = Number(t.health),
                                i = Number(t.shield);
                            n != this.health && (this.health = n, this.healthBars.updateHealth(n)), i != this.shield && (this.shield = i, this.healthBars.updateShields(i)), this.engineDown = t.engineDown, this.engineUp = t.engineUp, this.engineLeft = t.engineLeft, this.engineRight = t.engineRight
                        }
                    }, {
                        key: "setPosition",
                        value: function(t, n) {
                            _(Object(h.default)(e.prototype), "setPosition", this).call(this, t, n), this.gunMesh.position.set(t, 20, n), this.healthBars.updatePosition(t, n)
                        }
                    }, {
                        key: "setRotation",
                        value: function(t) {
                            this.rotation = t;
                            if (this.mesh) {
                                var e = 0,
                                    n = 0,
                                    i = 0,
                                    r = 0;
                                this.engineLeft && (n += Math.PI / 10, i -= 5), this.engineRight && (n -= Math.PI / 10, i += 5), this.engineUp && (e -= Math.PI / 10, r -= 5), this.engineDown && (e += Math.PI / 10, r += 5);
                                var a = (new u.f).makeRotationX(e),
                                    o = (new u.f).makeRotationZ(n);
                                a.multiply(o), this.mesh.matrix = a, this.mesh.setRotationFromMatrix(a), this.gunMesh.position.set(this.mesh.position.x + i, 20, this.mesh.position.z + r), this.gunMesh.rotation.set(-Math.PI / 2, 0, -1 * t)
                            }
                        }
                    }, {
                        key: "material",
                        value: function() {
                            return new u.h({
                                map: this.manager.textures.shipColor
                            })
                        }
                    }, {
                        key: "tick",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "tick", this).call(this, t), this.abilityObjects.forEach(function(e) {
                                e.tick(t)
                            }), this.engineLeft && this.engineLeftParticleCreated + this.particleCreateDelay < this.manager.tickStartTime && (new S(this.manager, {
                                x: this.position.x + 10 * Math.random() - 5,
                                y: this.position.y + 10 * Math.random() - 5,
                                rotation: .4 * Math.random() - .2 + 0,
                                scale: 30 * Math.random() + 30,
                                speed: .4,
                                drag: .8,
                                lifespan: 120,
                                color: 5592405,
                                fadeTime: 100
                            }), this.engineLeftParticleCreated = this.manager.tickStartTime), this.engineUp && this.engineUpParticleCreated + this.particleCreateDelay < this.manager.tickStartTime && (new S(this.manager, {
                                x: this.position.x + 10 * Math.random() - 5,
                                y: this.position.y + 10 * Math.random() - 5,
                                rotation: Math.PI / 2 + (.4 * Math.random() - .2),
                                scale: 30 * Math.random() + 30,
                                speed: .4,
                                drag: .8,
                                lifespan: 120,
                                color: 5592405,
                                fadeTime: 100
                            }), this.engineUpParticleCreated = this.manager.tickStartTime), this.engineRight && this.engineRightParticleCreated + this.particleCreateDelay < this.manager.tickStartTime && (new S(this.manager, {
                                x: this.position.x + 10 * Math.random() - 5,
                                y: this.position.y + 10 * Math.random() - 5,
                                rotation: Math.PI + (.4 * Math.random() - .2),
                                scale: 30 * Math.random() + 30,
                                speed: .4,
                                drag: .8,
                                lifespan: 120,
                                color: 5592405,
                                fadeTime: 100
                            }), this.engineRightParticleCreated = this.manager.tickStartTime), this.engineDown && this.engineDownParticleCreated + this.particleCreateDelay < this.manager.tickStartTime && (new S(this.manager, {
                                x: this.position.x + 10 * Math.random() - 5,
                                y: this.position.y + 10 * Math.random() - 5,
                                rotation: -Math.PI / 2 + (.4 * Math.random() - .2),
                                scale: 30 * Math.random() + 30,
                                speed: .4,
                                drag: .8,
                                lifespan: 120,
                                color: 5592405,
                                fadeTime: 100
                            }), this.engineDownParticleCreated = this.manager.tickStartTime)
                        }
                    }, {
                        key: "destroy",
                        value: function(t) {
                            this.gunMesh && (this.manager.scene.remove(this.gunMesh), this.gunMesh.geometry.dispose(), this.gunMesh.material.dispose(), this.gunMesh = void 0), this.abilityObjects.forEach(function(t) {
                                t.destroy()
                            }), this.shieldRechargeEnd(), this.chargeEnd(), this.stunnedEnd(), _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var n = this.manager.ships.indexOf(this); - 1 != n && this.manager.ships.splice(n, 1), t ? this.manager.ui.addToLog(t + " destroyed " + this.name + "'s bot.") : this.manager.ui.addToLog(this.name + "'s bot was destroyed."), this.healthBars.destroy()
                        }
                    }, {
                        key: "goInvisible",
                        value: function() {
                            this.material.visible = !1, this.healthBars.goInvisible()
                        }
                    }, {
                        key: "goVisible",
                        value: function() {
                            this.material.visible = !0, this.healthBars.goVisible()
                        }
                    }, {
                        key: "chargeStart",
                        value: function() {
                            this.chargeEnd(), this.chargeSoundId = this.manager.sounds.charging.play()
                        }
                    }, {
                        key: "chargeEnd",
                        value: function() {
                            this.chargeSoundId && (this.manager.sounds.charging.stop(this.chargeSoundId), this.chargeSoundId = null)
                        }
                    }, {
                        key: "shieldRechargeStart",
                        value: function() {
                            this.shieldRechargeEnd(), this.shieldRechargeSoundId = this.manager.sounds.shieldRecharge.play()
                        }
                    }, {
                        key: "shieldRechargeEnd",
                        value: function() {
                            this.shieldRechargeSoundId && (this.manager.sounds.shieldRecharge.stop(this.shieldRechargeSoundId), this.shieldRechargeSoundId = null)
                        }
                    }, {
                        key: "stunnedStart",
                        value: function() {
                            this.stunnedEnd(), this.stunnedSoundId = this.manager.sounds.stunned.play()
                        }
                    }, {
                        key: "stunnedEnd",
                        value: function() {
                            this.stunnedSoundId && (this.manager.sounds.stunned.stop(this.stunnedSoundId), this.stunnedSoundId = null)
                        }
                    }]), e
                }(p),
                L = n("DzJC"),
                P = n.n(L),
                O = n("p46w"),
                C = n("KsUC"),
                R = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var u;
                        Object(s.default)(this, e), (u = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o, c))).isUpKeyDown = !1, u.isDownKeyDown = !1, u.isRightKeyDown = !1, u.isLeftKeyDown = !1, u.isAbilityDown = [], u.abilityKeys = [];
                        for (var d = 0; d < C.numAbilities; d++) u.isAbilityDown[d] = !1, u.abilityKeys[d] = O.get("abilityKey" + d) || C.abilityKeyDefaults[d];
                        return u.lastMousePosition = {
                            x: null,
                            y: null
                        }, u.throttledMouseUpdate = P()(function(t, e) {
                            u.manager.replay || u.manager.sendToServer({
                                t: "mousemove",
                                x: t,
                                y: e
                            })
                        }, 30), window.addEventListener("keydown", Object(v.default)(u), !1), window.addEventListener("keyup", Object(v.default)(u), !1), window.addEventListener("mousemove", Object(v.default)(u), !1), window.addEventListener("mousedown", Object(v.default)(u), !1), window.addEventListener("mouseup", Object(v.default)(u), !1), window.addEventListener("contextmenu", Object(v.default)(u), !1), u
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "material",
                        value: function() {
                            return new u.h({
                                map: this.manager.textures.playerColor
                            })
                        }
                    }, {
                        key: "updateAttributes",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "updateAttributes", this).call(this, t);
                            var n = document.getElementById("health");
                            n && (n.style.width = this.health / C.maxHealth * 100 + "%");
                            var i = document.getElementById("healthText");
                            i && (i.innerHTML = Math.round(this.health));
                            var r = document.getElementById("shield");
                            r && (r.style.width = this.shield / C.maxShield * 100 + "%");
                            var a = document.getElementById("shieldText");
                            a && (a.innerHTML = Math.round(this.shield))
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this)
                        }
                    }, {
                        key: "handleEvent",
                        value: function(t) {
                            var e = this;
                            switch (t.type) {
                                case "contextmenu":
                                    return t.preventDefault(), !1;
                                case "mousedown":
                                    for (var n = [], i = 0; i < this.abilityKeys.length; i++) "lmb" == this.abilityKeys[i] && 1 == t.which ? n.push(i) : "mmb" == this.abilityKeys[i] && 2 == t.which ? n.push(i) : "rmb" == this.abilityKeys[i] && 3 == t.which && n.push(i);
                                    n.forEach(function(t) {
                                        e.isAbilityDown[t] || (e.manager.sendToServer({
                                            t: "abilityKeyDown",
                                            num: t
                                        }), e.isAbilityDown[t] = !0)
                                    });
                                    break;
                                case "mouseup":
                                    n = [];
                                    for (var r = 0; r < this.abilityKeys.length; r++) "lmb" == this.abilityKeys[r] && 1 == t.which ? n.push(r) : "mmb" == this.abilityKeys[r] && 2 == t.which ? n.push(r) : "rmb" == this.abilityKeys[r] && 3 == t.which && n.push(r);
                                    n.forEach(function(t) {
                                        e.isAbilityDown[t] && (e.manager.sendToServer({
                                            t: "abilityKeyUp",
                                            num: t
                                        }), e.isAbilityDown[t] = !1)
                                    });
                                    break;
                                case "mousemove":
                                    if (t.clientX != this.lastMousePosition.x || t.clientY != this.lastMousePosition.y) {
                                        var a = new u.o;
                                        a.set(t.clientX / window.innerWidth * 2 - 1, -t.clientY / window.innerHeight * 2 + 1, 0), a.unproject(this.manager.camera), this.throttledMouseUpdate(a.x, a.z), this.lastMousePosition = {
                                            x: t.clientX,
                                            y: t.clientY
                                        }
                                    }
                                    break;
                                case "keydown":
                                    switch (t.key) {
                                        case "ArrowUp":
                                        case "w":
                                        case "W":
                                            this.isUpKeyDown || (this.manager.sendToServer({
                                                t: "keyDown",
                                                key: "up"
                                            }), this.isUpKeyDown = !0);
                                            break;
                                        case "ArrowDown":
                                        case "s":
                                        case "S":
                                            this.isDownKeyDown || (this.manager.sendToServer({
                                                t: "keyDown",
                                                key: "down"
                                            }), this.isDownKeyDown = !0);
                                            break;
                                        case "ArrowRight":
                                        case "d":
                                        case "D":
                                            this.isRightKeyDown || (this.manager.sendToServer({
                                                t: "keyDown",
                                                key: "right"
                                            }), this.isRightKeyDown = !0);
                                            break;
                                        case "ArrowLeft":
                                        case "a":
                                        case "A":
                                            this.isLeftKeyDown || (this.manager.sendToServer({
                                                t: "keyDown",
                                                key: "left"
                                            }), this.isLeftKeyDown = !0);
                                            break;
                                        default:
                                            for (var o = 0; o < this.abilityKeys.length; o++) t.code == this.abilityKeys[o] && (this.isAbilityDown[o] || (this.manager.sendToServer({
                                                t: "abilityKeyDown",
                                                num: o
                                            }), this.isAbilityDown[o] = !0))
                                    }
                                    break;
                                case "keyup":
                                    switch (t.key) {
                                        case "ArrowUp":
                                        case "w":
                                        case "W":
                                            this.isUpKeyDown && (this.manager.sendToServer({
                                                t: "keyUp",
                                                key: "up"
                                            }), this.isUpKeyDown = !1);
                                            break;
                                        case "ArrowDown":
                                        case "s":
                                        case "S":
                                            this.isDownKeyDown && (this.manager.sendToServer({
                                                t: "keyUp",
                                                key: "down"
                                            }), this.isDownKeyDown = !1);
                                            break;
                                        case "ArrowRight":
                                        case "d":
                                        case "D":
                                            this.isRightKeyDown && (this.manager.sendToServer({
                                                t: "keyUp",
                                                key: "right"
                                            }), this.isRightKeyDown = !1);
                                            break;
                                        case "ArrowLeft":
                                        case "a":
                                        case "A":
                                            this.isLeftKeyDown && (this.manager.sendToServer({
                                                t: "keyUp",
                                                key: "left"
                                            }), this.isLeftKeyDown = !1);
                                            break;
                                        default:
                                            for (var s = 0; s < this.abilityKeys.length; s++) t.code == this.abilityKeys[s] && this.isAbilityDown[s] && (this.manager.sendToServer({
                                                t: "abilityKeyUp",
                                                num: s
                                            }), this.isAbilityDown[s] = !1)
                                    }
                            }
                        }
                    }, {
                        key: "goInvisible",
                        value: function() {
                            this.mesh.material.visible = !1
                        }
                    }, {
                        key: "goVisible",
                        value: function() {
                            this.mesh.material.opacity = 1
                        }
                    }]), e
                }(A),
                I = function(t) {
                    function e(t, n, i, r, a, o) {
                        var c;
                        Object(s.default)(this, e), c = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o));
                        var d = new u.c(a, a, 1, 32),
                            p = new u.h({
                                color: 6975347,
                                map: c.manager.textures.pillarColor
                            });
                        c.mesh = new u.g(d, p), c.mesh.position.set(c.position.x, 0, c.position.y), c.manager.scene.add(c.mesh);
                        var f = new u.j(5 * a, 5 * a, 1),
                            m = new u.h({
                                color: 0,
                                alphaMap: c.manager.textures.obstacleAoAlpha,
                                transparent: !0
                            });
                        return c.aoMesh = new u.g(f, m), c.aoMesh.position.set(c.position.x, -45, c.position.y), c.aoMesh.rotation.set(-Math.PI / 2, 0, 0), c.manager.scene.add(c.aoMesh), c
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "setPosition",
                        value: function(t, n) {
                            _(Object(h.default)(e.prototype), "setPosition", this).call(this, t, n), this.aoMesh.position.set(t, -45, n)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.aoMesh && (this.manager.scene.remove(this.aoMesh), this.aoMesh.geometry.dispose(), this.aoMesh.material.dispose(), this.aoMesh = void 0), _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.obstacles.indexOf(this); - 1 != t && this.manager.obstacles.splice(t, 1)
                        }
                    }]), e
                }(p),
                D = function(t) {
                    function e(t, n, i, r, a, o) {
                        var c;
                        Object(s.default)(this, e), (c = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, 0, 0, r))).scale = {
                            x: a,
                            y: o
                        };
                        var d = new u.a(1, 1, 1),
                            p = new u.h({
                                color: 5857127
                            });
                        return c.mesh = new u.g(d, p), c.mesh.position.set(c.position.x, 0, c.position.y), c.mesh.scale.set(a, 100, o), c.manager.scene.add(c.mesh), c
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "tick", this).call(this, t)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.boxes.indexOf(this); - 1 != t && this.manager.boxes.splice(t, 1)
                        }
                    }, {
                        key: "updateAttributes",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "updateAttributes", this).call(this, t);
                            var n = Number(t.scaleX),
                                i = Number(t.scaleY);
                            this.scale.x == n && this.scale.y == i || (this.scale.x = n, this.scale.y = i, this.mesh && this.mesh.scale.set(n, 1, i))
                        }
                    }]), e
                }(p),
                j = function(t) {
                    function e(t, n, i, a, o, c, d, p) {
                        var f;
                        return Object(s.default)(this, e), f = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, a, o, c)), setTimeout(function() {
                            f.mesh = f.manager.blasterBulletBucket.getObject(), f.mesh.scale.set(6 * f.radius, 6 * f.radius, 6 * f.radius), f.mesh.position.set(f.position.x, -.5, f.position.y), f.mesh.rotation.set(-Math.PI / 2, 0, -1 * f.rotation), f.mesh.material.color = new u.b(r()(d)), new S(f.manager, {
                                x: f.position.x,
                                y: f.position.y,
                                rotation: f.rotation,
                                scale: 80,
                                speed: .25,
                                drag: 0,
                                lifespan: 100,
                                color: r()(d),
                                fadeTime: 80
                            }), p && (f.soundId = f.manager.sounds.blaster.play(), f.manager.sounds.blaster.volume(.4 * Math.random() + .1, f.soundId), f.manager.sounds.blaster.rate(.2 * Math.random() + .9, f.soundId))
                        }, f.manager.renderDelay), f
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "setRotation",
                        value: function(t) {
                            this.rotation = t, this.mesh && this.mesh.rotation.set(-Math.PI / 2, 0, -1 * t)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.mesh && (this.manager.blasterBulletBucket.returnObject(this.mesh), this.mesh = void 0), _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                N = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var d;
                        Object(s.default)(this, e), (d = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o))).ship = c;
                        var p = new u.j(4 * d.radius, 4 * d.radius),
                            f = new u.h({
                                color: 3500725,
                                alphaMap: d.manager.textures.forceFieldAlpha,
                                transparent: !0
                            });
                        return d.mesh = new u.g(p, f), d.mesh.position.set(d.ship.position.x, 0, d.ship.position.y), d.mesh.rotation.set(-Math.PI / 2, 0, 0), d.manager.scene.add(d.mesh), d.manager.sounds.forceField.play(), d
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            this.mesh.position.set(this.ship.position.x, 0, this.ship.position.y)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                k = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var u;
                        return Object(s.default)(this, e), (u = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o))).color = c, u.createMesh(), u
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "createMesh",
                        value: function() {
                            var t = new u.j(2 * this.radius, 2 * this.radius),
                                e = new u.h({
                                    color: this.color
                                });
                            this.mesh = new u.g(t, e), this.mesh.position.set(this.position.x, -.5, this.position.y), this.mesh.rotation.set(-Math.PI / 2, 0, -1 * this.rotation), this.manager.scene.add(this.mesh)
                        }
                    }, {
                        key: "setRotation",
                        value: function(t) {
                            this.rotation = t, this.mesh && this.mesh.rotation.set(-Math.PI / 2, 0, -1 * this.rotation)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                z = function(t) {
                    function e(t, n, i, a, o, c, d) {
                        var p;
                        if (Object(s.default)(this, e), (p = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, a, o, c))).radius = o, p.mesh = p.manager.explosionBucket.getObject(), p.mesh.position.set(p.position.x, 0, p.position.y), p.mesh.material.color = new u.b(r()(d)), p.mesh.scale.set(1, 1, 1), p.radius > 30) {
                            for (var f = 0; f < 10; f++) new S(p.manager, {
                                x: p.position.x,
                                y: p.position.y,
                                rotation: Math.random() * Math.PI * 2,
                                scale: 40,
                                speed: p.radius / 60,
                                drag: .8,
                                lifespan: 200,
                                color: r()(d),
                                fadeTime: 150
                            });
                            p.soundId = p.manager.sounds.explosionLarge.play(), p.manager.sounds.explosionLarge.volume(.5 * Math.random() + .5, p.soundId)
                        } else p.soundId = p.manager.sounds.explosionSmall.play(), p.manager.sounds.explosionSmall.volume(.4 * Math.random() + .2, p.soundId), p.manager.sounds.explosionSmall.rate(.4 * Math.random() + .8, p.soundId);
                        return p
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "setRotation",
                        value: function(t) {
                            this.rotation = t
                        }
                    }, {
                        key: "tick",
                        value: function(t) {
                            var e = this.mesh.scale.x;
                            (e += 6 * this.radius / 5) <= 6 * this.radius ? this.mesh.scale.set(e, e, e) : this.destroy()
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.manager.explosionBucket.returnObject(this.mesh), this.mesh = void 0, _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                B = function(t) {
                    function e(t, n, i, r) {
                        var a;
                        Object(s.default)(this, e), (a = Object(l.default)(this, Object(h.default)(e).call(this, t, r.position.x, r.position.y, r.rotation, n, i))).ship = r;
                        var o = new u.h({
                            color: 12303291
                        });
                        return a.mesh = new u.g(a.manager.smasherSpikesGeometry, o), a.mesh.position.set(a.position.x, 0, a.position.y), a.mesh.rotation.set(Math.PI / 2, 0, a.ship.rotation), a.mesh.scale.set(n, n, n), a.manager.scene.add(a.mesh), a.manager.sounds.smasher.play(), a
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            this.mesh.position.set(this.ship.position.x, 0, this.ship.position.y), this.mesh.rotation.set(Math.PI / 2, 0, this.ship.rotation)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                U = function(t) {
                    function e(t, n, i, r, a, o) {
                        var c;
                        Object(s.default)(this, e), (c = Object(l.default)(this, Object(h.default)(e).call(this, t, i, r, o.rotation, n, a))).ship = o;
                        var d = new u.j(1, 1),
                            p = new u.h({
                                color: new u.b(8947848),
                                alphaMap: c.manager.textures.forceFieldAlpha,
                                transparent: !0
                            });
                        return c.mesh = new u.g(d, p), c.mesh.position.set(i, 0, r), c.mesh.rotation.set(-Math.PI / 2, 0, 0), c.mesh.scale.set(20, 1, 20), c.manager.scene.add(c.mesh), c.manager.sounds.slam.play(), c
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            var e = this.mesh.scale.x;
                            (e += 4 * this.radius / 10) <= 4 * this.radius ? this.mesh.scale.set(e, e, e) : this.destroy()
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                G = function(t) {
                    function e(t, n, i, r, a) {
                        var o;
                        return Object(s.default)(this, e), (o = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, 0, r, a))).radius = r, setTimeout(function() {
                            var t = new u.c(1, 1, .5, 32),
                                e = new u.h({
                                    color: 3500725
                                });
                            o.mesh = new u.g(t, e), o.mesh.position.set(o.position.x, 0, o.position.y), o.manager.scene.add(o.mesh), o.manager.sounds.emp.play()
                        }, o.manager.renderDelay), o
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            if (this.mesh) {
                                var e = this.mesh.scale.x;
                                (e += this.radius / 5) < this.radius ? this.mesh.scale.set(e, 1, e) : this.destroy()
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                F = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var u;
                        return Object(s.default)(this, e), (u = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o, c))).color = c, u.manager.sounds.stunGun.play(), u
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "tick", this).call(this, t), new S(this.manager, {
                                x: this.position.x,
                                y: this.position.y,
                                rotation: 0,
                                scale: 30 * Math.random() + 20,
                                speed: 0,
                                drag: 0,
                                lifespan: 100,
                                color: 6710886,
                                fadeTime: 100
                            })
                        }
                    }]), e
                }(j),
                H = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var u;
                        return Object(s.default)(this, e), (u = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o, c))).color = c, u.manager.sounds.blaster.play(), u
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "tick", this).call(this, t), new S(this.manager, {
                                x: this.position.x,
                                y: this.position.y,
                                rotation: 0,
                                scale: 30 * Math.random() + 20,
                                speed: 0,
                                drag: 0,
                                lifespan: 100,
                                color: 16755370,
                                fadeTime: 100
                            })
                        }
                    }]), e
                }(j),
                V = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var d;
                        Object(s.default)(this, e), (d = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o))).health = c, d.maxHealth = c;
                        var p = new u.c(d.radius, d.radius, .1, 12),
                            f = new u.h({
                                map: d.manager.textures.turretColor
                            });
                        d.mesh = new u.g(p, f), d.mesh.position.set(d.position.x, 0, d.position.y), d.mesh.setRotationFromAxisAngle(new u.o(0, 1, 0), -1 * d.rotation), d.manager.scene.add(d.mesh);
                        var m = new u.j(2.5 * d.radius, 2.5 * d.radius),
                            v = new u.h({
                                map: d.manager.textures.shipGunColor,
                                transparent: !0
                            });
                        return d.gunMesh = new u.g(m, v), d.gunMesh.position.set(d.position.x, 20, d.position.y), d.gunMesh.rotation.set(-Math.PI / 2, 0, 0), d.manager.scene.add(d.gunMesh), d.offsetX = 0, d.offsetY = 0, d.offsetZ = -35, d.healthBar = new w(d.maxHealth, d.maxHealth, 50, 10, t.scene, n + d.offsetX, d.offsetY, i + d.offsetZ, 1118481, 7714101), d.manager.sounds.turret.play(), d
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "updateAttributes",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "updateAttributes", this).call(this, t), this.health = Number(t.health), this.healthBar.updateValue(this.health)
                        }
                    }, {
                        key: "setPosition",
                        value: function(t, n) {
                            _(Object(h.default)(e.prototype), "setPosition", this).call(this, t, n), this.healthBar.updatePosition(t + this.offsetX, n + this.offsetZ), this.gunMesh.position.set(t, 20, n)
                        }
                    }, {
                        key: "setRotation",
                        value: function(t) {
                            this.rotation = t, this.gunMesh && this.gunMesh.rotation.set(-Math.PI / 2, 0, -1 * t)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.gunMesh && (this.manager.scene.remove(this.gunMesh), this.gunMesh.geometry.dispose(), this.gunMesh.material.dispose(), this.gunMesh = void 0), this.healthBar.destroy(), _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                W = 3500725,
                q = function(t) {
                    function e(t, n, i, r) {
                        var a;
                        return Object(s.default)(this, e), (a = Object(l.default)(this, Object(h.default)(e).call(this, t, r.position.x, r.position.y, r.rotation, n, i))).ship = r, setTimeout(function() {
                            var t = new u.c(1, 1, .1, 32),
                                e = new u.h({
                                    color: W
                                });
                            a.mesh = new u.g(t, e), a.mesh.position.set(a.position.x, 0, a.position.y), a.manager.scene.add(a.mesh);
                            for (var n = 0; n < 20; n++) new S(a.manager, {
                                x: a.position.x,
                                y: a.position.y,
                                rotation: Math.random() * Math.PI * 2,
                                scale: 40,
                                speed: 2,
                                drag: .8,
                                lifespan: 150,
                                color: W,
                                fadeTime: 80
                            });
                            a.manager.sounds.slam.play()
                        }, a.renderDelay), a
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            if (this.mesh) {
                                this.mesh.position.set(this.ship.position.x, 0, this.ship.position.y);
                                var e = this.mesh.scale.x;
                                (e += this.radius / 6) <= this.radius ? this.mesh.scale.set(e, 1, e) : this.destroy()
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                X = function t(e, n, i, a, o) {
                    Object(s.default)(this, t);
                    for (var c = 0; c < 5; c++) new S(e, {
                        x: n,
                        y: i,
                        rotation: a + (.5 * Math.random() - .25),
                        scale: 60,
                        speed: 2 * Math.random(),
                        drag: .8,
                        lifespan: 200,
                        color: r()(o),
                        fadeTime: 150
                    }), e.sounds.cannon.play()
                },
                Y = (n("HlzF"), function(t) {
                    function e(t, n, i, r, a, o) {
                        var c;
                        return Object(s.default)(this, e), (c = Object(l.default)(this, Object(h.default)(e).call(this, t, r ? r.position.x : a, r ? r.position.y : o, 0, n, i))).ship = r, c.ship ? c.ship.abilityObjects.push(Object(v.default)(c)) : c.manager.abilityObjects.push(Object(v.default)(c)), c.particles = [], c.soundId = c.manager.sounds.vacuum.play(), c
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            for (var e = 0; e < 5; e++) {
                                var n = Math.random() * Math.PI * 2,
                                    i = this.ship ? this.ship.position.x : this.position.x,
                                    r = this.ship ? this.ship.position.y : this.position.y;
                                new S(this.manager, {
                                    x: i + Math.cos(n) * this.radius,
                                    y: r + Math.sin(n) * this.radius,
                                    rotation: n + Math.PI,
                                    scale: 10 * Math.random() + 16,
                                    speed: 2,
                                    drag: .8,
                                    lifespan: 100,
                                    color: 3500725,
                                    fadeTime: 100
                                })
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            if (this.manager.sounds.vacuum.stop(this.soundId), this.particles.forEach(function(t) {
                                    t.destroy()
                                }), _(Object(h.default)(e.prototype), "destroy", this).call(this), this.ship) {
                                var t = this.ship.abilityObjects.indexOf(this); - 1 != t && this.ship.abilityObjects.splice(t, 1)
                            } else {
                                var n = this.manager.abilityObjects.indexOf(this); - 1 != n && this.manager.abilityObjects.splice(n, 1)
                            }
                        }
                    }]), e
                }(p)),
                Z = function(t) {
                    function e(t, n, i, r, a, o, c) {
                        var u;
                        return Object(s.default)(this, e), (u = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a / 2, o, c))).manager.sounds.mineDropper.play(), u
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "createMesh",
                        value: function() {
                            var t = new u.j(8 * this.radius, 8 * this.radius),
                                e = new u.h({
                                    color: this.color,
                                    transparent: !0,
                                    alphaMap: this.manager.textures.mineAlpha
                                });
                            this.mesh = new u.g(t, e), this.mesh.position.set(this.position.x, -.5, this.position.y), this.mesh.rotation.set(-Math.PI / 2, 0, -1 * this.rotation), this.manager.scene.add(this.mesh)
                        }
                    }]), e
                }(k),
                J = function(t) {
                    function e(t, n, i, r, a, o) {
                        var c;
                        Object(s.default)(this, e), (c = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, o.rotation, r, a))).ship = o;
                        var d = new u.c(1, 1, .1, 32),
                            p = new u.h({
                                color: 6710886
                            });
                        return c.mesh = new u.g(d, p), c.mesh.position.set(o.position.x, 0, o.position.y), c.manager.scene.add(c.mesh), c.manager.sounds.silencer.play(), c
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            var e = this.mesh.scale.x;
                            (e += this.radius / 5) <= this.radius ? this.mesh.scale.set(e, 1, e) : this.destroy()
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                K = function(t) {
                    function e(t, n, i, r, a, o) {
                        var c;
                        return Object(s.default)(this, e), c = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, r, a, o)), setTimeout(function() {
                            var e = new u.a(2 * c.radius, .1, 2 * c.radius),
                                n = new u.h({
                                    color: 16759620
                                });
                            c.mesh = new u.g(e, n), c.mesh.position.set(c.position.x, -.5, c.position.y), c.mesh.setRotationFromAxisAngle(new u.o(0, 1, 0), -1 * c.rotation), c.manager.scene.add(c.mesh), c.soundId = t.sounds.cannon.play()
                        }, c.manager.renderDelay), c
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "destroy",
                        value: function(t, n, i) {
                            var r = this;
                            new z(this.manager, n, i, 0, 50, Math.random(), 16759620), this.vacuumEffect = new Y(this.manager, t, Math.random(), null, n, i), _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var a = this.manager.abilityObjects.indexOf(this); - 1 != a && this.manager.abilityObjects.splice(a, 1), setTimeout(function() {
                                r.vacuumEffect.destroy()
                            }, 300)
                        }
                    }]), e
                }(p),
                Q = function(t) {
                    function e(t, n, i, r) {
                        var a;
                        Object(s.default)(this, e), a = Object(l.default)(this, Object(h.default)(e).call(this, t, n, i, 0, r, Math.random()));
                        var o = new u.j(4 * a.radius, 4 * a.radius),
                            c = new u.h({
                                color: 3500725,
                                alphaMap: a.manager.textures.particleAlpha,
                                transparent: !0,
                                alphaTest: .1
                            });
                        return a.mesh = new u.g(o, c), a.mesh.position.set(a.position.x, 0, a.position.y), a.mesh.rotation.set(-Math.PI / 2, 0, 0), a.manager.scene.add(a.mesh), a.manager.sounds.teleport.play(), setTimeout(function() {
                            a.destroy()
                        }, 300), a
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                $ = function(t) {
                    function e(t, n, i, r) {
                        var a;
                        Object(s.default)(this, e), (a = Object(l.default)(this, Object(h.default)(e).call(this, t, r.position.x, r.position.y, r.rotation, n, i))).ship = r;
                        var o = new u.h({
                            color: 12303291
                        });
                        return a.mesh = new u.g(a.manager.slicerSpikesGeometry, o), a.mesh.position.set(a.position.x, 0, a.position.y), a.mesh.rotation.set(Math.PI / 2, 0, 0), a.mesh.scale.set(n, n, n), a.manager.scene.add(a.mesh), a.manager.sounds.smasher.play(), a
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            this.mesh.position.set(this.ship.position.x, -1, this.ship.position.y), this.mesh.rotation.set(Math.PI / 2, 0, this.mesh.rotation.z + .08)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                tt = function(t) {
                    function e(t, n) {
                        var i;
                        return Object(s.default)(this, e), (i = Object(l.default)(this, Object(h.default)(e).call(this, t, n.position.x, n.position.y, n.rotation, n.radius, Math.random()))).ship = n, t.sounds.boost.play(), setTimeout(function() {
                            i.destroy()
                        }, 425), i
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "tick", this).call(this, t), new S(this.manager, {
                                x: this.ship.position.x + 20 * Math.random() - 10,
                                y: this.ship.position.y + 20 * Math.random() - 10,
                                rotation: this.ship.rotation,
                                scale: 30 * Math.random() + 30,
                                speed: 0,
                                drag: 0,
                                lifespan: 200,
                                color: 6710886,
                                fadeTime: 180
                            }), new S(this.manager, {
                                x: this.ship.position.x,
                                y: this.ship.position.y,
                                rotation: this.ship.rotation,
                                scale: 20,
                                speed: 0,
                                drag: 0,
                                lifespan: 250,
                                color: 16737894,
                                fadeTime: 180
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                et = function(t) {
                    function e(t, n, i) {
                        var r;
                        return Object(s.default)(this, e), (r = Object(l.default)(this, Object(h.default)(e).call(this, t, n.position.x, n.position.y, n.rotation, n.radius, i))).ship = n, t.sounds.boost.play(), r
                    }
                    return Object(d.default)(e, t), Object(c.default)(e, [{
                        key: "tick",
                        value: function(t) {
                            _(Object(h.default)(e.prototype), "tick", this).call(this, t), new S(this.manager, {
                                x: this.ship.position.x + 20 * Math.random() - 10,
                                y: this.ship.position.y + 20 * Math.random() - 10,
                                rotation: this.ship.rotation,
                                scale: 30 * Math.random() + 30,
                                speed: 0,
                                drag: 0,
                                lifespan: 200,
                                color: 6710886,
                                fadeTime: 180
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            _(Object(h.default)(e.prototype), "destroy", this).call(this);
                            var t = this.manager.abilityObjects.indexOf(this); - 1 != t && this.manager.abilityObjects.splice(t, 1)
                        }
                    }]), e
                }(p),
                nt = {
                    mass: function(t, e, n, i) {
                        for (var r = 0; r < t.m.length; r++) try {
                            nt[t.m[r].t](t.m[r], e, n, i)
                        } catch (a) {
                            console.log(t.m[r].t), console.error(a)
                        }
                    },
                    gameId: function(t, e, n, i) {
                        window.location.href = "/game/" + i.props.server._id + "/" + t.gameId
                    },
                    spectatorInitial: function(t, e, n, i) {
                        var r = document.getElementById("rightUI");
                        r && (r.style.display = "none")
                    },
                    pong: function(t, e, n, i) {
                        var r = o()(),
                            a = r - e.pingStart;
                        e.pings.unshift(a), e.pings.length > 10 && e.pings.pop(), e.ping = e.pings.reduce(function(t, e) {
                            return t + e
                        }, 0) / e.pings.length, e.serverTimeOffset = r - Number(t.time) - a / 2;
                        var s = document.getElementById("ping");
                        s && (s.innerHTML = Math.round(e.ping / 2))
                    },
                    spectatorJoined: function(t, e, n, i) {
                        i.addToLog(t.name + " is spectating.")
                    },
                    serverTickStats: function(t, e, n, i) {
                        var r = document.getElementById("serverTickTime");
                        r && (r.innerHTML = Math.round(100 * Number(t.serverTickTime)) / 100)
                    },
                    winner: function(t, e, n, i) {
                        i.setState({
                            winner: t.name
                        }), e.sounds.gameOver.play()
                    },
                    text: function(t, e, n, i) {
                        i.addToLog(t.m), e.sounds.countdown.play()
                    },
                    gameStarted: function(t, e, n, i) {
                        i.addToLog("Game started."), e.sounds.gameStart.play()
                    },
                    abilityCooldown: function(t, e, n, i) {
                        i.cooldownData[Number(t.num)] = {
                            lastFired: o()(),
                            cooldown: Number(t.cooldown)
                        }
                    },
                    abilityCooldownFull: function(t, e, n, i) {
                        i.cooldownData[Number(t.num)] = {
                            lastFired: o()() - Number(t.cooldown),
                            cooldown: Number(t.cooldown)
                        }
                    },
                    mapInitial: function(t, e, n, i) {
                        e.map = new m(e, t)
                    },
                    mapUpdate: function(t, e) {
                        e.map.updateAttributes(t)
                    },
                    clientDisconnected: function(t, e, n, i) {
                        i.addToLog(t.name + " disconnected.")
                    },
                    playerInitial: function(t, e) {
                        var n = new R(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, t.name);
                        e.player = n, e.ships.push(n)
                    },
                    shipInitial: function(t, e) {
                        e.ships.push(new A(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, t.name))
                    },
                    shipDestroy: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy(t.killer && t.killer.length ? t.killer : null)
                        }, e.renderDelay())
                    },
                    shipUpdate: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    obstacleInitial: function(t, e) {
                        e.obstacles.push(new I(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id))
                    },
                    obstacleDestroy: function(t, e) {
                        var n = e.obstacles.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    obstacleUpdate: function(t, e) {
                        var n = e.obstacles.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    boxInitial: function(t, e) {
                        e.boxes.push(new D(e, Number(t.x), Number(t.y), t.id, Number(t.scaleX), Number(t.scaleY)))
                    },
                    boxDestroy: function(t, e) {
                        var n = e.boxes.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    boxUpdate: function(t, e) {
                        var n = e.boxes.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    blasterBulletInitial: function(t, e) {
                        e.abilityObjects.push(new j(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, t.color, t.playSound))
                    },
                    blasterBulletUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    blasterBulletDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    blast: function(t, e) {
                        new X(e, Number(t.x), Number(t.y), Number(t.rotation), t.color)
                    },
                    shieldBubbleInitial: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && e.abilityObjects.push(new N(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, n))
                    },
                    shieldBubbleUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    shieldBubbleDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    grenadeInitial: function(t, e) {
                        e.abilityObjects.push(new k(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, r()(t.color)))
                    },
                    grenadeUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    grenadeDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    vortexGrenadeInitial: function(t, e) {
                        e.abilityObjects.push(new K(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id))
                    },
                    vortexGrenadeUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    vortexGrenadeDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy(Number(t.radius), Number(t.x), Number(t.y))
                        }, e.renderDelay())
                    },
                    mineInitial: function(t, e) {
                        e.abilityObjects.push(new Z(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, r()(t.color)))
                    },
                    mineUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    mineDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    explosionInitial: function(t, e) {
                        setTimeout(function() {
                            e.abilityObjects.push(new z(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, t.color))
                        }, e.renderDelay())
                    },
                    explosionUpdate: function() {},
                    explosionDestroy: function(t, e) {},
                    smasherSpikesInitial: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && e.abilityObjects.push(new B(e, Number(t.radius), t.id, n))
                    },
                    smasherSpikesDestroyed: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.destroy()
                    },
                    slicerSpikesInitial: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && e.abilityObjects.push(new $(e, Number(t.radius), t.id, n))
                    },
                    slicerSpikesDestroyed: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    slamInitial: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            e.abilityObjects.push(new U(e, Number(t.radius), Number(t.x), Number(t.y), t.id, n))
                        }, e.renderDelay())
                    },
                    silencerInitial: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            e.abilityObjects.push(new J(e, Number(t.x), Number(t.y), Number(t.radius), t.id, n))
                        }, e.renderDelay())
                    },
                    freezeInitial: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            e.abilityObjects.push(new q(e, Number(t.radius), t.id, n))
                        }, e.renderDelay())
                    },
                    goInvisible: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && n.goInvisible()
                    },
                    goVisible: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && n.goVisible()
                    },
                    empInitial: function(t, e) {
                        e.ships.find(function(e) {
                            return e.id == t.shipId
                        }) && setTimeout(function() {
                            e.abilityObjects.push(new G(e, Number(t.x), Number(t.y), Number(t.radius), t.id))
                        }, e.renderDelay())
                    },
                    stunGunBulletInitial: function(t, e) {
                        e.abilityObjects.push(new F(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, t.color))
                    },
                    stunGunBulletUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    stunGunBulletDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    playerSeekingMissleInitial: function(t, e) {
                        e.abilityObjects.push(new H(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, t.color))
                    },
                    playerSeekingMissleUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    playerSeekingMissleDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    turretInitial: function(t, e) {
                        e.abilityObjects.push(new V(e, Number(t.x), Number(t.y), Number(t.rotation), Number(t.radius), t.id, Number(t.health)))
                    },
                    turretUpdate: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && n.updateAttributes(t)
                    },
                    turretDestroy: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    vacuumStart: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && new Y(e, Number(t.radius), t.id, n)
                    },
                    vacuumEnd: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        if (n) {
                            var i = n.abilityObjects.find(function(e) {
                                return e.id == t.id
                            });
                            i && setTimeout(function() {
                                i.destroy()
                            }, e.renderDelay())
                        }
                    },
                    boostStart: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && e.abilityObjects.push(new et(e, n, t.id))
                    },
                    boostEnd: function(t, e) {
                        var n = e.abilityObjects.find(function(e) {
                            return e.id == t.id
                        });
                        n && setTimeout(function() {
                            n.destroy()
                        }, e.renderDelay())
                    },
                    dashInitial: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            e.abilityObjects.push(new tt(e, n))
                        }, e.renderDelay())
                    },
                    bulletTimeInitial: function(t, e) {
                        setTimeout(function() {
                            e.sounds.bulletTime.play()
                        }, e.renderDelay())
                    },
                    rageStart: function(t, e) {
                        setTimeout(function() {
                            e.sounds.rage.play()
                        }, e.renderDelay())
                    },
                    chargeStart: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            n.chargeStart()
                        }, e.renderDelay())
                    },
                    chargeEnd: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            n.chargeEnd()
                        }, e.renderDelay())
                    },
                    shieldRechargeStart: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            n.shieldRechargeStart()
                        }, e.renderDelay())
                    },
                    shieldRechargeEnd: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            n.shieldRechargeEnd()
                        }, e.renderDelay())
                    },
                    stunnedStart: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            n.stunnedStart()
                        }, e.renderDelay())
                    },
                    stunnedEnd: function(t, e) {
                        var n = e.ships.find(function(e) {
                            return e.id == t.shipId
                        });
                        n && setTimeout(function() {
                            n.stunnedEnd()
                        }, e.renderDelay())
                    },
                    reviveInitial: function(t, e) {
                        setTimeout(function() {
                            e.sounds.teleport.play()
                        }, e.renderDelay())
                    },
                    teleportInitial: function(t, e) {
                        e.abilityObjects.push(new Q(e, Number(t.x), Number(t.y), Number(t.radius)))
                    }
                };
            e.a = nt
        },
        O0oS: function(t, e, n) {
            var i = n("Cwc5"),
                r = function() {
                    try {
                        var t = i(Object, "defineProperty");
                        return t({}, "", {}), t
                    } catch (e) {}
                }();
            t.exports = r
        },
        OBhP: function(t, e, n) {
            var i = n("fmRc"),
                r = n("gFfm"),
                a = n("MrPd"),
                o = n("WwFo"),
                s = n("Dw+G"),
                c = n("5Tg0"),
                u = n("Q1l4"),
                l = n("VOtZ"),
                h = n("EEGq"),
                d = n("qZTm"),
                p = n("G6z8"),
                f = n("QqLw"),
                m = n("yHx3"),
                v = n("wrZu"),
                g = n("+iFO"),
                y = n("Z0cm"),
                x = n("DSRE"),
                b = n("zEVN"),
                _ = n("GoyQ"),
                w = n("1+5i"),
                M = n("7GkX"),
                T = 1,
                S = 2,
                E = 4,
                A = "[object Arguments]",
                L = "[object Function]",
                P = "[object GeneratorFunction]",
                O = "[object Object]",
                C = {};
            C[A] = C["[object Array]"] = C["[object ArrayBuffer]"] = C["[object DataView]"] = C["[object Boolean]"] = C["[object Date]"] = C["[object Float32Array]"] = C["[object Float64Array]"] = C["[object Int8Array]"] = C["[object Int16Array]"] = C["[object Int32Array]"] = C["[object Map]"] = C["[object Number]"] = C[O] = C["[object RegExp]"] = C["[object Set]"] = C["[object String]"] = C["[object Symbol]"] = C["[object Uint8Array]"] = C["[object Uint8ClampedArray]"] = C["[object Uint16Array]"] = C["[object Uint32Array]"] = !0, C["[object Error]"] = C[L] = C["[object WeakMap]"] = !1, t.exports = function t(e, n, R, I, D, j) {
                var N, k = n & T,
                    z = n & S,
                    B = n & E;
                if (R && (N = D ? R(e, I, D, j) : R(e)), void 0 !== N) return N;
                if (!_(e)) return e;
                var U = y(e);
                if (U) {
                    if (N = m(e), !k) return u(e, N)
                } else {
                    var G = f(e),
                        F = G == L || G == P;
                    if (x(e)) return c(e, k);
                    if (G == O || G == A || F && !D) {
                        if (N = z || F ? {} : g(e), !k) return z ? h(e, s(N, e)) : l(e, o(N, e))
                    } else {
                        if (!C[G]) return D ? e : {};
                        N = v(e, G, k)
                    }
                }
                j || (j = new i);
                var H = j.get(e);
                if (H) return H;
                if (j.set(e, N), w(e)) return e.forEach(function(i) {
                    N.add(t(i, n, R, i, e, j))
                }), N;
                if (b(e)) return e.forEach(function(i, r) {
                    N.set(r, t(i, n, R, r, e, j))
                }), N;
                var V = B ? z ? p : d : z ? keysIn : M,
                    W = U ? void 0 : V(e);
                return r(W || e, function(i, r) {
                    W && (i = e[r = i]), a(N, r, t(i, n, R, r, e, j))
                }), N
            }
        },
        "Of+w": function(t, e, n) {
            var i = n("Cwc5")(n("Kz5y"), "WeakMap");
            t.exports = i
        },
        OzVs: function(t, e, n) {
            "use strict";
            n.r(e),
                function(t) {
                    n.d(e, "default", function() {
                        return E
                    });
                    var i = n("Cg2A"),
                        r = n.n(i),
                        a = n("ln6h"),
                        o = n.n(a),
                        s = n("9Jkg"),
                        c = n.n(s),
                        u = n("O40h"),
                        l = n("0iUn"),
                        h = n("MI3g"),
                        d = n("a7VT"),
                        p = n("AT/M"),
                        f = n("sLSF"),
                        m = n("Tit0"),
                        v = n("MX0m"),
                        g = n.n(v),
                        y = n("q1tI"),
                        x = n.n(y),
                        b = n("zgjP"),
                        _ = n.n(b),
                        w = n("MyG3"),
                        M = n("xmKf"),
                        T = n("3M1/"),
                        S = (n("BkRI"), n("oyjb"), n("KsUC")),
                        E = function(e) {
                            function n(t) {
                                var e;
                                Object(l.default)(this, n), (e = Object(h.default)(this, Object(d.default)(n).call(this, t))).state = {
                                    isConnected: !0,
                                    abilityTypes: null,
                                    cooldowns: [],
                                    cooldownWidths: ["100%", "100%", "100%", "100%"],
                                    clientTickTime: null,
                                    winner: null
                                }, e.cooldownData = [];
                                for (var i = 0; i < S.numAbilities; i++) e.cooldownData[i] = {
                                    lastFired: 0,
                                    cooldown: 0
                                };
                                return e.playButton = e.playButton.bind(Object(p.default)(e)), e
                            }
                            return Object(m.default)(n, e), Object(f.default)(n, null, [{
                                key: "getInitialProps",
                                value: function() {
                                    var e = Object(u.default)(o.a.mark(function e(n) {
                                        var i, r, a, s, u, l, h;
                                        return o.a.wrap(function(e) {
                                            for (;;) switch (e.prev = e.next) {
                                                case 0:
                                                    return i = n.req, r = n.query, a = i && i.session ? i.session.userId : null, e.next = 4, _()(t.env.API_URL + "/api/server", {
                                                        method: "post",
                                                        headers: {
                                                            Accept: "application/json, text/plain, */*",
                                                            "Content-Type": "application/json"
                                                        },
                                                        body: c()({
                                                            serverId: r.serverId
                                                        })
                                                    });
                                                case 4:
                                                    if (s = e.sent, u = null, 200 != s.status) {
                                                        e.next = 10;
                                                        break
                                                    }
                                                    return e.next = 9, s.json();
                                                case 9:
                                                    u = e.sent;
                                                case 10:
                                                    if (l = null, !a) {
                                                        e.next = 19;
                                                        break
                                                    }
                                                    return e.next = 14, _()(t.env.API_URL + "/api/user", {
                                                        method: "post",
                                                        headers: {
                                                            Accept: "application/json, text/plain, */*",
                                                            "Content-Type": "application/json"
                                                        },
                                                        body: c()({
                                                            userId: a
                                                        })
                                                    });
                                                case 14:
                                                    if (200 != (h = e.sent).status) {
                                                        e.next = 19;
                                                        break
                                                    }
                                                    return e.next = 18, h.json();
                                                case 18:
                                                    l = e.sent;
                                                case 19:
                                                    return e.abrupt("return", {
                                                        userId: a,
                                                        gameId: r.gameId,
                                                        server: u,
                                                        user: l,
                                                        partyId: r.partyId
                                                    });
                                                case 20:
                                                case "end":
                                                    return e.stop()
                                            }
                                        }, e)
                                    }));
                                    return function(t) {
                                        return e.apply(this, arguments)
                                    }
                                }()
                            }]), Object(f.default)(n, [{
                                key: "componentDidMount",
                                value: function() {
                                    var t = this;
                                    this.props.server && this.props.gameId && (this.ws = new WebSocket(this.props.server.address), this.ws.onopen = function(e) {
                                        Object(w.d)(e, t.manager, t.ws, t), t.manager = new M.a(t.props.gameId, t, null, t.props.userId, t.props.user)
                                    }, this.ws.onmessage = function(e) {
                                        Object(w.c)(e, t.manager, t.ws, t)
                                    }, this.ws.onclose = function(e) {
                                        Object(w.a)(e, t.manager, t.ws, t)
                                    }, this.ws.onerror = function(t) {
                                        Object(w.b)(t)
                                    }, this.updateCooldownsTimerHandle = setInterval(function() {
                                        t.updateCooldowns()
                                    }, 90))
                                }
                            }, {
                                key: "addToLog",
                                value: function(t) {
                                    var e = document.getElementById("log");
                                    if (e) {
                                        var n = document.createElement("div");
                                        n.innerHTML = t, e.appendChild(n)
                                    }
                                }
                            }, {
                                key: "componentWillUnmount",
                                value: function() {
                                    this.ws.close()
                                }
                            }, {
                                key: "renderLostConnection",
                                value: function() {
                                    if (!this.state.isConnected) return x.a.createElement("div", {
                                        className: "jsx-1043258230"
                                    }, x.a.createElement("div", {
                                        id: "lostConnectionModal",
                                        className: "jsx-1043258230"
                                    }, "Lost connection to server."), x.a.createElement(g.a, {
                                        id: "1043258230"
                                    }, ["#lostConnectionModal.jsx-1043258230{position:fixed;left:20px;top:50px;color:#fff;}"]))
                                }
                            }, {
                                key: "renderStats",
                                value: function() {
                                    return x.a.createElement("div", {
                                        className: "jsx-2220120901"
                                    }, "Ping: ", x.a.createElement("span", {
                                        id: "ping",
                                        className: "jsx-2220120901"
                                    }, "-"), "    Server: ", x.a.createElement("span", {
                                        id: "serverTickTime",
                                        className: "jsx-2220120901"
                                    }, "-"), "    Client: ", x.a.createElement("span", {
                                        id: "clientTickTime",
                                        className: "jsx-2220120901"
                                    }, "-"), "    Render: ", x.a.createElement("span", {
                                        id: "renderTickTime",
                                        className: "jsx-2220120901"
                                    }, "-"), x.a.createElement(g.a, {
                                        id: "2220120901"
                                    }, ["div.jsx-2220120901{position:fixed;left:10px;bottom:10px;color:#999;font-size:50%;}"]))
                                }
                            }, {
                                key: "renderLoading",
                                value: function() {
                                    return x.a.createElement("div", {
                                        id: "loading",
                                        className: "jsx-1153364257"
                                    }, "Loading...", x.a.createElement(g.a, {
                                        id: "1153364257"
                                    }, ["div.jsx-1153364257{position:fixed;width:300px;height:60px;top:50%;left:50%;margin-top:-30px;margin-left:-150px;color:#fff;display:true;text-align:center;padding:20px;background-color:hsl(203,30%,10%);border-radius:3px;}"]))
                                }
                            }, {
                                key: "renderLog",
                                value: function() {
                                    return x.a.createElement("div", {
                                        className: "jsx-952872202"
                                    }, x.a.createElement("div", {
                                        id: "log",
                                        className: "jsx-952872202"
                                    }), x.a.createElement(g.a, {
                                        id: "952872202"
                                    }, ["#log.jsx-952872202{line-height:150%;border-radius:3px;background-color:hsl(203,30%,10%);padding:10px;font-family:'Roboto',sans-serif;font-size:90%;}"]))
                                }
                            }, {
                                key: "updateCooldowns",
                                value: function() {
                                    for (var t = 0; t < S.numAbilities; t++) {
                                        var e = document.getElementById("cooldownBar" + t);
                                        e && (e.style.width = 100 * Math.min(1, (r()() - this.cooldownData[t].lastFired) / this.cooldownData[t].cooldown) + "%")
                                    }
                                }
                            }, {
                                key: "renderCooldowns",
                                value: function() {
                                    var t = this;
                                    if (!this.state.abilityTypes) return null;
                                    for (var e = [], n = function(n) {
                                            e[n] = S.abilityTypes.find(function(e) {
                                                return e.id == t.state.abilityTypes[n]
                                            })
                                        }, i = 0; i < S.numAbilities; i++) n(i);
                                    var r = -1;
                                    return x.a.createElement("div", {
                                        id: "cooldownContainer",
                                        className: "jsx-1869683811"
                                    }, e.map(function(t) {
                                        var e = "cooldownBar" + ++r;
                                        return x.a.createElement("div", {
                                            key: r,
                                            className: "jsx-1869683811"
                                        }, x.a.createElement("label", {
                                            className: "jsx-1869683811"
                                        }, t.name), x.a.createElement("div", {
                                            className: "jsx-1869683811 bg"
                                        }, x.a.createElement("div", {
                                            id: e,
                                            style: {
                                                width: "100%"
                                            },
                                            className: "jsx-1869683811 bar"
                                        })))
                                    }), x.a.createElement(g.a, {
                                        id: "1869683811"
                                    }, ["#cooldownContainer.jsx-1869683811{position:relative;left:0px;top:0px;background-color:hsl(203,30%,10%);padding:10px;border-radius:3px;margin-bottom:5px;}", ".bg.jsx-1869683811{background-color:hsl(0,0%,40%);height:30px;margin-bottom:10px;border-radius:3px;}", ".bar.jsx-1869683811{height:30px;background-color:hsl(0,0%,70%);border-radius:3px;}", "label.jsx-1869683811{margin-bottom:8px;font-size:80%;}"]))
                                }
                            }, {
                                key: "renderHealthBars",
                                value: function() {
                                    return x.a.createElement("div", {
                                        id: "statsContainer",
                                        className: "jsx-303145664"
                                    }, x.a.createElement("label", {
                                        className: "jsx-303145664"
                                    }, "Shield"), x.a.createElement("div", {
                                        id: "shieldContainer",
                                        className: "jsx-303145664 barContainer"
                                    }, x.a.createElement("div", {
                                        id: "shield",
                                        style: {
                                            width: "100%"
                                        },
                                        className: "jsx-303145664 bar"
                                    }), x.a.createElement("div", {
                                        id: "shieldText",
                                        className: "jsx-303145664 text"
                                    })), x.a.createElement("label", {
                                        className: "jsx-303145664"
                                    }, "Health"), x.a.createElement("div", {
                                        id: "healthContainer",
                                        className: "jsx-303145664 barContainer"
                                    }, x.a.createElement("div", {
                                        id: "health",
                                        style: {
                                            width: "100%"
                                        },
                                        className: "jsx-303145664 bar"
                                    }), x.a.createElement("div", {
                                        id: "healthText",
                                        className: "jsx-303145664 text"
                                    })), x.a.createElement(g.a, {
                                        id: "303145664"
                                    }, [".jsx-303145664{label margin-bottom:8px;font-size:80%;}", "#statsContainer.jsx-303145664{background-color:hsl(203,30%,10%);padding:10px;border-radius:3px;}", ".barContainer.jsx-303145664{background-color:hsl(0,0%,40%);width:200px;height:30px;position:relative;border-radius:3px;margin-bottom:10px;}", "#healthContainer.jsx-303145664{left:0px;top:0px;}", "#shieldContainer.jsx-303145664{left:0px;top:0px;}", ".bar.jsx-303145664{height:100%;border-radius:3px;}", ".text.jsx-303145664{width:200px;position:relative;top:-23px;text-align:center;vertical-align:middle;font-size:150%;color:#fff;}", "#health.jsx-303145664{background-color:hsl(90,60%,60%);}", "#shield.jsx-303145664{background-color:hsl(215,60%,60%);}"]))
                                }
                            }, {
                                key: "playButton",
                                value: function(t) {
                                    this.ws && this.ws.readyState === this.ws.OPEN && this.ws.send(c()({
                                        t: "requestGame"
                                    }))
                                }
                            }, {
                                key: "renderWinner",
                                value: function() {
                                    if (this.state.winner) {
                                        var t = "/party/" + this.props.server._id + "/" + this.props.partyId;
                                        return x.a.createElement("div", {
                                            id: "container",
                                            className: "jsx-2544686383"
                                        }, x.a.createElement("div", {
                                            id: "winner",
                                            className: "jsx-2544686383"
                                        }, this.state.winner, " Wins!"), x.a.createElement("div", {
                                            className: "jsx-2544686383"
                                        }, x.a.createElement("button", {
                                            onClick: this.playButton,
                                            className: "jsx-2544686383"
                                        }, "Play Again"), this.props.partyId ? x.a.createElement("a", {
                                            href: t,
                                            className: "jsx-2544686383"
                                        }, x.a.createElement("button", {
                                            className: "jsx-2544686383"
                                        }, "Back to Party")) : null), x.a.createElement("div", {
                                            id: "discord",
                                            className: "jsx-2544686383"
                                        }, x.a.createElement("a", {
                                            href: "https://discord.gg/6R3jYyH",
                                            className: "jsx-2544686383"
                                        }, "Chat about this game on ", x.a.createElement("img", {
                                            src: "/static/Discord-Logo+Wordmark-White.png",
                                            className: "jsx-2544686383"
                                        }))), x.a.createElement(g.a, {
                                            id: "2544686383"
                                        }, ["#container.jsx-2544686383{margin-top:5px;background-color:hsl(203,30%,10%);border-radius:3px;padding:10px 20px;font-family:'Roboto',sans-serif;}", "#winner.jsx-2544686383{font-size:150%;margin-bottom:20px;}", "img.jsx-2544686383{width:100px;vertical-align:middle;}", "#discord.jsx-2544686383{margin-top:10px;font-size:85%;}"]))
                                    }
                                }
                            }, {
                                key: "renderBackButton",
                                value: function() {
                                    if (this.props.partyId) {
                                        var t = "/party/" + this.props.server._id + "/" + this.props.partyId;
                                        return x.a.createElement("div", {
                                            className: "jsx-3084849309"
                                        }, x.a.createElement("a", {
                                            href: t,
                                            className: "jsx-3084849309"
                                        }, "< Back to Party"), x.a.createElement("br", {
                                            className: "jsx-3084849309"
                                        }), x.a.createElement("br", {
                                            className: "jsx-3084849309"
                                        }), x.a.createElement("a", {
                                            href: "/",
                                            className: "jsx-3084849309"
                                        }, "< Back Home"), x.a.createElement(g.a, {
                                            id: "3084849309"
                                        }, ["a.jsx-3084849309{margin-bottom:10px;}"]))
                                    }
                                    return x.a.createElement("a", {
                                        href: "/"
                                    }, "< Back Home")
                                }
                            }, {
                                key: "render",
                                value: function() {
                                    return x.a.createElement("div", {
                                        className: "jsx-3447413811"
                                    }, x.a.createElement(T.a, null, x.a.createElement("div", {
                                        id: "game",
                                        className: "jsx-3447413811"
                                    }), this.renderLostConnection(), this.renderStats(), this.renderLoading(), x.a.createElement("div", {
                                        id: "logContainer",
                                        className: "jsx-3447413811"
                                    }, this.renderLog(), this.renderWinner()), x.a.createElement("div", {
                                        id: "rightUI",
                                        className: "jsx-3447413811"
                                    }, this.renderCooldowns(), this.renderHealthBars()), x.a.createElement("div", {
                                        id: "backButton",
                                        className: "jsx-3447413811"
                                    }, this.renderBackButton())), x.a.createElement(g.a, {
                                        id: "3447413811"
                                    }, ["#rightUI{position:absolute;right:0px;bottom:100px;}", "#game canvas{position:fixed;}", "#backButton{position:fixed;top:20px;left:10px;}", "#logContainer{position:absolute;left:10px;bottom:100px;width:300px;}"]))
                                }
                            }]), n
                        }(x.a.Component)
                }.call(this, n("8oxB"))
        },
        Q1l4: function(t, e) {
            t.exports = function(t, e) {
                var n = -1,
                    i = t.length;
                for (e || (e = Array(i)); ++n < i;) e[n] = t[n];
                return e
            }
        },
        QIyF: function(t, e, n) {
            var i = n("Kz5y");
            t.exports = function() {
                return i.Date.now()
            }
        },
        QcOe: function(t, e, n) {
            var i = n("GoyQ"),
                r = n("6sVZ"),
                a = n("7Ix3"),
                o = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                if (!i(t)) return a(t);
                var e = r(t),
                    n = [];
                for (var s in t)("constructor" != s || !e && o.call(t, s)) && n.push(s);
                return n
            }
        },
        QkVE: function(t, e, n) {
            var i = n("EpBk");
            t.exports = function(t, e) {
                var n = t.__data__;
                return i(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
            }
        },
        QqLw: function(t, e, n) {
            var i = n("tadb"),
                r = n("ebwN"),
                a = n("HOxn"),
                o = n("yGk4"),
                s = n("Of+w"),
                c = n("NykK"),
                u = n("3Fdi"),
                l = u(i),
                h = u(r),
                d = u(a),
                p = u(o),
                f = u(s),
                m = c;
            (i && "[object DataView]" != m(new i(new ArrayBuffer(1))) || r && "[object Map]" != m(new r) || a && "[object Promise]" != m(a.resolve()) || o && "[object Set]" != m(new o) || s && "[object WeakMap]" != m(new s)) && (m = function(t) {
                var e = c(t),
                    n = "[object Object]" == e ? t.constructor : void 0,
                    i = n ? u(n) : "";
                if (i) switch (i) {
                    case l:
                        return "[object DataView]";
                    case h:
                        return "[object Map]";
                    case d:
                        return "[object Promise]";
                    case p:
                        return "[object Set]";
                    case f:
                        return "[object WeakMap]"
                }
                return e
            }), t.exports = m
        },
        SRBb: function(t, e, n) {
            n("HLdI"), t.exports = n("WEpk").Reflect.get
        },
        SfRM: function(t, e, n) {
            var i = n("YESw");
            t.exports = function() {
                this.__data__ = i ? i(null) : {}, this.size = 0
            }
        },
        "UNi/": function(t, e) {
            t.exports = function(t, e) {
                for (var n = -1, i = Array(t); ++n < t;) i[n] = e(n);
                return i
            }
        },
        V6Ve: function(t, e, n) {
            var i = n("kekF")(Object.keys, Object);
            t.exports = i
        },
        VOtZ: function(t, e, n) {
            var i = n("juv8"),
                r = n("MvSz");
            t.exports = function(t, e) {
                return i(t, r(t), e)
            }
        },
        VaNO: function(t, e) {
            t.exports = function(t) {
                return this.__data__.has(t)
            }
        },
        WFqU: function(t, e, n) {
            (function(e) {
                var n = "object" == typeof e && e && e.Object === Object && e;
                t.exports = n
            }).call(this, n("yLpj"))
        },
        Womt: function(t, e, n) {
            "use strict";

            function i() {}
            n.d(e, "p", function() {
                return aa
            }), n.d(e, "k", function() {
                return ca
            }), n.d(e, "m", function() {
                return da
            }), n.d(e, "g", function() {
                return di
            }), n.d(e, "n", function() {
                return _s
            }), n.d(e, "i", function() {
                return Ks
            }), n.d(e, "e", function() {
                return De
            }), n.d(e, "f", function() {
                return Ne
            }), n.d(e, "o", function() {
                return ze
            }), n.d(e, "b", function() {
                return hn
            }), n.d(e, "l", function() {
                return Vs
            }), n.d(e, "j", function() {
                return Xn
            }), n.d(e, "d", function() {
                return xo
            }), n.d(e, "c", function() {
                return jo
            }), n.d(e, "a", function() {
                return Wn
            }), n.d(e, "h", function() {
                return hi
            }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), n = 1; n < arguments.length; n++) {
                    var i = arguments[n];
                    if (null != i)
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
                }
                return e
            }), Object.assign(i.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners[t];
                        if (void 0 !== n) {
                            var i = n.indexOf(e); - 1 !== i && n.splice(i, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var n = e.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, t)
                        }
                    }
                }
            });
            var r, a, o, s, c, u, l, h, d, p, f, m, v = "101",
                g = 0,
                y = 1,
                x = 2,
                b = 1,
                _ = 2,
                w = 0,
                M = 1,
                T = 2,
                S = 0,
                E = 1,
                A = 2,
                L = 0,
                P = 1,
                O = 2,
                C = 3,
                R = 4,
                I = 5,
                D = 100,
                j = 101,
                N = 102,
                k = 103,
                z = 104,
                B = 200,
                U = 201,
                G = 202,
                F = 203,
                H = 204,
                V = 205,
                W = 206,
                q = 207,
                X = 208,
                Y = 209,
                Z = 210,
                J = 0,
                K = 1,
                Q = 2,
                $ = 3,
                tt = 4,
                et = 5,
                nt = 6,
                it = 7,
                rt = 0,
                at = 1,
                ot = 2,
                st = 0,
                ct = 1,
                ut = 2,
                lt = 3,
                ht = 4,
                dt = 5,
                pt = 301,
                ft = 302,
                mt = 303,
                vt = 304,
                gt = 305,
                yt = 306,
                xt = 307,
                bt = 1e3,
                _t = 1001,
                wt = 1002,
                Mt = 1003,
                Tt = 1004,
                St = 1005,
                Et = 1006,
                At = 1007,
                Lt = 1008,
                Pt = 1009,
                Ot = 1010,
                Ct = 1011,
                Rt = 1012,
                It = 1013,
                Dt = 1014,
                jt = 1015,
                Nt = 1016,
                kt = 1017,
                zt = 1018,
                Bt = 1019,
                Ut = 1020,
                Gt = 1021,
                Ft = 1022,
                Ht = 1023,
                Vt = 1024,
                Wt = 1025,
                qt = 1026,
                Xt = 1027,
                Yt = 1028,
                Zt = 33776,
                Jt = 33777,
                Kt = 33778,
                Qt = 33779,
                $t = 35840,
                te = 35841,
                ee = 35842,
                ne = 35843,
                ie = 36196,
                re = 37808,
                ae = 37809,
                oe = 37810,
                se = 37811,
                ce = 37812,
                ue = 37813,
                le = 37814,
                he = 37815,
                de = 37816,
                pe = 37817,
                fe = 37818,
                me = 37819,
                ve = 37820,
                ge = 37821,
                ye = 2201,
                xe = 2400,
                be = 0,
                _e = 1,
                we = 2,
                Me = 3e3,
                Te = 3001,
                Se = 3007,
                Ee = 3002,
                Ae = 3004,
                Le = 3005,
                Pe = 3006,
                Oe = 3200,
                Ce = 3201,
                Re = 0,
                Ie = 1,
                De = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                        return function() {
                            var e = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0;
                            return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & n] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[63 & i | 128] + t[i >> 8 & 255] + "-" + t[i >> 16 & 255] + t[i >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase()
                        }
                    }(),
                    clamp: function(t, e, n) {
                        return Math.max(e, Math.min(n, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, n, i, r) {
                        return i + (t - e) * (r - i) / (n - e)
                    },
                    lerp: function(t, e, n) {
                        return (1 - n) * t + n * e
                    },
                    smoothstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    degToRad: function(t) {
                        return t * De.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * De.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 == (t & t - 1) && 0 !== t
                    },
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: function(t) {
                        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                    }
                };

            function je(t, e) {
                this.x = t || 0, this.y = e || 0
            }

            function Ne() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function ke(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
            }

            function ze(t, e, n) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0
            }

            function Be() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.defineProperties(je.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }
            }), Object.assign(je.prototype, {
                isVector2: !0,
                set: function(t, e) {
                    return this.x = t, this.y = e, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                },
                multiply: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                },
                clampScalar: (r = new je, a = new je, function(t, e) {
                    return r.set(t, t), a.set(e, e), this.clamp(r, a)
                }),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI), t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                },
                rotateAround: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = this.x - t.x,
                        a = this.y - t.y;
                    return this.x = r * n - a * i + t.x, this.y = r * i + a * n + t.y, this
                }
            }), Object.assign(Ne.prototype, {
                isMatrix4: !0,
                set: function(t, e, n, i, r, a, o, s, c, u, l, h, d, p, f, m) {
                    var v = this.elements;
                    return v[0] = t, v[4] = e, v[8] = n, v[12] = i, v[1] = r, v[5] = a, v[9] = o, v[13] = s, v[2] = c, v[6] = u, v[10] = l, v[14] = h, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new Ne).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                },
                copyPosition: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                },
                extractBasis: function(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: (p = new ze, function(t) {
                    var e = this.elements,
                        n = t.elements,
                        i = 1 / p.setFromMatrixColumn(t, 0).length(),
                        r = 1 / p.setFromMatrixColumn(t, 1).length(),
                        a = 1 / p.setFromMatrixColumn(t, 2).length();
                    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }),
                makeRotationFromEuler: function(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z,
                        a = Math.cos(n),
                        o = Math.sin(n),
                        s = Math.cos(i),
                        c = Math.sin(i),
                        u = Math.cos(r),
                        l = Math.sin(r);
                    if ("XYZ" === t.order) {
                        var h = a * u,
                            d = a * l,
                            p = o * u,
                            f = o * l;
                        e[0] = s * u, e[4] = -s * l, e[8] = c, e[1] = d + p * c, e[5] = h - f * c, e[9] = -o * s, e[2] = f - h * c, e[6] = p + d * c, e[10] = a * s
                    } else if ("YXZ" === t.order) {
                        var m = s * u,
                            v = s * l,
                            g = c * u,
                            y = c * l;
                        e[0] = m + y * o, e[4] = g * o - v, e[8] = a * c, e[1] = a * l, e[5] = a * u, e[9] = -o, e[2] = v * o - g, e[6] = y + m * o, e[10] = a * s
                    } else if ("ZXY" === t.order) {
                        m = s * u, v = s * l, g = c * u, y = c * l;
                        e[0] = m - y * o, e[4] = -a * l, e[8] = g + v * o, e[1] = v + g * o, e[5] = a * u, e[9] = y - m * o, e[2] = -a * c, e[6] = o, e[10] = a * s
                    } else if ("ZYX" === t.order) {
                        h = a * u, d = a * l, p = o * u, f = o * l;
                        e[0] = s * u, e[4] = p * c - d, e[8] = h * c + f, e[1] = s * l, e[5] = f * c + h, e[9] = d * c - p, e[2] = -c, e[6] = o * s, e[10] = a * s
                    } else if ("YZX" === t.order) {
                        var x = a * s,
                            b = a * c,
                            _ = o * s,
                            w = o * c;
                        e[0] = s * u, e[4] = w - x * l, e[8] = _ * l + b, e[1] = l, e[5] = a * u, e[9] = -o * u, e[2] = -c * u, e[6] = b * l + _, e[10] = x - w * l
                    } else if ("XZY" === t.order) {
                        x = a * s, b = a * c, _ = o * s, w = o * c;
                        e[0] = s * u, e[4] = -l, e[8] = c * u, e[1] = x * l + w, e[5] = a * u, e[9] = b * l - _, e[2] = _ * l - b, e[6] = o * u, e[10] = w * l + x
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromQuaternion: (h = new ze(0, 0, 0), d = new ze(1, 1, 1), function(t) {
                    return this.compose(h, t, d)
                }),
                lookAt: (c = new ze, u = new ze, l = new ze, function(t, e, n) {
                    var i = this.elements;
                    return l.subVectors(t, e), 0 === l.lengthSq() && (l.z = 1), l.normalize(), c.crossVectors(n, l), 0 === c.lengthSq() && (1 === Math.abs(n.z) ? l.x += 1e-4 : l.z += 1e-4, l.normalize(), c.crossVectors(n, l)), c.normalize(), u.crossVectors(l, c), i[0] = c.x, i[4] = u.x, i[8] = l.x, i[1] = c.y, i[5] = u.y, i[9] = l.y, i[2] = c.z, i[6] = u.z, i[10] = l.z, this
                }),
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[4],
                        s = n[8],
                        c = n[12],
                        u = n[1],
                        l = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        _ = i[0],
                        w = i[4],
                        M = i[8],
                        T = i[12],
                        S = i[1],
                        E = i[5],
                        A = i[9],
                        L = i[13],
                        P = i[2],
                        O = i[6],
                        C = i[10],
                        R = i[14],
                        I = i[3],
                        D = i[7],
                        j = i[11],
                        N = i[15];
                    return r[0] = a * _ + o * S + s * P + c * I, r[4] = a * w + o * E + s * O + c * D, r[8] = a * M + o * A + s * C + c * j, r[12] = a * T + o * L + s * R + c * N, r[1] = u * _ + l * S + h * P + d * I, r[5] = u * w + l * E + h * O + d * D, r[9] = u * M + l * A + h * C + d * j, r[13] = u * T + l * L + h * R + d * N, r[2] = p * _ + f * S + m * P + v * I, r[6] = p * w + f * E + m * O + v * D, r[10] = p * M + f * A + m * C + v * j, r[14] = p * T + f * L + m * R + v * N, r[3] = g * _ + y * S + x * P + b * I, r[7] = g * w + y * E + x * O + b * D, r[11] = g * M + y * A + x * C + b * j, r[15] = g * T + y * L + x * R + b * N, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                },
                applyToBufferAttribute: function() {
                    var t = new ze;
                    return function(e) {
                        for (var n = 0, i = e.count; n < i; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix4(this), e.setXYZ(n, t.x, t.y, t.z);
                        return e
                    }
                }(),
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[4],
                        i = t[8],
                        r = t[12],
                        a = t[1],
                        o = t[5],
                        s = t[9],
                        c = t[13],
                        u = t[2],
                        l = t[6],
                        h = t[10],
                        d = t[14];
                    return t[3] * (+r * s * l - i * c * l - r * o * h + n * c * h + i * o * d - n * s * d) + t[7] * (+e * s * d - e * c * h + r * a * h - i * a * d + i * c * u - r * s * u) + t[11] * (+e * c * l - e * o * d - r * a * l + n * a * d + r * o * u - n * c * u) + t[15] * (-i * o * u - e * s * l + e * o * h + i * a * l - n * a * h + n * s * u)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                },
                setPosition: function(t) {
                    var e = this.elements;
                    return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
                },
                getInverse: function(t, e) {
                    var n = this.elements,
                        i = t.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = i[3],
                        c = i[4],
                        u = i[5],
                        l = i[6],
                        h = i[7],
                        d = i[8],
                        p = i[9],
                        f = i[10],
                        m = i[11],
                        v = i[12],
                        g = i[13],
                        y = i[14],
                        x = i[15],
                        b = p * y * h - g * f * h + g * l * m - u * y * m - p * l * x + u * f * x,
                        _ = v * f * h - d * y * h - v * l * m + c * y * m + d * l * x - c * f * x,
                        w = d * g * h - v * p * h + v * u * m - c * g * m - d * u * x + c * p * x,
                        M = v * p * l - d * g * l - v * u * f + c * g * f + d * u * y - c * p * y,
                        T = r * b + a * _ + o * w + s * M;
                    if (0 === T) {
                        var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(S);
                        return console.warn(S), this.identity()
                    }
                    var E = 1 / T;
                    return n[0] = b * E, n[1] = (g * f * s - p * y * s - g * o * m + a * y * m + p * o * x - a * f * x) * E, n[2] = (u * y * s - g * l * s + g * o * h - a * y * h - u * o * x + a * l * x) * E, n[3] = (p * l * s - u * f * s - p * o * h + a * f * h + u * o * m - a * l * m) * E, n[4] = _ * E, n[5] = (d * y * s - v * f * s + v * o * m - r * y * m - d * o * x + r * f * x) * E, n[6] = (v * l * s - c * y * s - v * o * h + r * y * h + c * o * x - r * l * x) * E, n[7] = (c * f * s - d * l * s + d * o * h - r * f * h - c * o * m + r * l * m) * E, n[8] = w * E, n[9] = (v * p * s - d * g * s - v * a * m + r * g * m + d * a * x - r * p * x) * E, n[10] = (c * g * s - v * u * s + v * a * h - r * g * h - c * a * x + r * u * x) * E, n[11] = (d * u * s - c * p * s - d * a * h + r * p * h + c * a * m - r * u * m) * E, n[12] = M * E, n[13] = (d * g * o - v * p * o + v * a * f - r * g * f - d * a * y + r * p * y) * E, n[14] = (v * u * o - c * g * o - v * a * l + r * g * l + c * a * y - r * u * y) * E, n[15] = (c * p * o - d * u * o + d * a * l - r * p * l - c * a * f + r * u * f) * E, this
                },
                scale: function(t) {
                    var e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z;
                    return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, i))
                },
                makeTranslation: function(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(t, e) {
                    var n = Math.cos(e),
                        i = Math.sin(e),
                        r = 1 - n,
                        a = t.x,
                        o = t.y,
                        s = t.z,
                        c = r * a,
                        u = r * o;
                    return this.set(c * a + n, c * o - i * s, c * s + i * o, 0, c * o + i * s, u * o + n, u * s - i * a, 0, c * s - i * o, u * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(t, e, n) {
                    var i = this.elements,
                        r = e._x,
                        a = e._y,
                        o = e._z,
                        s = e._w,
                        c = r + r,
                        u = a + a,
                        l = o + o,
                        h = r * c,
                        d = r * u,
                        p = r * l,
                        f = a * u,
                        m = a * l,
                        v = o * l,
                        g = s * c,
                        y = s * u,
                        x = s * l,
                        b = n.x,
                        _ = n.y,
                        w = n.z;
                    return i[0] = (1 - (f + v)) * b, i[1] = (d + x) * b, i[2] = (p - y) * b, i[3] = 0, i[4] = (d - x) * _, i[5] = (1 - (h + v)) * _, i[6] = (m + g) * _, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - g) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                },
                decompose: (o = new ze, s = new Ne, function(t, e, n) {
                    var i = this.elements,
                        r = o.set(i[0], i[1], i[2]).length(),
                        a = o.set(i[4], i[5], i[6]).length(),
                        c = o.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], s.copy(this);
                    var u = 1 / r,
                        l = 1 / a,
                        h = 1 / c;
                    return s.elements[0] *= u, s.elements[1] *= u, s.elements[2] *= u, s.elements[4] *= l, s.elements[5] *= l, s.elements[6] *= l, s.elements[8] *= h, s.elements[9] *= h, s.elements[10] *= h, e.setFromRotationMatrix(s), n.x = r, n.y = a, n.z = c, this
                }),
                makePerspective: function(t, e, n, i, r, a) {
                    void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var o = this.elements,
                        s = 2 * r / (e - t),
                        c = 2 * r / (n - i),
                        u = (e + t) / (e - t),
                        l = (n + i) / (n - i),
                        h = -(a + r) / (a - r),
                        d = -2 * a * r / (a - r);
                    return o[0] = s, o[4] = 0, o[8] = u, o[12] = 0, o[1] = 0, o[5] = c, o[9] = l, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                },
                makeOrthographic: function(t, e, n, i, r, a) {
                    var o = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (n - i),
                        u = 1 / (a - r),
                        l = (e + t) * s,
                        h = (n + i) * c,
                        d = (a + r) * u;
                    return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -l, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * u, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            }), Object.assign(ke, {
                slerp: function(t, e, n, i) {
                    return n.copy(t).slerp(e, i)
                },
                slerpFlat: function(t, e, n, i, r, a, o) {
                    var s = n[i + 0],
                        c = n[i + 1],
                        u = n[i + 2],
                        l = n[i + 3],
                        h = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3];
                    if (l !== f || s !== h || c !== d || u !== p) {
                        var m = 1 - o,
                            v = s * h + c * d + u * p + l * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y),
                                b = Math.atan2(x, v * g);
                            m = Math.sin(m * b) / x, o = Math.sin(o * b) / x
                        }
                        var _ = o * g;
                        if (s = s * m + h * _, c = c * m + d * _, u = u * m + p * _, l = l * m + f * _, m === 1 - o) {
                            var w = 1 / Math.sqrt(s * s + c * c + u * u + l * l);
                            s *= w, c *= w, u *= w, l *= w
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = u, t[e + 3] = l
                }
            }), Object.defineProperties(ke.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(t) {
                        this._w = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(ke.prototype, {
                isQuaternion: !0,
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._w = i, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
                },
                setFromEuler: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        a = t.order,
                        o = Math.cos,
                        s = Math.sin,
                        c = o(n / 2),
                        u = o(i / 2),
                        l = o(r / 2),
                        h = s(n / 2),
                        d = s(i / 2),
                        p = s(r / 2);
                    return "XYZ" === a ? (this._x = h * u * l + c * d * p, this._y = c * d * l - h * u * p, this._z = c * u * p + h * d * l, this._w = c * u * l - h * d * p) : "YXZ" === a ? (this._x = h * u * l + c * d * p, this._y = c * d * l - h * u * p, this._z = c * u * p - h * d * l, this._w = c * u * l + h * d * p) : "ZXY" === a ? (this._x = h * u * l - c * d * p, this._y = c * d * l + h * u * p, this._z = c * u * p + h * d * l, this._w = c * u * l - h * d * p) : "ZYX" === a ? (this._x = h * u * l - c * d * p, this._y = c * d * l + h * u * p, this._z = c * u * p - h * d * l, this._w = c * u * l + h * d * p) : "YZX" === a ? (this._x = h * u * l + c * d * p, this._y = c * d * l + h * u * p, this._z = c * u * p - h * d * l, this._w = c * u * l - h * d * p) : "XZY" === a && (this._x = h * u * l - c * d * p, this._y = c * d * l - h * u * p, this._z = c * u * p + h * d * l, this._w = c * u * l + h * d * p), !1 !== e && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(t, e) {
                    var n = e / 2,
                        i = Math.sin(n);
                    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t) {
                    var e, n = t.elements,
                        i = n[0],
                        r = n[4],
                        a = n[8],
                        o = n[1],
                        s = n[5],
                        c = n[9],
                        u = n[2],
                        l = n[6],
                        h = n[10],
                        d = i + s + h;
                    return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (l - c) * e, this._y = (a - u) * e, this._z = (o - r) * e) : i > s && i > h ? (e = 2 * Math.sqrt(1 + i - s - h), this._w = (l - c) / e, this._x = .25 * e, this._y = (r + o) / e, this._z = (a + u) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - i - h), this._w = (a - u) / e, this._x = (r + o) / e, this._y = .25 * e, this._z = (c + l) / e) : (e = 2 * Math.sqrt(1 + h - i - s), this._w = (o - r) / e, this._x = (a + u) / e, this._y = (c + l) / e, this._z = .25 * e), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() {
                    var t, e = new ze;
                    return function(n, i) {
                        return void 0 === e && (e = new ze), (t = n.dot(i) + 1) < 1e-6 ? (t = 0, Math.abs(n.x) > Math.abs(n.z) ? e.set(-n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, i), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
                    }
                }(),
                angleTo: function(t) {
                    return 2 * Math.acos(Math.abs(De.clamp(this.dot(t), -1, 1)))
                },
                rotateTowards: function(t, e) {
                    var n = this.angleTo(t);
                    if (0 === n) return this;
                    var i = Math.min(1, e / n);
                    return this.slerp(t, i), this
                },
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var n = t._x,
                        i = t._y,
                        r = t._z,
                        a = t._w,
                        o = e._x,
                        s = e._y,
                        c = e._z,
                        u = e._w;
                    return this._x = n * u + a * o + i * c - r * s, this._y = i * u + a * s + r * o - n * c, this._z = r * u + a * c + n * s - i * o, this._w = a * u - n * o - i * s - r * c, this.onChangeCallback(), this
                },
                slerp: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        a = this._w,
                        o = a * t._w + n * t._x + i * t._y + r * t._z;
                    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                    var s = 1 - o * o;
                    if (s <= Number.EPSILON) {
                        var c = 1 - e;
                        return this._w = c * a + e * this._w, this._x = c * n + e * this._x, this._y = c * i + e * this._y, this._z = c * r + e * this._z, this.normalize()
                    }
                    var u = Math.sqrt(s),
                        l = Math.atan2(u, o),
                        h = Math.sin((1 - e) * l) / u,
                        d = Math.sin(e * l) / u;
                    return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = i * h + this._y * d, this._z = r * h + this._z * d, this.onChangeCallback(), this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(ze.prototype, {
                isVector3: !0,
                set: function(t, e, n) {
                    return this.x = t, this.y = e, this.z = n, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                },
                applyEuler: (f = new ke, function(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(f.setFromEuler(t))
                }),
                applyAxisAngle: function() {
                    var t = new ke;
                    return function(e, n) {
                        return this.applyQuaternion(t.setFromAxisAngle(e, n))
                    }
                }(),
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements,
                        a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a, this
                },
                applyQuaternion: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.x,
                        a = t.y,
                        o = t.z,
                        s = t.w,
                        c = s * e + a * i - o * n,
                        u = s * n + o * e - r * i,
                        l = s * i + r * n - a * e,
                        h = -r * e - a * n - o * i;
                    return this.x = c * s + h * -r + u * -o - l * -a, this.y = u * s + h * -a + l * -r - c * -o, this.z = l * s + h * -o + c * -a - u * -r, this
                },
                project: function(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                },
                unproject: function() {
                    var t = new Ne;
                    return function(e) {
                        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
                    }
                }(),
                transformDirection: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                },
                clampScalar: function() {
                    var t = new ze,
                        e = new ze;
                    return function(n, i) {
                        return t.set(n, n, n), e.set(i, i, i), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                cross: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                },
                crossVectors: function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        a = e.x,
                        o = e.y,
                        s = e.z;
                    return this.x = i * s - r * o, this.y = r * a - n * s, this.z = n * o - i * a, this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: function() {
                    var t = new ze;
                    return function(e) {
                        return t.copy(this).projectOnVector(e), this.sub(t)
                    }
                }(),
                reflect: function() {
                    var t = new ze;
                    return function(e) {
                        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                }(),
                angleTo: function(t) {
                    var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                    return Math.acos(De.clamp(e, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return e * e + n * n + i * i
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                },
                setFromSphericalCoords: function(t, e, n) {
                    var i = Math.sin(e) * t;
                    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
                },
                setFromCylindrical: function(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                },
                setFromCylindricalCoords: function(t, e, n) {
                    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                },
                setFromMatrixPosition: function(t) {
                    var e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        i = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = i, this
                },
                setFromMatrixColumn: function(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
            }), Object.assign(Be.prototype, {
                isMatrix3: !0,
                set: function(t, e, n, i, r, a, o, s, c) {
                    var u = this.elements;
                    return u[0] = t, u[1] = i, u[2] = o, u[3] = e, u[4] = r, u[5] = s, u[6] = n, u[7] = a, u[8] = c, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                },
                applyToBufferAttribute: function() {
                    var t = new ze;
                    return function(e) {
                        for (var n = 0, i = e.count; n < i; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix3(this), e.setXYZ(n, t.x, t.y, t.z);
                        return e
                    }
                }(),
                multiply: function(t) {
                    return this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[3],
                        s = n[6],
                        c = n[1],
                        u = n[4],
                        l = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = i[0],
                        m = i[3],
                        v = i[6],
                        g = i[1],
                        y = i[4],
                        x = i[7],
                        b = i[2],
                        _ = i[5],
                        w = i[8];
                    return r[0] = a * f + o * g + s * b, r[3] = a * m + o * y + s * _, r[6] = a * v + o * x + s * w, r[1] = c * f + u * g + l * b, r[4] = c * m + u * y + l * _, r[7] = c * v + u * x + l * w, r[2] = h * f + d * g + p * b, r[5] = h * m + d * y + p * _, r[8] = h * v + d * x + p * w, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        a = t[4],
                        o = t[5],
                        s = t[6],
                        c = t[7],
                        u = t[8];
                    return e * a * u - e * o * c - n * r * u + n * o * s + i * r * c - i * a * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = t.elements,
                        i = this.elements,
                        r = n[0],
                        a = n[1],
                        o = n[2],
                        s = n[3],
                        c = n[4],
                        u = n[5],
                        l = n[6],
                        h = n[7],
                        d = n[8],
                        p = d * c - u * h,
                        f = u * l - d * s,
                        m = h * s - c * l,
                        v = r * p + a * f + o * m;
                    if (0 === v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return i[0] = p * y, i[1] = (o * h - d * a) * y, i[2] = (u * a - o * c) * y, i[3] = f * y, i[4] = (d * r - o * l) * y, i[5] = (o * s - u * r) * y, i[6] = m * y, i[7] = (a * l - h * r) * y, i[8] = (c * r - a * s) * y, this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                },
                setUvTransform: function(t, e, n, i, r, a, o) {
                    var s = Math.cos(r),
                        c = Math.sin(r);
                    this.set(n * s, n * c, -n * (s * a + c * o) + a + t, -i * c, i * s, -i * (-c * a + s * o) + o + e, 0, 0, 1)
                },
                scale: function(t, e) {
                    var n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t),
                        i = this.elements,
                        r = i[0],
                        a = i[3],
                        o = i[6],
                        s = i[1],
                        c = i[4],
                        u = i[7];
                    return i[0] = e * r + n * s, i[3] = e * a + n * c, i[6] = e * o + n * u, i[1] = -n * r + e * s, i[4] = -n * a + e * c, i[7] = -n * o + e * u, this
                },
                translate: function(t, e) {
                    var n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
            });
            var Ue, Ge, Fe, He, Ve, We = {
                    getDataURL: function(t) {
                        var e;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === m && (m = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), m.width = t.width, m.height = t.height;
                            var n = m.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = m
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }
                },
                qe = 0;

            function Xe(t, e, n, i, r, a, o, s, c, u) {
                Object.defineProperty(this, "id", {
                    value: qe++
                }), this.uuid = De.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Xe.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Xe.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : _t, this.wrapT = void 0 !== i ? i : _t, this.magFilter = void 0 !== r ? r : Et, this.minFilter = void 0 !== a ? a : Lt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== o ? o : Ht, this.type = void 0 !== s ? s : Pt, this.offset = new je(0, 0), this.repeat = new je(1, 1), this.center = new je(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Be, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : Me, this.version = 0, this.onUpdate = null
            }

            function Ye(t, e, n, i) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
            }

            function Ze(t, e, n) {
                this.width = t, this.height = e, this.scissor = new Ye(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ye(0, 0, t, e), n = n || {}, this.texture = new Xe(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Et, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function Je(t, e, n) {
                Ze.call(this, t, e, n), this.samples = 4
            }

            function Ke(t, e, n) {
                Ze.call(this, t, e, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }

            function Qe(t, e, n, i, r, a, o, s, c, u, l, h) {
                Xe.call(this, null, a, o, s, c, u, i, r, l, h), this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.magFilter = void 0 !== c ? c : Mt, this.minFilter = void 0 !== u ? u : Mt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function $e(t, e) {
                this.min = void 0 !== t ? t : new ze(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new ze(-1 / 0, -1 / 0, -1 / 0)
            }

            function tn(t, e) {
                this.center = void 0 !== t ? t : new ze, this.radius = void 0 !== e ? e : 0
            }

            function en(t, e) {
                this.normal = void 0 !== t ? t : new ze(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }

            function nn(t, e, n, i, r, a) {
                this.planes = [void 0 !== t ? t : new en, void 0 !== e ? e : new en, void 0 !== n ? n : new en, void 0 !== i ? i : new en, void 0 !== r ? r : new en, void 0 !== a ? a : new en]
            }
            Xe.DEFAULT_IMAGE = void 0, Xe.DEFAULT_MAPPING = 300, Xe.prototype = Object.assign(Object.create(i.prototype), {
                constructor: Xe,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        var i = this.image;
                        if (void 0 === i.uuid && (i.uuid = De.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                            var r;
                            if (Array.isArray(i)) {
                                r = [];
                                for (var a = 0, o = i.length; a < o; a++) r.push(We.getDataURL(i[a]))
                            } else r = We.getDataURL(i);
                            t.images[i.uuid] = {
                                uuid: i.uuid,
                                url: r
                            }
                        }
                        n.image = i.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case bt:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case _t:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case wt:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case bt:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case _t:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case wt:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(Xe.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Ye.prototype, {
                isVector4: !0,
                set: function(t, e, n, i) {
                    return this.x = t, this.y = e, this.z = n, this.w = i, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setW: function(t) {
                    return this.w = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        a = t.elements;
                    return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, n, i, r, a = t.elements,
                        o = a[0],
                        s = a[4],
                        c = a[8],
                        u = a[1],
                        l = a[5],
                        h = a[9],
                        d = a[2],
                        p = a[6],
                        f = a[10];
                    if (Math.abs(s - u) < .01 && Math.abs(c - d) < .01 && Math.abs(h - p) < .01) {
                        if (Math.abs(s + u) < .1 && Math.abs(c + d) < .1 && Math.abs(h + p) < .1 && Math.abs(o + l + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var m = (o + 1) / 2,
                            v = (l + 1) / 2,
                            g = (f + 1) / 2,
                            y = (s + u) / 4,
                            x = (c + d) / 4,
                            b = (h + p) / 4;
                        return m > v && m > g ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = y / (n = Math.sqrt(m)), r = x / n) : v > g ? v < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = y / (i = Math.sqrt(v)), r = b / i) : g < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = x / (r = Math.sqrt(g)), i = b / r), this.set(n, i, r, e), this
                    }
                    var _ = Math.sqrt((p - h) * (p - h) + (c - d) * (c - d) + (u - s) * (u - s));
                    return Math.abs(_) < .001 && (_ = 1), this.x = (p - h) / _, this.y = (c - d) / _, this.z = (u - s) / _, this.w = Math.acos((o + l + f - 1) / 2), this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                },
                clampScalar: function() {
                    var t, e;
                    return function(n, i) {
                        return void 0 === t && (t = new Ye, e = new Ye), t.set(n, n, n, n), e.set(i, i, i, i), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }), Ze.prototype = Object.assign(Object.create(i.prototype), {
                constructor: Ze,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Je.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: Je,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(t) {
                    return Ze.prototype.copy.call(this, t), this.samples = t.samples, this
                }
            }), Ke.prototype = Object.create(Ze.prototype), Ke.prototype.constructor = Ke, Ke.prototype.isWebGLRenderTargetCube = !0, Qe.prototype = Object.create(Xe.prototype), Qe.prototype.constructor = Qe, Qe.prototype.isDataTexture = !0, Object.assign($e.prototype, {
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                        var u = t[s],
                            l = t[s + 1],
                            h = t[s + 2];
                        u < e && (e = u), l < n && (n = l), h < i && (i = h), u > r && (r = u), l > a && (a = l), h > o && (o = h)
                    }
                    return this.min.set(e, n, i), this.max.set(r, a, o), this
                },
                setFromBufferAttribute: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.count; s < c; s++) {
                        var u = t.getX(s),
                            l = t.getY(s),
                            h = t.getZ(s);
                        u < e && (e = u), l < n && (n = l), h < i && (i = h), u > r && (r = u), l > a && (a = l), h > o && (o = h)
                    }
                    return this.min.set(e, n, i), this.max.set(r, a, o), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new ze;
                    return function(e, n) {
                        var i = t.copy(n).multiplyScalar(.5);
                        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                    }
                }(),
                setFromObject: function(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new ze), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new ze), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function() {
                    var t, e, n, i = new ze;

                    function r(r) {
                        var a = r.geometry;
                        if (void 0 !== a)
                            if (a.isGeometry) {
                                var o = a.vertices;
                                for (e = 0, n = o.length; e < n; e++) i.copy(o[e]), i.applyMatrix4(r.matrixWorld), t.expandByPoint(i)
                            } else if (a.isBufferGeometry) {
                            var s = a.attributes.position;
                            if (void 0 !== s)
                                for (e = 0, n = s.count; e < n; e++) i.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld), t.expandByPoint(i)
                        }
                    }
                    return function(e) {
                        return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
                    }
                }(),
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new ze), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: (Ge = new ze, function(t) {
                    return this.clampPoint(t.center, Ge), Ge.distanceToSquared(t.center) <= t.radius * t.radius
                }),
                intersectsPlane: function(t) {
                    var e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                },
                intersectsTriangle: function() {
                    var t = new ze,
                        e = new ze,
                        n = new ze,
                        i = new ze,
                        r = new ze,
                        a = new ze,
                        o = new ze,
                        s = new ze,
                        c = new ze,
                        u = new ze;

                    function l(i) {
                        var r, a;
                        for (r = 0, a = i.length - 3; r <= a; r += 3) {
                            o.fromArray(i, r);
                            var s = c.x * Math.abs(o.x) + c.y * Math.abs(o.y) + c.z * Math.abs(o.z),
                                u = t.dot(o),
                                l = e.dot(o),
                                h = n.dot(o);
                            if (Math.max(-Math.max(u, l, h), Math.min(u, l, h)) > s) return !1
                        }
                        return !0
                    }
                    return function(o) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(s), c.subVectors(this.max, s), t.subVectors(o.a, s), e.subVectors(o.b, s), n.subVectors(o.c, s), i.subVectors(e, t), r.subVectors(n, e), a.subVectors(t, n);
                        var h = [0, -i.z, i.y, 0, -r.z, r.y, 0, -a.z, a.y, i.z, 0, -i.x, r.z, 0, -r.x, a.z, 0, -a.x, -i.y, i.x, 0, -r.y, r.x, 0, -a.y, a.x, 0];
                        return !!l(h) && (!!l(h = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(i, r), l(h = [u.x, u.y, u.z])))
                    }
                }(),
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new ze), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new ze;
                    return function(e) {
                        return t.copy(e).clamp(this.min, this.max).sub(e).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var t = new ze;
                    return function(e) {
                        return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new tn), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: (Ue = [new ze, new ze, new ze, new ze, new ze, new ze, new ze, new ze], function(t) {
                    return this.isEmpty() ? this : (Ue[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ue[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ue[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ue[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ue[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ue[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ue[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ue[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ue), this)
                }),
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), Object.assign(tn.prototype, {
                set: function(t, e) {
                    return this.center.copy(t), this.radius = e, this
                },
                setFromPoints: (Fe = new $e, function(t, e) {
                    var n = this.center;
                    void 0 !== e ? n.copy(e) : Fe.setFromPoints(t).getCenter(n);
                    for (var i = 0, r = 0, a = t.length; r < a; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                    return this.radius = Math.sqrt(i), this
                }),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(t, e) {
                    var n = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new ze), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                },
                getBoundingBox: function(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new $e), t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                },
                translate: function(t) {
                    return this.center.add(t), this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }), Object.assign(en.prototype, {
                set: function(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                },
                setComponents: function(t, e, n, i) {
                    return this.normal.set(t, e, n), this.constant = i, this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var t = new ze,
                        e = new ze;
                    return function(n, i, r) {
                        var a = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize();
                        return this.setFromNormalAndCoplanarPoint(a, n), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new ze), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                },
                intersectLine: function() {
                    var t = new ze;
                    return function(e, n) {
                        void 0 === n && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new ze);
                        var i = e.delta(t),
                            r = this.normal.dot(i);
                        if (0 === r) return 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0;
                        var a = -(e.start.dot(this.normal) + this.constant) / r;
                        return a < 0 || a > 1 ? void 0 : n.copy(i).multiplyScalar(a).add(e.start)
                    }
                }(),
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new ze), t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var t = new ze,
                        e = new Be;
                    return function(n, i) {
                        var r = i || e.getNormalMatrix(n),
                            a = this.coplanarPoint(t).applyMatrix4(n),
                            o = this.normal.applyMatrix3(r).normalize();
                        return this.constant = -a.dot(o), this
                    }
                }(),
                translate: function(t) {
                    return this.constant -= t.dot(this.normal), this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }), Object.assign(nn.prototype, {
                set: function(t, e, n, i, r, a) {
                    var o = this.planes;
                    return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes,
                        n = t.elements,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        c = n[5],
                        u = n[6],
                        l = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return e[0].setComponents(o - i, l - s, f - h, y - m).normalize(), e[1].setComponents(o + i, l + s, f + h, y + m).normalize(), e[2].setComponents(o + r, l + c, f + d, y + v).normalize(), e[3].setComponents(o - r, l - c, f - d, y - v).normalize(), e[4].setComponents(o - a, l - u, f - p, y - g).normalize(), e[5].setComponents(o + a, l + u, f + p, y + g).normalize(), this
                },
                intersectsObject: (Ve = new tn, function(t) {
                    var e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), Ve.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ve)
                }),
                intersectsSprite: function() {
                    var t = new tn;
                    return function(e) {
                        return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSphere: function(t) {
                    for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                        if (e[r].distanceToPoint(n) < i) return !1
                    }
                    return !0
                },
                intersectsBox: (He = new ze, function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) {
                        var i = e[n];
                        if (He.x = i.normal.x > 0 ? t.max.x : t.min.x, He.y = i.normal.y > 0 ? t.max.y : t.min.y, He.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(He) < 0) return !1
                    }
                    return !0
                }),
                containsPoint: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            });
            var rn = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
                bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
                normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
            };

            function an(t) {
                var e = {};
                for (var n in t)
                    for (var i in e[n] = {}, t[n]) {
                        var r = t[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                    }
                return e
            }

            function on(t) {
                for (var e = {}, n = 0; n < t.length; n++) {
                    var i = an(t[n]);
                    for (var r in i) e[r] = i[r]
                }
                return e
            }
            var sn, cn, un, ln = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            };

            function hn(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            Object.assign(hn.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                },
                setScalar: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                },
                setHex: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                },
                setRGB: function(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                },
                setHSL: function() {
                    function t(t, e, n) {
                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                    }
                    return function(e, n, i) {
                        if (e = De.euclideanModulo(e, 1), n = De.clamp(n, 0, 1), i = De.clamp(i, 0, 1), 0 === n) this.r = this.g = this.b = i;
                        else {
                            var r = i <= .5 ? i * (1 + n) : i + n - i * n,
                                a = 2 * i - r;
                            this.r = t(a, r, e + 1 / 3), this.g = t(a, r, e), this.b = t(a, r, e - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var i, r = n[1],
                            a = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                                if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                    var o = parseFloat(i[1]) / 360,
                                        s = parseInt(i[2], 10) / 100,
                                        c = parseInt(i[3], 10) / 100;
                                    return e(i[5]), this.setHSL(o, s, c)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var u, l = (u = n[1]).length;
                        if (3 === l) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
                        if (6 === l) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this
                    }
                    t && t.length > 0 && (void 0 !== (u = ln[t]) ? this.setHex(u) : console.warn("THREE.Color: Unknown color " + t));
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                },
                convertGammaToLinear: function(t) {
                    return this.copyGammaToLinear(this, t), this
                },
                convertLinearToGamma: function(t) {
                    return this.copyLinearToGamma(this, t), this
                },
                copySRGBToLinear: function() {
                    function t(t) {
                        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                copyLinearToSRGB: function() {
                    function t(t) {
                        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                convertSRGBToLinear: function() {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function() {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var e, n, i = this.r,
                        r = this.g,
                        a = this.b,
                        o = Math.max(i, r, a),
                        s = Math.min(i, r, a),
                        c = (s + o) / 2;
                    if (s === o) e = 0, n = 0;
                    else {
                        var u = o - s;
                        switch (n = c <= .5 ? u / (o + s) : u / (2 - o - s), o) {
                            case i:
                                e = (r - a) / u + (r < a ? 6 : 0);
                                break;
                            case r:
                                e = (a - i) / u + 2;
                                break;
                            case a:
                                e = (i - r) / u + 4
                        }
                        e /= 6
                    }
                    return t.h = e, t.s = n, t.l = c, t
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: (un = {}, function(t, e, n) {
                    return this.getHSL(un), un.h += t, un.s += e, un.l += n, this.setHSL(un.h, un.s, un.l), this
                }),
                add: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                },
                addScalar: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                },
                multiply: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                },
                multiplyScalar: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                },
                lerpHSL: (sn = {
                    h: 0,
                    s: 0,
                    l: 0
                }, cn = {
                    h: 0,
                    s: 0,
                    l: 0
                }, function(t, e) {
                    this.getHSL(sn), t.getHSL(cn);
                    var n = De.lerp(sn.h, cn.h, e),
                        i = De.lerp(sn.s, cn.s, e),
                        r = De.lerp(sn.l, cn.l, e);
                    return this.setHSL(n, i, r), this
                }),
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                },
                toJSON: function() {
                    return this.getHex()
                }
            });
            var dn, pn = {
                    common: {
                        diffuse: {
                            value: new hn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Be
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new je(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new hn(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new hn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Be
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new hn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new je(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Be
                        }
                    }
                },
                fn = {
                    basic: {
                        uniforms: on([pn.common, pn.specularmap, pn.envmap, pn.aomap, pn.lightmap, pn.fog]),
                        vertexShader: rn.meshbasic_vert,
                        fragmentShader: rn.meshbasic_frag
                    },
                    lambert: {
                        uniforms: on([pn.common, pn.specularmap, pn.envmap, pn.aomap, pn.lightmap, pn.emissivemap, pn.fog, pn.lights, {
                            emissive: {
                                value: new hn(0)
                            }
                        }]),
                        vertexShader: rn.meshlambert_vert,
                        fragmentShader: rn.meshlambert_frag
                    },
                    phong: {
                        uniforms: on([pn.common, pn.specularmap, pn.envmap, pn.aomap, pn.lightmap, pn.emissivemap, pn.bumpmap, pn.normalmap, pn.displacementmap, pn.gradientmap, pn.fog, pn.lights, {
                            emissive: {
                                value: new hn(0)
                            },
                            specular: {
                                value: new hn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: rn.meshphong_vert,
                        fragmentShader: rn.meshphong_frag
                    },
                    standard: {
                        uniforms: on([pn.common, pn.envmap, pn.aomap, pn.lightmap, pn.emissivemap, pn.bumpmap, pn.normalmap, pn.displacementmap, pn.roughnessmap, pn.metalnessmap, pn.fog, pn.lights, {
                            emissive: {
                                value: new hn(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: rn.meshphysical_vert,
                        fragmentShader: rn.meshphysical_frag
                    },
                    matcap: {
                        uniforms: on([pn.common, pn.bumpmap, pn.normalmap, pn.displacementmap, pn.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: rn.meshmatcap_vert,
                        fragmentShader: rn.meshmatcap_frag
                    },
                    points: {
                        uniforms: on([pn.points, pn.fog]),
                        vertexShader: rn.points_vert,
                        fragmentShader: rn.points_frag
                    },
                    dashed: {
                        uniforms: on([pn.common, pn.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: rn.linedashed_vert,
                        fragmentShader: rn.linedashed_frag
                    },
                    depth: {
                        uniforms: on([pn.common, pn.displacementmap]),
                        vertexShader: rn.depth_vert,
                        fragmentShader: rn.depth_frag
                    },
                    normal: {
                        uniforms: on([pn.common, pn.bumpmap, pn.normalmap, pn.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: rn.normal_vert,
                        fragmentShader: rn.normal_frag
                    },
                    sprite: {
                        uniforms: on([pn.sprite, pn.fog]),
                        vertexShader: rn.sprite_vert,
                        fragmentShader: rn.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Be
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: rn.background_vert,
                        fragmentShader: rn.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: rn.cube_vert,
                        fragmentShader: rn.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: rn.equirect_vert,
                        fragmentShader: rn.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: on([pn.common, pn.displacementmap, {
                            referencePosition: {
                                value: new ze
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: rn.distanceRGBA_vert,
                        fragmentShader: rn.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: on([pn.lights, pn.fog, {
                            color: {
                                value: new hn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: rn.shadow_vert,
                        fragmentShader: rn.shadow_frag
                    }
                };

            function mn() {
                var t = null,
                    e = !1,
                    n = null;

                function i(r, a) {
                    !1 !== e && (n(r, a), t.requestAnimationFrame(i))
                }
                return {
                    start: function() {
                        !0 !== e && null !== n && (t.requestAnimationFrame(i), e = !0)
                    },
                    stop: function() {
                        e = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function vn(t) {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var i = e.get(n);
                        i && (t.deleteBuffer(i.buffer), e.delete(n))
                    },
                    update: function(n, i) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var r = e.get(n);
                        void 0 === r ? e.set(n, function(e, n) {
                            var i = e.array,
                                r = e.dynamic ? 35048 : 35044,
                                a = t.createBuffer();
                            t.bindBuffer(n, a), t.bufferData(n, i, r), e.onUploadCallback();
                            var o = 5126;
                            return i instanceof Float32Array ? o = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? o = 5123 : i instanceof Int16Array ? o = 5122 : i instanceof Uint32Array ? o = 5125 : i instanceof Int32Array ? o = 5124 : i instanceof Int8Array ? o = 5120 : i instanceof Uint8Array && (o = 5121), {
                                buffer: a,
                                type: o,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(n, i)) : r.version < n.version && (function(e, n, i) {
                            var r = n.array,
                                a = n.updateRange;
                            t.bindBuffer(i, e), !1 === n.dynamic ? t.bufferData(i, r, 35044) : -1 === a.count ? t.bufferSubData(i, 0, r) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, a.offset * r.BYTES_PER_ELEMENT, r.subarray(a.offset, a.offset + a.count)), a.count = -1)
                        }(r.buffer, n, i), r.version = n.version)
                    }
                }
            }

            function gn(t, e, n, i, r, a) {
                this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new ze, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new hn, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
            }

            function yn(t, e, n, i) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || yn.DefaultOrder
            }

            function xn() {
                this.mask = 1
            }
            fn.physical = {
                uniforms: on([fn.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: rn.meshphysical_vert,
                fragmentShader: rn.meshphysical_frag
            }, Object.assign(gn.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            }), yn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], yn.DefaultOrder = "XYZ", Object.defineProperties(yn.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(yn.prototype, {
                isEuler: !0,
                set: function(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t, e, n) {
                    var i = De.clamp,
                        r = t.elements,
                        a = r[0],
                        o = r[4],
                        s = r[8],
                        c = r[1],
                        u = r[5],
                        l = r[9],
                        h = r[2],
                        d = r[6],
                        p = r[10];
                    return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, u), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, u))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-l, u), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === e ? (this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-l, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this.onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var t = new Ne;
                    return function(e, n, i) {
                        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, n, i)
                    }
                }(),
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: (dn = new ke, function(t) {
                    return dn.setFromEuler(this), this.setFromQuaternion(dn, t)
                }),
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new ze(this._x, this._y, this._z)
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(xn.prototype, {
                set: function(t) {
                    this.mask = 1 << t | 0
                },
                enable: function(t) {
                    this.mask |= 1 << t | 0
                },
                toggle: function(t) {
                    this.mask ^= 1 << t | 0
                },
                disable: function(t) {
                    this.mask &= ~(1 << t | 0)
                },
                test: function(t) {
                    return 0 != (this.mask & t.mask)
                }
            });
            var bn, _n, wn, Mn, Tn = 0;

            function Sn() {
                Object.defineProperty(this, "id", {
                    value: Tn++
                }), this.uuid = De.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Sn.DefaultUp.clone();
                var t = new ze,
                    e = new yn,
                    n = new ke,
                    i = new ze(1, 1, 1);
                e.onChange(function() {
                    n.setFromEuler(e, !1)
                }), n.onChange(function() {
                    e.setFromQuaternion(n, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ne
                    },
                    normalMatrix: {
                        value: new Be
                    }
                }), this.matrix = new Ne, this.matrixWorld = new Ne, this.matrixAutoUpdate = Sn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new xn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            Sn.DefaultUp = new ze(0, 1, 0), Sn.DefaultMatrixAutoUpdate = !0, Sn.prototype = Object.assign(Object.create(i.prototype), {
                constructor: Sn,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(t) {
                    this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: (Mn = new ke, function(t, e) {
                    return Mn.setFromAxisAngle(t, e), this.quaternion.multiply(Mn), this
                }),
                rotateOnWorldAxis: function() {
                    var t = new ke;
                    return function(e, n) {
                        return t.setFromAxisAngle(e, n), this.quaternion.premultiply(t), this
                    }
                }(),
                rotateX: function() {
                    var t = new ze(1, 0, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateY: function() {
                    var t = new ze(0, 1, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateZ: function() {
                    var t = new ze(0, 0, 1);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                translateOnAxis: function() {
                    var t = new ze;
                    return function(e, n) {
                        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(n)), this
                    }
                }(),
                translateX: function() {
                    var t = new ze(1, 0, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateY: function() {
                    var t = new ze(0, 1, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateZ: function() {
                    var t = new ze(0, 0, 1);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: (wn = new Ne, function(t) {
                    return t.applyMatrix4(wn.getInverse(this.matrixWorld))
                }),
                lookAt: function() {
                    var t = new ke,
                        e = new Ne,
                        n = new ze,
                        i = new ze;
                    return function(r, a, o) {
                        r.isVector3 ? n.copy(r) : n.set(r, a, o);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), i.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? e.lookAt(i, n, this.up) : e.lookAt(n, i, this.up), this.quaternion.setFromRotationMatrix(e), s && (e.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
                    }
                }(),
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                        type: "added"
                    }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var n = this.children.indexOf(t);
                    return -1 !== n && (t.parent = null, t.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(n, 1)), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var n = 0, i = this.children.length; n < i; n++) {
                        var r = this.children[n].getObjectByProperty(t, e);
                        if (void 0 !== r) return r
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new ze), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: (bn = new ze, _n = new ze, function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new ke), this.updateMatrixWorld(!0), this.matrixWorld.decompose(bn, t, _n), t
                }),
                getWorldScale: function() {
                    var t = new ze,
                        e = new ke;
                    return function(n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new ze), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n
                    }
                }(),
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new ze), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    var n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                        for (var i = this.children, r = 0, a = i.length; r < a; r++) i[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var i = {};

                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== be && (i.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(t.geometries, this.geometry);
                        var a = this.geometry.parameters;
                        if (void 0 !== a && void 0 !== a.shapes) {
                            var o = a.shapes;
                            if (Array.isArray(o))
                                for (var s = 0, c = o.length; s < c; s++) {
                                    var u = o[s];
                                    r(t.shapes, u)
                                } else r(t.shapes, o)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var l = [];
                            for (s = 0, c = this.material.length; s < c; s++) l.push(r(t.materials, this.material[s]));
                            i.material = l
                        } else i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(t).object)
                    }
                    if (e) {
                        var h = m(t.geometries),
                            d = m(t.materials),
                            p = m(t.textures),
                            f = m(t.images);
                        o = m(t.shapes);
                        h.length > 0 && (n.geometries = h), d.length > 0 && (n.materials = d), p.length > 0 && (n.textures = p), f.length > 0 && (n.images = f), o.length > 0 && (n.shapes = o)
                    }
                    return n.object = i, n;

                    function m(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var n = 0; n < t.children.length; n++) {
                            var i = t.children[n];
                            this.add(i.clone())
                        }
                    return this
                }
            });
            var En, An, Ln = 0;

            function Pn() {
                Object.defineProperty(this, "id", {
                    value: Ln += 2
                }), this.uuid = De.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function On(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function Cn(t, e, n) {
                On.call(this, new Int8Array(t), e, n)
            }

            function Rn(t, e, n) {
                On.call(this, new Uint8Array(t), e, n)
            }

            function In(t, e, n) {
                On.call(this, new Uint8ClampedArray(t), e, n)
            }

            function Dn(t, e, n) {
                On.call(this, new Int16Array(t), e, n)
            }

            function jn(t, e, n) {
                On.call(this, new Uint16Array(t), e, n)
            }

            function Nn(t, e, n) {
                On.call(this, new Int32Array(t), e, n)
            }

            function kn(t, e, n) {
                On.call(this, new Uint32Array(t), e, n)
            }

            function zn(t, e, n) {
                On.call(this, new Float32Array(t), e, n)
            }

            function Bn(t, e, n) {
                On.call(this, new Float64Array(t), e, n)
            }

            function Un() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Gn(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                return e
            }
            Pn.prototype = Object.assign(Object.create(i.prototype), {
                constructor: Pn,
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new Be).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                        this.vertices[n].applyMatrix4(t)
                    }
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n];
                        r.normal.applyMatrix3(e).normalize();
                        for (var a = 0, o = r.vertexNormals.length; a < o; a++) r.vertexNormals[a].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function() {
                    var t = new Ne;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new Ne;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new Ne;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new Ne;
                    return function(e, n, i) {
                        return t.makeTranslation(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new Ne;
                    return function(e, n, i) {
                        return t.makeScale(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                lookAt: (An = new Sn, function(t) {
                    An.lookAt(t), An.updateMatrix(), this.applyMatrix(An.matrix)
                }),
                fromBufferGeometry: function(t) {
                    var e = this,
                        n = null !== t.index ? t.index.array : void 0,
                        i = t.attributes,
                        r = i.position.array,
                        a = void 0 !== i.normal ? i.normal.array : void 0,
                        o = void 0 !== i.color ? i.color.array : void 0,
                        s = void 0 !== i.uv ? i.uv.array : void 0,
                        c = void 0 !== i.uv2 ? i.uv2.array : void 0;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var u = 0, l = 0; u < r.length; u += 3, l += 2) e.vertices.push((new ze).fromArray(r, u)), void 0 !== o && e.colors.push((new hn).fromArray(o, u));

                    function h(t, n, i, r) {
                        var u = void 0 === o ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                            l = new gn(t, n, i, void 0 === a ? [] : [(new ze).fromArray(a, 3 * t), (new ze).fromArray(a, 3 * n), (new ze).fromArray(a, 3 * i)], u, r);
                        e.faces.push(l), void 0 !== s && e.faceVertexUvs[0].push([(new je).fromArray(s, 2 * t), (new je).fromArray(s, 2 * n), (new je).fromArray(s, 2 * i)]), void 0 !== c && e.faceVertexUvs[1].push([(new je).fromArray(c, 2 * t), (new je).fromArray(c, 2 * n), (new je).fromArray(c, 2 * i)])
                    }
                    var d = t.groups;
                    if (d.length > 0)
                        for (u = 0; u < d.length; u++)
                            for (var p = d[u], f = p.start, m = (l = f, f + p.count); l < m; l += 3) void 0 !== n ? h(n[l], n[l + 1], n[l + 2], p.materialIndex) : h(l, l + 1, l + 2, p.materialIndex);
                    else if (void 0 !== n)
                        for (u = 0; u < n.length; u += 3) h(n[u], n[u + 1], n[u + 2]);
                    else
                        for (u = 0; u < r.length / 3; u += 3) h(u, u + 1, u + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: (En = new ze, function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(En).negate(), this.translate(En.x, En.y, En.z), this
                }),
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        n = 0 === e ? 1 : 1 / e,
                        i = new Ne;
                    return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
                },
                computeFaceNormals: function() {
                    for (var t = new ze, e = new ze, n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n],
                            a = this.vertices[r.a],
                            o = this.vertices[r.b],
                            s = this.vertices[r.c];
                        t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    var e, n, i, r, a, o;
                    for (void 0 === t && (t = !0), o = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) o[e] = new ze;
                    if (t) {
                        var s, c, u, l = new ze,
                            h = new ze;
                        for (i = 0, r = this.faces.length; i < r; i++) a = this.faces[i], s = this.vertices[a.a], c = this.vertices[a.b], u = this.vertices[a.c], l.subVectors(u, c), h.subVectors(s, c), l.cross(h), o[a.a].add(l), o[a.b].add(l), o[a.c].add(l)
                    } else
                        for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) o[(a = this.faces[i]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
                    for (e = 0, n = this.vertices.length; e < n; e++) o[e].normalize();
                    for (i = 0, r = this.faces.length; i < r; i++) {
                        var d = (a = this.faces[i]).vertexNormals;
                        3 === d.length ? (d[0].copy(o[a.a]), d[1].copy(o[a.b]), d[2].copy(o[a.c])) : (d[0] = o[a.a].clone(), d[1] = o[a.b].clone(), d[2] = o[a.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var t, e, n;
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                        var i = (n = this.faces[t]).vertexNormals;
                        3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, n, i, r;
                    for (n = 0, i = this.faces.length; n < i; n++)
                        for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                    var a = new Pn;
                    for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            var o = this.morphNormals[t].faceNormals,
                                s = this.morphNormals[t].vertexNormals;
                            for (n = 0, i = this.faces.length; n < i; n++) c = new ze, u = {
                                a: new ze,
                                b: new ze,
                                c: new ze
                            }, o.push(c), s.push(u)
                        }
                        var c, u, l = this.morphNormals[t];
                        for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], c = l.faceNormals[n], u = l.vertexNormals[n], c.copy(r.normal), u.a.copy(r.vertexNormals[0]), u.b.copy(r.vertexNormals[1]), u.c.copy(r.vertexNormals[2])
                    }
                    for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new $e), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new tn), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, n) {
                    if (t && t.isGeometry) {
                        var i, r = this.vertices.length,
                            a = this.vertices,
                            o = t.vertices,
                            s = this.faces,
                            c = t.faces,
                            u = this.faceVertexUvs[0],
                            l = t.faceVertexUvs[0],
                            h = this.colors,
                            d = t.colors;
                        void 0 === n && (n = 0), void 0 !== e && (i = (new Be).getNormalMatrix(e));
                        for (var p = 0, f = o.length; p < f; p++) {
                            var m = o[p].clone();
                            void 0 !== e && m.applyMatrix4(e), a.push(m)
                        }
                        for (p = 0, f = d.length; p < f; p++) h.push(d[p].clone());
                        for (p = 0, f = c.length; p < f; p++) {
                            var v, g, y, x = c[p],
                                b = x.vertexNormals,
                                _ = x.vertexColors;
                            (v = new gn(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal), void 0 !== i && v.normal.applyMatrix3(i).normalize();
                            for (var w = 0, M = b.length; w < M; w++) g = b[w].clone(), void 0 !== i && g.applyMatrix3(i).normalize(), v.vertexNormals.push(g);
                            v.color.copy(x.color);
                            for (w = 0, M = _.length; w < M; w++) y = _[w], v.vertexColors.push(y.clone());
                            v.materialIndex = x.materialIndex + n, s.push(v)
                        }
                        for (p = 0, f = l.length; p < f; p++) {
                            var T = l[p],
                                S = [];
                            if (void 0 !== T) {
                                for (w = 0, M = T.length; w < M; w++) S.push(T[w].clone());
                                u.push(S)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    var t, e, n, i, r, a, o, s, c = {},
                        u = [],
                        l = [],
                        h = Math.pow(10, 4);
                    for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n], void 0 === c[e = Math.round(t.x * h) + "_" + Math.round(t.y * h) + "_" + Math.round(t.z * h)] ? (c[e] = n, u.push(this.vertices[n]), l[n] = u.length - 1) : l[n] = l[c[e]];
                    var d = [];
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        (r = this.faces[n]).a = l[r.a], r.b = l[r.b], r.c = l[r.c], a = [r.a, r.b, r.c];
                        for (var p = 0; p < 3; p++)
                            if (a[p] === a[(p + 1) % 3]) {
                                d.push(n);
                                break
                            }
                    }
                    for (n = d.length - 1; n >= 0; n--) {
                        var f = d[n];
                        for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(f, 1)
                    }
                    var m = this.vertices.length - u.length;
                    return this.vertices = u, m
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, n = t.length; e < n; e++) {
                        var i = t[e];
                        this.vertices.push(new ze(i.x, i.y, i.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var i, r, a = this.faceVertexUvs[0],
                        o = this.faceVertexUvs[1];
                    a && a.length === e && (i = []), o && o.length === e && (r = []);
                    for (n = 0; n < e; n++) {
                        var s = t[n]._id;
                        i && i.push(a[s]), r && r.push(o[s])
                    }
                    i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    for (var i = [], r = 0; r < this.vertices.length; r++) {
                        var a = this.vertices[r];
                        i.push(a.x, a.y, a.z)
                    }
                    var o = [],
                        s = [],
                        c = {},
                        u = [],
                        l = {},
                        h = [],
                        d = {};
                    for (r = 0; r < this.faces.length; r++) {
                        var p = this.faces[r],
                            f = void 0 !== this.faceVertexUvs[0][r],
                            m = p.normal.length() > 0,
                            v = p.vertexNormals.length > 0,
                            g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                            y = p.vertexColors.length > 0,
                            x = 0;
                        if (x = M(x, 0, 0), x = M(x, 1, !0), x = M(x, 2, !1), x = M(x, 3, f), x = M(x, 4, m), x = M(x, 5, v), x = M(x, 6, g), x = M(x, 7, y), o.push(x), o.push(p.a, p.b, p.c), o.push(p.materialIndex), f) {
                            var b = this.faceVertexUvs[0][r];
                            o.push(E(b[0]), E(b[1]), E(b[2]))
                        }
                        if (m && o.push(T(p.normal)), v) {
                            var _ = p.vertexNormals;
                            o.push(T(_[0]), T(_[1]), T(_[2]))
                        }
                        if (g && o.push(S(p.color)), y) {
                            var w = p.vertexColors;
                            o.push(S(w[0]), S(w[1]), S(w[2]))
                        }
                    }

                    function M(t, e, n) {
                        return n ? t | 1 << e : t & ~(1 << e)
                    }

                    function T(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
                    }

                    function S(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== l[e] ? l[e] : (l[e] = u.length, u.push(t.getHex()), l[e])
                    }

                    function E(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== d[e] ? d[e] : (d[e] = h.length / 2, h.push(t.x, t.y), d[e])
                    }
                    return t.data = {}, t.data.vertices = i, t.data.normals = s, u.length > 0 && (t.data.colors = u), h.length > 0 && (t.data.uvs = [h]), t.data.faces = o, t
                },
                clone: function() {
                    return (new Pn).copy(this)
                },
                copy: function(t) {
                    var e, n, i, r, a, o;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var s = t.vertices;
                    for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
                    var c = t.colors;
                    for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
                    var u = t.faces;
                    for (e = 0, n = u.length; e < n; e++) this.faces.push(u[e].clone());
                    for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                        var l = t.faceVertexUvs[e];
                        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = l.length; i < r; i++) {
                            var h = l[i],
                                d = [];
                            for (a = 0, o = h.length; a < o; a++) {
                                var p = h[a];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[e].push(d)
                        }
                    }
                    var f = t.morphTargets;
                    for (e = 0, n = f.length; e < n; e++) {
                        var m = {};
                        if (m.name = f[e].name, void 0 !== f[e].vertices)
                            for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++) m.vertices.push(f[e].vertices[i].clone());
                        if (void 0 !== f[e].normals)
                            for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++) m.normals.push(f[e].normals[i].clone());
                        this.morphTargets.push(m)
                    }
                    var v = t.morphNormals;
                    for (e = 0, n = v.length; e < n; e++) {
                        var g = {};
                        if (void 0 !== v[e].vertexNormals)
                            for (g.vertexNormals = [], i = 0, r = v[e].vertexNormals.length; i < r; i++) {
                                var y = v[e].vertexNormals[i],
                                    x = {};
                                x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
                            }
                        if (void 0 !== v[e].faceNormals)
                            for (g.faceNormals = [], i = 0, r = v[e].faceNormals.length; i < r; i++) g.faceNormals.push(v[e].faceNormals[i].clone());
                        this.morphNormals.push(g)
                    }
                    var b = t.skinWeights;
                    for (e = 0, n = b.length; e < n; e++) this.skinWeights.push(b[e].clone());
                    var _ = t.skinIndices;
                    for (e = 0, n = _.length; e < n; e++) this.skinIndices.push(_[e].clone());
                    var w = t.lineDistances;
                    for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
                    var M = t.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var T = t.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(On.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(On.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (var i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new hn), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), a = new je), e[n++] = a.x, e[n++] = a.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new ze), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), a = new Ye), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z, e[n++] = a.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), Cn.prototype = Object.create(On.prototype), Cn.prototype.constructor = Cn, Rn.prototype = Object.create(On.prototype), Rn.prototype.constructor = Rn, In.prototype = Object.create(On.prototype), In.prototype.constructor = In, Dn.prototype = Object.create(On.prototype), Dn.prototype.constructor = Dn, jn.prototype = Object.create(On.prototype), jn.prototype.constructor = jn, Nn.prototype = Object.create(On.prototype), Nn.prototype.constructor = Nn, kn.prototype = Object.create(On.prototype), kn.prototype.constructor = kn, zn.prototype = Object.create(On.prototype), zn.prototype.constructor = zn, Bn.prototype = Object.create(On.prototype), Bn.prototype.constructor = Bn, Object.assign(Un.prototype, {
                computeGroups: function(t) {
                    for (var e, n = [], i = void 0, r = t.faces, a = 0; a < r.length; a++) {
                        var o = r[a];
                        o.materialIndex !== i && (i = o.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), e = {
                            start: 3 * a,
                            materialIndex: i
                        })
                    }
                    void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), this.groups = n
                },
                fromGeometry: function(t) {
                    var e, n = t.faces,
                        i = t.vertices,
                        r = t.faceVertexUvs,
                        a = r[0] && r[0].length > 0,
                        o = r[1] && r[1].length > 0,
                        s = t.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        e = [];
                        for (var u = 0; u < c; u++) e[u] = {
                            name: s[u].name,
                            data: []
                        };
                        this.morphTargets.position = e
                    }
                    var l, h = t.morphNormals,
                        d = h.length;
                    if (d > 0) {
                        l = [];
                        for (u = 0; u < d; u++) l[u] = {
                            name: h[u].name,
                            data: []
                        };
                        this.morphTargets.normal = l
                    }
                    var p = t.skinIndices,
                        f = t.skinWeights,
                        m = p.length === i.length,
                        v = f.length === i.length;
                    i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (u = 0; u < n.length; u++) {
                        var g = n[u];
                        this.vertices.push(i[g.a], i[g.b], i[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var x = g.normal;
                            this.normals.push(x, x, x)
                        }
                        var b, _ = g.vertexColors;
                        if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                        else {
                            var w = g.color;
                            this.colors.push(w, w, w)
                        }
                        if (!0 === a) void 0 !== (b = r[0][u]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new je, new je, new je));
                        if (!0 === o) void 0 !== (b = r[1][u]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new je, new je, new je));
                        for (var M = 0; M < c; M++) {
                            var T = s[M].vertices;
                            e[M].data.push(T[g.a], T[g.b], T[g.c])
                        }
                        for (M = 0; M < d; M++) {
                            var S = h[M].vertexNormals[u];
                            l[M].data.push(S.a, S.b, S.c)
                        }
                        m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                }
            });
            var Fn = 1;

            function Hn() {
                Object.defineProperty(this, "id", {
                    value: Fn += 2
                }), this.uuid = De.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function Vn(t, e, n, i, r, a) {
                Pn.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                }, this.fromBufferGeometry(new Wn(t, e, n, i, r, a)), this.mergeVertices()
            }

            function Wn(t, e, n, i, r, a) {
                Hn.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                };
                var o = this;
                t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
                var s = [],
                    c = [],
                    u = [],
                    l = [],
                    h = 0,
                    d = 0;

                function p(t, e, n, i, r, a, p, f, m, v, g) {
                    var y, x, b = a / m,
                        _ = p / v,
                        w = a / 2,
                        M = p / 2,
                        T = f / 2,
                        S = m + 1,
                        E = v + 1,
                        A = 0,
                        L = 0,
                        P = new ze;
                    for (x = 0; x < E; x++) {
                        var O = x * _ - M;
                        for (y = 0; y < S; y++) {
                            var C = y * b - w;
                            P[t] = C * i, P[e] = O * r, P[n] = T, c.push(P.x, P.y, P.z), P[t] = 0, P[e] = 0, P[n] = f > 0 ? 1 : -1, u.push(P.x, P.y, P.z), l.push(y / m), l.push(1 - x / v), A += 1
                        }
                    }
                    for (x = 0; x < v; x++)
                        for (y = 0; y < m; y++) {
                            var R = h + y + S * x,
                                I = h + y + S * (x + 1),
                                D = h + (y + 1) + S * (x + 1),
                                j = h + (y + 1) + S * x;
                            s.push(R, I, j), s.push(I, D, j), L += 6
                        }
                    o.addGroup(d, L, g), d += L, h += A
                }
                p("z", "y", "x", -1, -1, n, e, t, a, r, 0), p("z", "y", "x", 1, -1, n, e, -t, a, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, a, 2), p("x", "z", "y", 1, -1, t, n, -e, i, a, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(s), this.addAttribute("position", new zn(c, 3)), this.addAttribute("normal", new zn(u, 3)), this.addAttribute("uv", new zn(l, 2))
            }

            function qn(t, e, n, i) {
                Pn.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                }, this.fromBufferGeometry(new Xn(t, e, n, i)), this.mergeVertices()
            }

            function Xn(t, e, n, i) {
                Hn.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                var r, a, o = (t = t || 1) / 2,
                    s = (e = e || 1) / 2,
                    c = Math.floor(n) || 1,
                    u = Math.floor(i) || 1,
                    l = c + 1,
                    h = u + 1,
                    d = t / c,
                    p = e / u,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (a = 0; a < h; a++) {
                    var y = a * p - s;
                    for (r = 0; r < l; r++) {
                        var x = r * d - o;
                        m.push(x, -y, 0), v.push(0, 0, 1), g.push(r / c), g.push(1 - a / u)
                    }
                }
                for (a = 0; a < u; a++)
                    for (r = 0; r < c; r++) {
                        var b = r + l * a,
                            _ = r + l * (a + 1),
                            w = r + 1 + l * (a + 1),
                            M = r + 1 + l * a;
                        f.push(b, _, M), f.push(_, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new zn(m, 3)), this.addAttribute("normal", new zn(v, 3)), this.addAttribute("uv", new zn(g, 2))
            }
            Hn.prototype = Object.assign(Object.create(i.prototype), {
                constructor: Hn,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(Gn(t) > 65535 ? kn : jn)(t, 1) : this.index = t
                },
                addAttribute: function(t, e) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new On(arguments[1], arguments[2])))
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, n) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                    var n = this.attributes.normal;
                    void 0 !== n && ((new Be).getNormalMatrix(t).applyToBufferAttribute(n), n.needsUpdate = !0);
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() {
                    var t = new Ne;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new Ne;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new Ne;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new Ne;
                    return function(e, n, i) {
                        return t.makeTranslation(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new Ne;
                    return function(e, n, i) {
                        return t.makeScale(e, n, i), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new Sn;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                center: function() {
                    var t = new ze;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        var n = new zn(3 * e.vertices.length, 3),
                            i = new zn(3 * e.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var r = new zn(e.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    for (var e = [], n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new zn(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, n = t.geometry;
                    if (t.isMesh) {
                        var i = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                        i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new Un).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new On(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        var n = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new On(n, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var i = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new On(i, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var r = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new On(r, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var a = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new On(a, 2).copyVector2sArray(t.uvs2))
                    }
                    for (var o in this.groups = t.groups, t.morphTargets) {
                        for (var s = [], c = t.morphTargets[o], u = 0, l = c.length; u < l; u++) {
                            var h = c[u],
                                d = new zn(3 * h.data.length, 3);
                            d.name = h.name, s.push(d.copyVector3sArray(h.data))
                        }
                        this.morphAttributes[o] = s
                    }
                    if (t.skinIndices.length > 0) {
                        var p = new zn(4 * t.skinIndices.length, 4);
                        this.addAttribute("skinIndex", p.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var f = new zn(4 * t.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new $e);
                    var t = this.attributes.position;
                    void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    var t = new $e,
                        e = new ze;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new tn);
                        var n = this.attributes.position;
                        if (n) {
                            var i = this.boundingSphere.center;
                            t.setFromBufferAttribute(n), t.getCenter(i);
                            for (var r = 0, a = 0, o = n.count; a < o; a++) e.x = n.getX(a), e.y = n.getY(a), e.z = n.getZ(a), r = Math.max(r, i.distanceToSquared(e));
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.attributes;
                    if (e.position) {
                        var n = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new On(new Float32Array(n.length), 3));
                        else
                            for (var i = e.normal.array, r = 0, a = i.length; r < a; r++) i[r] = 0;
                        var o, s, c, u = e.normal.array,
                            l = new ze,
                            h = new ze,
                            d = new ze,
                            p = new ze,
                            f = new ze;
                        if (t) {
                            var m = t.array;
                            for (r = 0, a = t.count; r < a; r += 3) o = 3 * m[r + 0], s = 3 * m[r + 1], c = 3 * m[r + 2], l.fromArray(n, o), h.fromArray(n, s), d.fromArray(n, c), p.subVectors(d, h), f.subVectors(l, h), p.cross(f), u[o] += p.x, u[o + 1] += p.y, u[o + 2] += p.z, u[s] += p.x, u[s + 1] += p.y, u[s + 2] += p.z, u[c] += p.x, u[c + 1] += p.y, u[c + 2] += p.z
                        } else
                            for (r = 0, a = n.length; r < a; r += 9) l.fromArray(n, r), h.fromArray(n, r + 3), d.fromArray(n, r + 6), p.subVectors(d, h), f.subVectors(l, h), p.cross(f), u[r] = p.x, u[r + 1] = p.y, u[r + 2] = p.z, u[r + 3] = p.x, u[r + 4] = p.y, u[r + 5] = p.z, u[r + 6] = p.x, u[r + 7] = p.y, u[r + 8] = p.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var n = this.attributes;
                        for (var i in n)
                            if (void 0 !== t.attributes[i])
                                for (var r = n[i].array, a = t.attributes[i], o = a.array, s = 0, c = a.itemSize * e; s < o.length; s++, c++) r[c] = o[s];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
                },
                normalizeNormals: function() {
                    var t = new ze;
                    return function() {
                        for (var e = this.attributes.normal, n = 0, i = e.count; n < i; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.normalize(), e.setXYZ(n, t.x, t.y, t.z)
                    }
                }(),
                toNonIndexed: function() {
                    function t(t, e) {
                        for (var n = t.array, i = t.itemSize, r = new n.constructor(e.length * i), a = 0, o = 0, s = 0, c = e.length; s < c; s++) {
                            a = e[s] * i;
                            for (var u = 0; u < i; u++) r[o++] = n[a++]
                        }
                        return new On(r, i)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var e = new Hn,
                        n = this.index.array,
                        i = this.attributes;
                    for (var r in i) {
                        var a = t(i[r], n);
                        e.addAttribute(r, a)
                    }
                    var o = this.morphAttributes;
                    for (r in o) {
                        for (var s = [], c = o[r], u = 0, l = c.length; u < l; u++) {
                            a = t(c[u], n);
                            s.push(a)
                        }
                        e.morphAttributes[r] = s
                    }
                    for (var h = this.groups, d = (u = 0, h.length); u < d; u++) {
                        var p = h[u];
                        e.addGroup(p.start, p.count, p.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var i = this.index;
                    if (null !== i) {
                        var r = Array.prototype.slice.call(i.array);
                        t.data.index = {
                            type: i.array.constructor.name,
                            array: r
                        }
                    }
                    var a = this.attributes;
                    for (var n in a) {
                        var o = a[n];
                        r = Array.prototype.slice.call(o.array);
                        t.data.attributes[n] = {
                            itemSize: o.itemSize,
                            type: o.array.constructor.name,
                            array: r,
                            normalized: o.normalized
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    var c = this.boundingSphere;
                    return null !== c && (t.data.boundingSphere = {
                        center: c.center.toArray(),
                        radius: c.radius
                    }), t
                },
                clone: function() {
                    return (new Hn).copy(this)
                },
                copy: function(t) {
                    var e, n, i;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var r = t.index;
                    null !== r && this.setIndex(r.clone());
                    var a = t.attributes;
                    for (e in a) {
                        var o = a[e];
                        this.addAttribute(e, o.clone())
                    }
                    var s = t.morphAttributes;
                    for (e in s) {
                        var c = [],
                            u = s[e];
                        for (n = 0, i = u.length; n < i; n++) c.push(u[n].clone());
                        this.morphAttributes[e] = c
                    }
                    var l = t.groups;
                    for (n = 0, i = l.length; n < i; n++) {
                        var h = l[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var d = t.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = t.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Vn.prototype = Object.create(Pn.prototype), Vn.prototype.constructor = Vn, Wn.prototype = Object.create(Hn.prototype), Wn.prototype.constructor = Wn, qn.prototype = Object.create(Pn.prototype), qn.prototype.constructor = qn, Xn.prototype = Object.create(Hn.prototype), Xn.prototype.constructor = Xn;
            var Yn, Zn, Jn, Kn, Qn, $n, ti, ei, ni, ii, ri, ai, oi = 0;

            function si() {
                Object.defineProperty(this, "id", {
                    value: oi++
                }), this.uuid = De.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = P, this.side = w, this.flatShading = !1, this.vertexColors = S, this.opacity = 1, this.transparent = !1, this.blendSrc = H, this.blendDst = V, this.blendEquation = D, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = $, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function ci(t) {
                si.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function ui(t, e) {
                this.origin = void 0 !== t ? t : new ze, this.direction = void 0 !== e ? e : new ze
            }

            function li(t, e, n) {
                this.a = void 0 !== t ? t : new ze, this.b = void 0 !== e ? e : new ze, this.c = void 0 !== n ? n : new ze
            }

            function hi(t) {
                si.call(this), this.type = "MeshBasicMaterial", this.color = new hn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = rt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function di(t, e) {
                Sn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Hn, this.material = void 0 !== e ? e : new hi({
                    color: 16777215 * Math.random()
                }), this.drawMode = be, this.updateMorphTargets()
            }

            function pi(t, e, n, i) {
                var r, a, o = new hn(0),
                    s = 0,
                    c = null,
                    u = 0;

                function l(t, n) {
                    e.buffers.color.setClear(t.r, t.g, t.b, n, i)
                }
                return {
                    getClearColor: function() {
                        return o
                    },
                    setClearColor: function(t, e) {
                        o.set(t), l(o, s = void 0 !== e ? e : 1)
                    },
                    getClearAlpha: function() {
                        return s
                    },
                    setClearAlpha: function(t) {
                        l(o, s = t)
                    },
                    render: function(e, i, h, d) {
                        var p = i.background;
                        if (null === p ? (l(o, s), c = null, u = 0) : p && p.isColor && (l(p, 1), d = !0, c = null, u = 0), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), p && (p.isCubeTexture || p.isWebGLRenderTargetCube)) {
                            void 0 === a && ((a = new di(new Wn(1, 1, 1), new ci({
                                type: "BackgroundCubeMaterial",
                                uniforms: an(fn.cube.uniforms),
                                vertexShader: fn.cube.vertexShader,
                                fragmentShader: fn.cube.fragmentShader,
                                side: M,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            }))).geometry.removeAttribute("normal"), a.geometry.removeAttribute("uv"), a.onBeforeRender = function(t, e, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld)
                            }, Object.defineProperty(a.material, "map", {
                                get: function() {
                                    return this.uniforms.tCube.value
                                }
                            }), n.update(a));
                            var f = p.isWebGLRenderTargetCube ? p.texture : p;
                            a.material.uniforms.tCube.value = f, a.material.uniforms.tFlip.value = p.isWebGLRenderTargetCube ? 1 : -1, c === p && u === f.version || (a.material.needsUpdate = !0, c = p, u = f.version), e.unshift(a, a.geometry, a.material, 0, 0, null)
                        } else p && p.isTexture && (void 0 === r && ((r = new di(new Xn(2, 2), new ci({
                            type: "BackgroundMaterial",
                            uniforms: an(fn.background.uniforms),
                            vertexShader: fn.background.vertexShader,
                            fragmentShader: fn.background.fragmentShader,
                            side: w,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"), Object.defineProperty(r.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), n.update(r)), r.material.uniforms.t2D.value = p, !0 === p.matrixAutoUpdate && p.updateMatrix(), r.material.uniforms.uvTransform.value.copy(p.matrix), c === p && u === p.version || (r.material.needsUpdate = !0, c = p, u = p.version), e.unshift(r, r.geometry, r.material, 0, 0, null))
                    }
                }
            }

            function fi(t, e, n, i) {
                var r;
                this.setMode = function(t) {
                    r = t
                }, this.render = function(e, i) {
                    t.drawArrays(r, e, i), n.update(i, r)
                }, this.renderInstances = function(a, o, s) {
                    var c;
                    if (i.isWebGL2) c = t;
                    else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[i.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, o, s, a.maxInstancedCount), n.update(s, r, a.maxInstancedCount)
                }
            }

            function mi(t, e, n) {
                var i;

                function r(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                    o = void 0 !== n.precision ? n.precision : "highp",
                    s = r(o);
                s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
                var c = !0 === n.logarithmicDepthBuffer,
                    u = t.getParameter(34930),
                    l = t.getParameter(35660),
                    h = t.getParameter(3379),
                    d = t.getParameter(34076),
                    p = t.getParameter(34921),
                    f = t.getParameter(36347),
                    m = t.getParameter(36348),
                    v = t.getParameter(36349),
                    g = l > 0,
                    y = a || !!e.get("OES_texture_float");
                return {
                    isWebGL2: a,
                    getMaxAnisotropy: function() {
                        if (void 0 !== i) return i;
                        var n = e.get("EXT_texture_filter_anisotropic");
                        return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: r,
                    precision: o,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: l,
                    maxTextureSize: h,
                    maxCubemapSize: d,
                    maxAttributes: p,
                    maxVertexUniforms: f,
                    maxVaryings: m,
                    maxFragmentUniforms: v,
                    vertexTextures: g,
                    floatFragmentTextures: y,
                    floatVertexTextures: g && y,
                    maxSamples: a ? t.getParameter(36183) : 0
                }
            }

            function vi() {
                var t = this,
                    e = null,
                    n = 0,
                    i = !1,
                    r = !1,
                    a = new en,
                    o = new Be,
                    s = {
                        value: null,
                        needsUpdate: !1
                    };

                function c() {
                    s.value !== e && (s.value = e, s.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                }

                function u(e, n, i, r) {
                    var c = null !== e ? e.length : 0,
                        u = null;
                    if (0 !== c) {
                        if (u = s.value, !0 !== r || null === u) {
                            var l = i + 4 * c,
                                h = n.matrixWorldInverse;
                            o.getNormalMatrix(h), (null === u || u.length < l) && (u = new Float32Array(l));
                            for (var d = 0, p = i; d !== c; ++d, p += 4) a.copy(e[d]).applyMatrix4(h, o), a.normal.toArray(u, p), u[p + 3] = a.constant
                        }
                        s.value = u, s.needsUpdate = !0
                    }
                    return t.numPlanes = c, u
                }
                this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, a) {
                    var o = 0 !== t.length || r || 0 !== n || i;
                    return i = r, e = u(t, a, 0), n = t.length, o
                }, this.beginShadows = function() {
                    r = !0, u(null)
                }, this.endShadows = function() {
                    r = !1, c()
                }, this.setState = function(t, a, o, l, h, d) {
                    if (!i || null === t || 0 === t.length || r && !o) r ? u(null) : c();
                    else {
                        var p = r ? 0 : n,
                            f = 4 * p,
                            m = h.clippingState || null;
                        s.value = m, m = u(t, l, f, d);
                        for (var v = 0; v !== f; ++v) m[v] = e[v];
                        h.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += p
                    }
                }
            }

            function gi(t) {
                var e = {};
                return {
                    get: function(n) {
                        if (void 0 !== e[n]) return e[n];
                        var i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = t.getExtension(n)
                        }
                        return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
                    }
                }
            }

            function yi(t, e, n) {
                var i = {},
                    r = {};

                function a(t) {
                    var o = t.target,
                        s = i[o.id];
                    for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                    o.removeEventListener("dispose", a), delete i[o.id];
                    var u = r[s.id];
                    u && (e.remove(u), delete r[s.id]), n.memory.geometries--
                }
                return {
                    get: function(t, e) {
                        var r = i[e.id];
                        return r || (e.addEventListener("dispose", a), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Hn).setFromObject(t)), r = e._bufferGeometry), i[e.id] = r, n.memory.geometries++, r)
                    },
                    update: function(t) {
                        var n = t.index,
                            i = t.attributes;
                        for (var r in null !== n && e.update(n, 34963), i) e.update(i[r], 34962);
                        var a = t.morphAttributes;
                        for (var r in a)
                            for (var o = a[r], s = 0, c = o.length; s < c; s++) e.update(o[s], 34962)
                    },
                    getWireframeAttribute: function(t) {
                        var n = r[t.id];
                        if (n) return n;
                        var i, a = [],
                            o = t.index,
                            s = t.attributes;
                        if (null !== o)
                            for (var c = 0, u = (i = o.array).length; c < u; c += 3) {
                                var l = i[c + 0],
                                    h = i[c + 1],
                                    d = i[c + 2];
                                a.push(l, h, h, d, d, l)
                            } else
                                for (c = 0, u = (i = s.position.array).length / 3 - 1; c < u; c += 3) l = c + 0, h = c + 1, d = c + 2, a.push(l, h, h, d, d, l);
                        return n = new(Gn(a) > 65535 ? kn : jn)(a, 1), e.update(n, 34963), r[t.id] = n, n
                    }
                }
            }

            function xi(t, e, n, i) {
                var r, a, o;
                this.setMode = function(t) {
                    r = t
                }, this.setIndex = function(t) {
                    a = t.type, o = t.bytesPerElement
                }, this.render = function(e, i) {
                    t.drawElements(r, i, a, e * o), n.update(i, r)
                }, this.renderInstances = function(s, c, u) {
                    var l;
                    if (i.isWebGL2) l = t;
                    else if (null === (l = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[i.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, u, a, c * o, s.maxInstancedCount), n.update(u, r, s.maxInstancedCount)
                }
            }

            function bi(t) {
                var e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function(t, n, i) {
                        switch (i = i || 1, e.calls++, n) {
                            case 4:
                                e.triangles += i * (t / 3);
                                break;
                            case 5:
                            case 6:
                                e.triangles += i * (t - 2);
                                break;
                            case 1:
                                e.lines += i * (t / 2);
                                break;
                            case 3:
                                e.lines += i * (t - 1);
                                break;
                            case 2:
                                e.lines += i * t;
                                break;
                            case 0:
                                e.points += i * t;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }

            function _i(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function wi(t) {
                var e = {},
                    n = new Float32Array(8);
                return {
                    update: function(i, r, a, o) {
                        var s = i.morphTargetInfluences,
                            c = s.length,
                            u = e[r.id];
                        if (void 0 === u) {
                            u = [];
                            for (var l = 0; l < c; l++) u[l] = [l, 0];
                            e[r.id] = u
                        }
                        var h = a.morphTargets && r.morphAttributes.position,
                            d = a.morphNormals && r.morphAttributes.normal;
                        for (l = 0; l < c; l++) 0 !== (p = u[l])[1] && (h && r.removeAttribute("morphTarget" + l), d && r.removeAttribute("morphNormal" + l));
                        for (l = 0; l < c; l++)(p = u[l])[0] = l, p[1] = s[l];
                        for (u.sort(_i), l = 0; l < 8; l++) {
                            var p;
                            if (p = u[l]) {
                                var f = p[0],
                                    m = p[1];
                                if (m) {
                                    h && r.addAttribute("morphTarget" + l, h[f]), d && r.addAttribute("morphNormal" + l, d[f]), n[l] = m;
                                    continue
                                }
                            }
                            n[l] = 0
                        }
                        o.getUniforms().setValue(t, "morphTargetInfluences", n)
                    }
                }
            }

            function Mi(t, e) {
                var n = {};
                return {
                    update: function(i) {
                        var r = e.render.frame,
                            a = i.geometry,
                            o = t.get(i, a);
                        return n[o.id] !== r && (a.isGeometry && o.updateFromObject(i), t.update(o), n[o.id] = r), o
                    },
                    dispose: function() {
                        n = {}
                    }
                }
            }

            function Ti(t, e, n, i, r, a, o, s, c, u) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : pt, Xe.call(this, t, e, n, i, r, a, o, s, c, u), this.flipY = !1
            }

            function Si(t, e, n, i) {
                Xe.call(this, null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = Mt, this.minFilter = Mt, this.generateMipmaps = !1, this.flipY = !1
            }
            si.prototype = Object.assign(Object.create(i.prototype), {
                constructor: si,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var n = t[e];
                            if (void 0 !== n)
                                if ("shading" !== e) {
                                    var i = this[e];
                                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function i(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== P && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== w && (n.side = this.side), this.vertexColors !== S && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        var r = i(t.textures),
                            a = i(t.images);
                        r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                    var e = t.clippingPlanes,
                        n = null;
                    if (null !== e) {
                        var i = e.length;
                        n = new Array(i);
                        for (var r = 0; r !== i; ++r) n[r] = e[r].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = t.shadowSide, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), ci.prototype = Object.create(si.prototype), ci.prototype.constructor = ci, ci.prototype.isShaderMaterial = !0, ci.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = an(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
            }, ci.prototype.toJSON = function(t) {
                var e = si.prototype.toJSON.call(this, t);
                for (var n in e.uniforms = {}, this.uniforms) {
                    var i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                var r = {};
                for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
                return Object.keys(r).length > 0 && (e.extensions = r), e
            }, Object.assign(ui.prototype, {
                set: function(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new ze), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                },
                recast: function() {
                    var t = new ze;
                    return function(e) {
                        return this.origin.copy(this.at(e, t)), this
                    }
                }(),
                closestPointToPoint: function(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new ze), e.subVectors(t, this.origin);
                    var n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function() {
                    var t = new ze;
                    return function(e) {
                        var n = t.subVectors(e, this.origin).dot(this.direction);
                        return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e))
                    }
                }(),
                distanceSqToSegment: (Zn = new ze, Jn = new ze, Kn = new ze, function(t, e, n, i) {
                    Zn.copy(t).add(e).multiplyScalar(.5), Jn.copy(e).sub(t).normalize(), Kn.copy(this.origin).sub(Zn);
                    var r, a, o, s, c = .5 * t.distanceTo(e),
                        u = -this.direction.dot(Jn),
                        l = Kn.dot(this.direction),
                        h = -Kn.dot(Jn),
                        d = Kn.lengthSq(),
                        p = Math.abs(1 - u * u);
                    if (p > 0)
                        if (a = u * l - h, s = c * p, (r = u * h - l) >= 0)
                            if (a >= -s)
                                if (a <= s) {
                                    var f = 1 / p;
                                    o = (r *= f) * (r + u * (a *= f) + 2 * l) + a * (u * r + a + 2 * h) + d
                                } else a = c, o = -(r = Math.max(0, -(u * a + l))) * r + a * (a + 2 * h) + d;
                    else a = -c, o = -(r = Math.max(0, -(u * a + l))) * r + a * (a + 2 * h) + d;
                    else a <= -s ? o = -(r = Math.max(0, -(-u * c + l))) * r + (a = r > 0 ? -c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d : a <= s ? (r = 0, o = (a = Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d) : o = -(r = Math.max(0, -(u * c + l))) * r + (a = r > 0 ? c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d;
                    else a = u > 0 ? -c : c, o = -(r = Math.max(0, -(u * a + l))) * r + a * (a + 2 * h) + d;
                    return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(Jn).multiplyScalar(a).add(Zn), o
                }),
                intersectSphere: function() {
                    var t = new ze;
                    return function(e, n) {
                        t.subVectors(e.center, this.origin);
                        var i = t.dot(this.direction),
                            r = t.dot(t) - i * i,
                            a = e.radius * e.radius;
                        if (r > a) return null;
                        var o = Math.sqrt(a - r),
                            s = i - o,
                            c = i + o;
                        return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
                    }
                }(),
                intersectsSphere: function(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                },
                intersectPlane: function(t, e) {
                    var n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0
                },
                intersectBox: function(t, e) {
                    var n, i, r, a, o, s, c = 1 / this.direction.x,
                        u = 1 / this.direction.y,
                        l = 1 / this.direction.z,
                        h = this.origin;
                    return c >= 0 ? (n = (t.min.x - h.x) * c, i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, i = (t.min.x - h.x) * c), u >= 0 ? (r = (t.min.y - h.y) * u, a = (t.max.y - h.y) * u) : (r = (t.max.y - h.y) * u, a = (t.min.y - h.y) * u), n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), l >= 0 ? (o = (t.min.z - h.z) * l, s = (t.max.z - h.z) * l) : (o = (t.max.z - h.z) * l, s = (t.min.z - h.z) * l), n > s || o > i ? null : ((o > n || n != n) && (n = o), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                },
                intersectsBox: (Yn = new ze, function(t) {
                    return null !== this.intersectBox(t, Yn)
                }),
                intersectTriangle: function() {
                    var t = new ze,
                        e = new ze,
                        n = new ze,
                        i = new ze;
                    return function(r, a, o, s, c) {
                        e.subVectors(a, r), n.subVectors(o, r), i.crossVectors(e, n);
                        var u, l = this.direction.dot(i);
                        if (l > 0) {
                            if (s) return null;
                            u = 1
                        } else {
                            if (!(l < 0)) return null;
                            u = -1, l = -l
                        }
                        t.subVectors(this.origin, r);
                        var h = u * this.direction.dot(n.crossVectors(t, n));
                        if (h < 0) return null;
                        var d = u * this.direction.dot(e.cross(t));
                        if (d < 0) return null;
                        if (h + d > l) return null;
                        var p = -u * t.dot(i);
                        return p < 0 ? null : this.at(p / l, c)
                    }
                }(),
                applyMatrix4: function(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }), Object.assign(li, {
                getNormal: ($n = new ze, function(t, e, n, i) {
                    void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new ze), i.subVectors(n, e), $n.subVectors(t, e), i.cross($n);
                    var r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                }),
                getBarycoord: function() {
                    var t = new ze,
                        e = new ze,
                        n = new ze;
                    return function(i, r, a, o, s) {
                        t.subVectors(o, r), e.subVectors(a, r), n.subVectors(i, r);
                        var c = t.dot(t),
                            u = t.dot(e),
                            l = t.dot(n),
                            h = e.dot(e),
                            d = e.dot(n),
                            p = c * h - u * u;
                        if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new ze), 0 === p) return s.set(-2, -1, -1);
                        var f = 1 / p,
                            m = (h * l - u * d) * f,
                            v = (c * d - u * l) * f;
                        return s.set(1 - m - v, v, m)
                    }
                }(),
                containsPoint: function() {
                    var t = new ze;
                    return function(e, n, i, r) {
                        return li.getBarycoord(e, n, i, r, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                    }
                }(),
                getUV: (Qn = new ze, function(t, e, n, i, r, a, o, s) {
                    return this.getBarycoord(t, e, n, i, Qn), s.set(0, 0), s.addScaledVector(r, Qn.x), s.addScaledVector(a, Qn.y), s.addScaledVector(o, Qn.z), s
                })
            }), Object.assign(li.prototype, {
                set: function(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                },
                setFromPointsAndIndices: function(t, e, n, i) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                },
                getArea: function() {
                    var t = new ze,
                        e = new ze;
                    return function() {
                        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                    }
                }(),
                getMidpoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new ze), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(t) {
                    return li.getNormal(this.a, this.b, this.c, t)
                },
                getPlane: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new ze), t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(t, e) {
                    return li.getBarycoord(t, this.a, this.b, this.c, e)
                },
                containsPoint: function(t) {
                    return li.containsPoint(t, this.a, this.b, this.c)
                },
                getUV: function(t, e, n, i, r) {
                    return li.getUV(t, this.a, this.b, this.c, e, n, i, r)
                },
                intersectsBox: function(t) {
                    return t.intersectsTriangle(this)
                },
                closestPointToPoint: (ti = new ze, ei = new ze, ni = new ze, ii = new ze, ri = new ze, ai = new ze, function(t, e) {
                    void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new ze);
                    var n, i, r = this.a,
                        a = this.b,
                        o = this.c;
                    ti.subVectors(a, r), ei.subVectors(o, r), ii.subVectors(t, r);
                    var s = ti.dot(ii),
                        c = ei.dot(ii);
                    if (s <= 0 && c <= 0) return e.copy(r);
                    ri.subVectors(t, a);
                    var u = ti.dot(ri),
                        l = ei.dot(ri);
                    if (u >= 0 && l <= u) return e.copy(a);
                    var h = s * l - u * c;
                    if (h <= 0 && s >= 0 && u <= 0) return n = s / (s - u), e.copy(r).addScaledVector(ti, n);
                    ai.subVectors(t, o);
                    var d = ti.dot(ai),
                        p = ei.dot(ai);
                    if (p >= 0 && d <= p) return e.copy(o);
                    var f = d * c - s * p;
                    if (f <= 0 && c >= 0 && p <= 0) return i = c / (c - p), e.copy(r).addScaledVector(ei, i);
                    var m = u * p - d * l;
                    if (m <= 0 && l - u >= 0 && d - p >= 0) return ni.subVectors(o, a), i = (l - u) / (l - u + (d - p)), e.copy(a).addScaledVector(ni, i);
                    var v = 1 / (m + f + h);
                    return n = f * v, i = h * v, e.copy(r).addScaledVector(ti, n).addScaledVector(ei, i)
                }),
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }), hi.prototype = Object.create(si.prototype), hi.prototype.constructor = hi, hi.prototype.isMeshBasicMaterial = !0, hi.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            }, di.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: di,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return Sn.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var t, e, n, i = this.geometry;
                    if (i.isBufferGeometry) {
                        var r = i.morphAttributes,
                            a = Object.keys(r);
                        if (a.length > 0) {
                            var o = r[a[0]];
                            if (void 0 !== o)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++) n = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    } else {
                        var s = i.morphTargets;
                        void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function() {
                    var t = new Ne,
                        e = new ui,
                        n = new tn,
                        i = new ze,
                        r = new ze,
                        a = new ze,
                        o = new ze,
                        s = new ze,
                        c = new ze,
                        u = new je,
                        l = new je,
                        h = new je,
                        d = new ze,
                        p = new ze;

                    function f(t, e, n, i, r, a, o, s) {
                        if (null === (e.side === M ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, e.side !== T, s))) return null;
                        p.copy(s), p.applyMatrix4(t.matrixWorld);
                        var c = n.ray.origin.distanceTo(p);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: p.clone(),
                            object: t
                        }
                    }

                    function m(t, e, n, o, s, c, p, m, v) {
                        i.fromBufferAttribute(s, p), r.fromBufferAttribute(s, m), a.fromBufferAttribute(s, v);
                        var g = f(t, e, n, o, i, r, a, d);
                        if (g) {
                            c && (u.fromBufferAttribute(c, p), l.fromBufferAttribute(c, m), h.fromBufferAttribute(c, v), g.uv = li.getUV(d, i, r, a, u, l, h, new je));
                            var y = new gn(p, m, v);
                            li.getNormal(i, r, a, y.normal), g.face = y
                        }
                        return g
                    }
                    return function(p, v) {
                        var g, y = this.geometry,
                            x = this.material,
                            b = this.matrixWorld;
                        if (void 0 !== x && (null === y.boundingSphere && y.computeBoundingSphere(), n.copy(y.boundingSphere), n.applyMatrix4(b), !1 !== p.ray.intersectsSphere(n) && (t.getInverse(b), e.copy(p.ray).applyMatrix4(t), null === y.boundingBox || !1 !== e.intersectsBox(y.boundingBox))))
                            if (y.isBufferGeometry) {
                                var _, w, M, T, S, E, A, L, P, O = y.index,
                                    C = y.attributes.position,
                                    R = y.attributes.uv,
                                    I = y.groups,
                                    D = y.drawRange;
                                if (null !== O)
                                    if (Array.isArray(x))
                                        for (T = 0, E = I.length; T < E; T++)
                                            for (P = x[(L = I[T]).materialIndex], S = Math.max(L.start, D.start), A = Math.min(L.start + L.count, D.start + D.count); S < A; S += 3) _ = O.getX(S), w = O.getX(S + 1), M = O.getX(S + 2), (g = m(this, P, p, e, C, R, _, w, M)) && (g.faceIndex = Math.floor(S / 3), g.face.materialIndex = L.materialIndex, v.push(g));
                                    else
                                        for (T = Math.max(0, D.start), E = Math.min(O.count, D.start + D.count); T < E; T += 3) _ = O.getX(T), w = O.getX(T + 1), M = O.getX(T + 2), (g = m(this, x, p, e, C, R, _, w, M)) && (g.faceIndex = Math.floor(T / 3), v.push(g));
                                else if (void 0 !== C)
                                    if (Array.isArray(x))
                                        for (T = 0, E = I.length; T < E; T++)
                                            for (P = x[(L = I[T]).materialIndex], S = Math.max(L.start, D.start), A = Math.min(L.start + L.count, D.start + D.count); S < A; S += 3)(g = m(this, P, p, e, C, R, _ = S, w = S + 1, M = S + 2)) && (g.faceIndex = Math.floor(S / 3), g.face.materialIndex = L.materialIndex, v.push(g));
                                    else
                                        for (T = Math.max(0, D.start), E = Math.min(C.count, D.start + D.count); T < E; T += 3)(g = m(this, x, p, e, C, R, _ = T, w = T + 1, M = T + 2)) && (g.faceIndex = Math.floor(T / 3), v.push(g))
                            } else if (y.isGeometry) {
                            var j, N, k, z, B = Array.isArray(x),
                                U = y.vertices,
                                G = y.faces,
                                F = y.faceVertexUvs[0];
                            F.length > 0 && (z = F);
                            for (var H = 0, V = G.length; H < V; H++) {
                                var W = G[H],
                                    q = B ? x[W.materialIndex] : x;
                                if (void 0 !== q) {
                                    if (j = U[W.a], N = U[W.b], k = U[W.c], !0 === q.morphTargets) {
                                        var X = y.morphTargets,
                                            Y = this.morphTargetInfluences;
                                        i.set(0, 0, 0), r.set(0, 0, 0), a.set(0, 0, 0);
                                        for (var Z = 0, J = X.length; Z < J; Z++) {
                                            var K = Y[Z];
                                            if (0 !== K) {
                                                var Q = X[Z].vertices;
                                                i.addScaledVector(o.subVectors(Q[W.a], j), K), r.addScaledVector(s.subVectors(Q[W.b], N), K), a.addScaledVector(c.subVectors(Q[W.c], k), K)
                                            }
                                        }
                                        i.add(j), r.add(N), a.add(k), j = i, N = r, k = a
                                    }
                                    if (g = f(this, q, p, e, j, N, k, d)) {
                                        if (z && z[H]) {
                                            var $ = z[H];
                                            u.copy($[0]), l.copy($[1]), h.copy($[2]), g.uv = li.getUV(d, j, N, k, u, l, h, new je)
                                        }
                                        g.face = W, g.faceIndex = H, v.push(g)
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Ti.prototype = Object.create(Xe.prototype), Ti.prototype.constructor = Ti, Ti.prototype.isCubeTexture = !0, Object.defineProperty(Ti.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), Si.prototype = Object.create(Xe.prototype), Si.prototype.constructor = Si, Si.prototype.isDataTexture3D = !0;
            var Ei = new Xe,
                Ai = new Si,
                Li = new Ti;

            function Pi() {
                this.seq = [], this.map = {}
            }
            var Oi = [],
                Ci = [],
                Ri = new Float32Array(16),
                Ii = new Float32Array(9),
                Di = new Float32Array(4);

            function ji(t, e, n) {
                var i = t[0];
                if (i <= 0 || i > 0) return t;
                var r = e * n,
                    a = Oi[r];
                if (void 0 === a && (a = new Float32Array(r), Oi[r] = a), 0 !== e) {
                    i.toArray(a, 0);
                    for (var o = 1, s = 0; o !== e; ++o) s += n, t[o].toArray(a, s)
                }
                return a
            }

            function Ni(t, e) {
                if (t.length !== e.length) return !1;
                for (var n = 0, i = t.length; n < i; n++)
                    if (t[n] !== e[n]) return !1;
                return !0
            }

            function ki(t, e) {
                for (var n = 0, i = e.length; n < i; n++) t[n] = e[n]
            }

            function zi(t, e) {
                var n = Ci[e];
                void 0 === n && (n = new Int32Array(e), Ci[e] = n);
                for (var i = 0; i !== e; ++i) n[i] = t.allocTextureUnit();
                return n
            }

            function Bi(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
            }

            function Ui(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
            }

            function Gi(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                else {
                    if (Ni(n, e)) return;
                    t.uniform2fv(this.addr, e), ki(n, e)
                }
            }

            function Fi(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                else {
                    if (Ni(n, e)) return;
                    t.uniform3fv(this.addr, e), ki(n, e)
                }
            }

            function Hi(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                else {
                    if (Ni(n, e)) return;
                    t.uniform4fv(this.addr, e), ki(n, e)
                }
            }

            function Vi(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Ni(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), ki(n, e)
                } else {
                    if (Ni(n, i)) return;
                    Di.set(i), t.uniformMatrix2fv(this.addr, !1, Di), ki(n, i)
                }
            }

            function Wi(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Ni(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), ki(n, e)
                } else {
                    if (Ni(n, i)) return;
                    Ii.set(i), t.uniformMatrix3fv(this.addr, !1, Ii), ki(n, i)
                }
            }

            function qi(t, e) {
                var n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Ni(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), ki(n, e)
                } else {
                    if (Ni(n, i)) return;
                    Ri.set(i), t.uniformMatrix4fv(this.addr, !1, Ri), ki(n, i)
                }
            }

            function Xi(t, e, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(e || Ei, r)
            }

            function Yi(t, e, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Ai, r)
            }

            function Zi(t, e, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || Li, r)
            }

            function Ji(t, e) {
                var n = this.cache;
                Ni(n, e) || (t.uniform2iv(this.addr, e), ki(n, e))
            }

            function Ki(t, e) {
                var n = this.cache;
                Ni(n, e) || (t.uniform3iv(this.addr, e), ki(n, e))
            }

            function Qi(t, e) {
                var n = this.cache;
                Ni(n, e) || (t.uniform4iv(this.addr, e), ki(n, e))
            }

            function $i(t, e) {
                var n = this.cache;
                Ni(n, e) || (t.uniform1fv(this.addr, e), ki(n, e))
            }

            function tr(t, e) {
                var n = this.cache;
                Ni(n, e) || (t.uniform1iv(this.addr, e), ki(n, e))
            }

            function er(t, e) {
                var n = this.cache,
                    i = ji(e, this.size, 2);
                Ni(n, i) || (t.uniform2fv(this.addr, i), this.updateCache(i))
            }

            function nr(t, e) {
                var n = this.cache,
                    i = ji(e, this.size, 3);
                Ni(n, i) || (t.uniform3fv(this.addr, i), this.updateCache(i))
            }

            function ir(t, e) {
                var n = this.cache,
                    i = ji(e, this.size, 4);
                Ni(n, i) || (t.uniform4fv(this.addr, i), this.updateCache(i))
            }

            function rr(t, e) {
                var n = this.cache,
                    i = ji(e, this.size, 4);
                Ni(n, i) || (t.uniformMatrix2fv(this.addr, !1, i), this.updateCache(i))
            }

            function ar(t, e) {
                var n = this.cache,
                    i = ji(e, this.size, 9);
                Ni(n, i) || (t.uniformMatrix3fv(this.addr, !1, i), this.updateCache(i))
            }

            function or(t, e) {
                var n = this.cache,
                    i = ji(e, this.size, 16);
                Ni(n, i) || (t.uniformMatrix4fv(this.addr, !1, i), this.updateCache(i))
            }

            function sr(t, e, n) {
                var i = this.cache,
                    r = e.length,
                    a = zi(n, r);
                !1 === Ni(i, a) && (t.uniform1iv(this.addr, a), ki(i, a));
                for (var o = 0; o !== r; ++o) n.setTexture2D(e[o] || Ei, a[o])
            }

            function cr(t, e, n) {
                var i = this.cache,
                    r = e.length,
                    a = zi(n, r);
                !1 === Ni(i, a) && (t.uniform1iv(this.addr, a), ki(i, a));
                for (var o = 0; o !== r; ++o) n.setTextureCube(e[o] || Li, a[o])
            }

            function ur(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Bi;
                        case 35664:
                            return Gi;
                        case 35665:
                            return Fi;
                        case 35666:
                            return Hi;
                        case 35674:
                            return Vi;
                        case 35675:
                            return Wi;
                        case 35676:
                            return qi;
                        case 35678:
                        case 36198:
                            return Xi;
                        case 35679:
                            return Yi;
                        case 35680:
                            return Zi;
                        case 5124:
                        case 35670:
                            return Ui;
                        case 35667:
                        case 35671:
                            return Ji;
                        case 35668:
                        case 35672:
                            return Ki;
                        case 35669:
                        case 35673:
                            return Qi
                    }
                }(e.type)
            }

            function lr(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return $i;
                        case 35664:
                            return er;
                        case 35665:
                            return nr;
                        case 35666:
                            return ir;
                        case 35674:
                            return rr;
                        case 35675:
                            return ar;
                        case 35676:
                            return or;
                        case 35678:
                            return sr;
                        case 35680:
                            return cr;
                        case 5124:
                        case 35670:
                            return tr;
                        case 35667:
                        case 35671:
                            return Ji;
                        case 35668:
                        case 35672:
                            return Ki;
                        case 35669:
                        case 35673:
                            return Qi
                    }
                }(e.type)
            }

            function hr(t) {
                this.id = t, Pi.call(this)
            }
            lr.prototype.updateCache = function(t) {
                var e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), ki(e, t)
            }, hr.prototype.setValue = function(t, e, n) {
                for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) {
                    var o = i[r];
                    o.setValue(t, e[o.id], n)
                }
            };
            var dr = /([\w\d_]+)(\])?(\[|\.)?/g;

            function pr(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function fr(t, e, n) {
                var i = t.name,
                    r = i.length;
                for (dr.lastIndex = 0;;) {
                    var a = dr.exec(i),
                        o = dr.lastIndex,
                        s = a[1],
                        c = "]" === a[2],
                        u = a[3];
                    if (c && (s |= 0), void 0 === u || "[" === u && o + 2 === r) {
                        pr(n, void 0 === u ? new ur(s, t, e) : new lr(s, t, e));
                        break
                    }
                    var l = n.map[s];
                    void 0 === l && pr(n, l = new hr(s)), n = l
                }
            }

            function mr(t, e, n) {
                Pi.call(this), this.renderer = n;
                for (var i = t.getProgramParameter(e, 35718), r = 0; r < i; ++r) {
                    var a = t.getActiveUniform(e, r);
                    fr(a, t.getUniformLocation(e, a.name), this)
                }
            }

            function vr(t, e, n) {
                var i = t.createShader(e);
                return t.shaderSource(i, n), t.compileShader(i), !1 === t.getShaderParameter(i, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(i), function(t) {
                    for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                    return e.join("\n")
                }(n)), i
            }
            mr.prototype.setValue = function(t, e, n) {
                var i = this.map[e];
                void 0 !== i && i.setValue(t, n, this.renderer)
            }, mr.prototype.setOptional = function(t, e, n) {
                var i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }, mr.upload = function(t, e, n, i) {
                for (var r = 0, a = e.length; r !== a; ++r) {
                    var o = e[r],
                        s = n[o.id];
                    !1 !== s.needsUpdate && o.setValue(t, s.value, i)
                }
            }, mr.seqWithValue = function(t, e) {
                for (var n = [], i = 0, r = t.length; i !== r; ++i) {
                    var a = t[i];
                    a.id in e && n.push(a)
                }
                return n
            };
            var gr = 0;

            function yr(t) {
                switch (t) {
                    case Me:
                        return ["Linear", "( value )"];
                    case Te:
                        return ["sRGB", "( value )"];
                    case Ee:
                        return ["RGBE", "( value )"];
                    case Ae:
                        return ["RGBM", "( value, 7.0 )"];
                    case Le:
                        return ["RGBM", "( value, 16.0 )"];
                    case Pe:
                        return ["RGBD", "( value, 256.0 )"];
                    case Se:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                }
            }

            function xr(t, e) {
                var n = yr(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function br(t, e) {
                var n;
                switch (e) {
                    case ct:
                        n = "Linear";
                        break;
                    case ut:
                        n = "Reinhard";
                        break;
                    case lt:
                        n = "Uncharted2";
                        break;
                    case ht:
                        n = "OptimizedCineon";
                        break;
                    case dt:
                        n = "ACESFilmic";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + e)
                }
                return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function _r(t) {
                return "" !== t
            }

            function wr(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }

            function Mr(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }

            function Tr(t) {
                return t.replace(/^[ \t]*#include +<([\w\d.\/]+)>/gm, function(t, e) {
                    var n = rn[e];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                    return Tr(n)
                })
            }

            function Sr(t) {
                return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, n, i) {
                    for (var r = "", a = parseInt(e); a < parseInt(n); a++) r += i.replace(/\[ i \]/g, "[ " + a + " ]");
                    return r
                })
            }

            function Er(t, e, n, i, r, a, o) {
                var s = t.context,
                    c = i.defines,
                    u = r.vertexShader,
                    l = r.fragmentShader,
                    h = "SHADOWMAP_TYPE_BASIC";
                a.shadowMapType === b ? h = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === _ && (h = "SHADOWMAP_TYPE_PCF_SOFT");
                var d = "ENVMAP_TYPE_CUBE",
                    p = "ENVMAP_MODE_REFLECTION",
                    f = "ENVMAP_BLENDING_MULTIPLY";
                if (a.envMap) {
                    switch (i.envMap.mapping) {
                        case pt:
                        case ft:
                            d = "ENVMAP_TYPE_CUBE";
                            break;
                        case yt:
                        case xt:
                            d = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case mt:
                        case vt:
                            d = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case gt:
                            d = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (i.envMap.mapping) {
                        case ft:
                        case vt:
                            p = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (i.combine) {
                        case rt:
                            f = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case at:
                            f = "ENVMAP_BLENDING_MIX";
                            break;
                        case ot:
                            f = "ENVMAP_BLENDING_ADD"
                    }
                }
                var m, v, g, y, x, w = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    M = o.isWebGL2 ? "" : function(t, e, n) {
                        return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(_r).join("\n")
                    }(i.extensions, a, e),
                    T = function(t) {
                        var e = [];
                        for (var n in t) {
                            var i = t[n];
                            !1 !== i && e.push("#define " + n + " " + i)
                        }
                        return e.join("\n")
                    }(c),
                    S = s.createProgram();
                if (i.isRawShaderMaterial ? ((m = [T].filter(_r).join("\n")).length > 0 && (m += "\n"), (v = [M, T].filter(_r).join("\n")).length > 0 && (v += "\n")) : (m = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, T, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + w, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + h : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(_r).join("\n"), v = [M, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, T, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + w, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + h : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== st ? "#define TONE_MAPPING" : "", a.toneMapping !== st ? rn.tonemapping_pars_fragment : "", a.toneMapping !== st ? br("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? rn.encodings_pars_fragment : "", a.mapEncoding ? xr("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? xr("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? xr("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? xr("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? (g = "linearToOutputTexel", y = a.outputEncoding, x = yr(y), "vec4 " + g + "( vec4 value ) { return LinearTo" + x[0] + x[1] + "; }") : "", a.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(_r).join("\n")), u = Mr(u = wr(u = Tr(u), a), a), l = Mr(l = wr(l = Tr(l), a), a), u = Sr(u), l = Sr(l), o.isWebGL2 && !i.isRawShaderMaterial) {
                    var E = !1,
                        A = /^\s*#version\s+300\s+es\s*\n/;
                    i.isShaderMaterial && null !== u.match(A) && null !== l.match(A) && (E = !0, u = u.replace(A, ""), l = l.replace(A, "")), m = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m, v = ["#version 300 es\n", "#define varying in", E ? "" : "out highp vec4 pc_fragColor;", E ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v
                }
                var L = v + l,
                    P = vr(s, 35633, m + u),
                    O = vr(s, 35632, L);
                s.attachShader(S, P), s.attachShader(S, O), void 0 !== i.index0AttributeName ? s.bindAttribLocation(S, 0, i.index0AttributeName) : !0 === a.morphTargets && s.bindAttribLocation(S, 0, "position"), s.linkProgram(S);
                var C, R, I = s.getProgramInfoLog(S).trim(),
                    D = s.getShaderInfoLog(P).trim(),
                    j = s.getShaderInfoLog(O).trim(),
                    N = !0,
                    k = !0;
                return !1 === s.getProgramParameter(S, 35714) ? (N = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(S, 35715), "gl.getProgramInfoLog", I, D, j)) : "" !== I ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", I) : "" !== D && "" !== j || (k = !1), k && (this.diagnostics = {
                    runnable: N,
                    material: i,
                    programLog: I,
                    vertexShader: {
                        log: D,
                        prefix: m
                    },
                    fragmentShader: {
                        log: j,
                        prefix: v
                    }
                }), s.deleteShader(P), s.deleteShader(O), this.getUniforms = function() {
                    return void 0 === C && (C = new mr(s, S, t)), C
                }, this.getAttributes = function() {
                    return void 0 === R && (R = function(t, e) {
                        for (var n = {}, i = t.getProgramParameter(e, 35721), r = 0; r < i; r++) {
                            var a = t.getActiveAttrib(e, r).name;
                            n[a] = t.getAttribLocation(e, a)
                        }
                        return n
                    }(s, S)), R
                }, this.destroy = function() {
                    s.deleteProgram(S), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.name = r.name, this.id = gr++, this.code = n, this.usedTimes = 1, this.program = S, this.vertexShader = P, this.fragmentShader = O, this
            }

            function Ar(t, e, n) {
                var i = [],
                    r = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function o(t, e) {
                    var n;
                    return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = Me, n === Me && e && (n = Se), n
                }
                this.getParameters = function(e, i, a, s, c, u, l) {
                    var h = r[e.type],
                        d = l.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (n.floatVertexTextures) return 1024;
                            var i = n.maxVertexUniforms,
                                r = Math.floor((i - 20) / 4),
                                a = Math.min(r, e.length);
                            return a < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + a + "."), 0) : a
                        }(l) : 0,
                        p = n.precision;
                    null !== e.precision && (p = n.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", p, "instead.");
                    var f = t.getRenderTarget();
                    return {
                        shaderID: h,
                        precision: p,
                        supportsVertexTextures: n.vertexTextures,
                        outputEncoding: o(f ? f.texture : null, t.gammaOutput),
                        map: !!e.map,
                        mapEncoding: o(e.map, t.gammaInput),
                        matcap: !!e.matcap,
                        matcapEncoding: o(e.matcap, t.gammaInput),
                        envMap: !!e.envMap,
                        envMapMode: e.envMap && e.envMap.mapping,
                        envMapEncoding: o(e.envMap, t.gammaInput),
                        envMapCubeUV: !!e.envMap && (e.envMap.mapping === yt || e.envMap.mapping === xt),
                        lightMap: !!e.lightMap,
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: o(e.emissiveMap, t.gammaInput),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        objectSpaceNormalMap: e.normalMapType === Ie,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        combine: e.combine,
                        vertexColors: e.vertexColors,
                        fog: !!s,
                        useFog: e.fog,
                        fogExp: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                        skinning: e.skinning && d > 0,
                        maxBones: d,
                        useVertexTexture: n.floatVertexTextures,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: i.directional.length,
                        numPointLights: i.point.length,
                        numSpotLights: i.spot.length,
                        numRectAreaLights: i.rectArea.length,
                        numHemiLights: i.hemi.length,
                        numClippingPlanes: c,
                        numClipIntersection: u,
                        dithering: e.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && a.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: t.toneMapping,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === T,
                        flipSided: e.side === M,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }, this.getProgramCode = function(e, n) {
                    var i = [];
                    if (n.shaderID ? i.push(n.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) i.push(r), i.push(e.defines[r]);
                    for (var o = 0; o < a.length; o++) i.push(n[a[o]]);
                    return i.push(e.onBeforeCompile.toString()), i.push(t.gammaOutput), i.push(t.gammaFactor), i.join()
                }, this.acquireProgram = function(r, a, o, s) {
                    for (var c, u = 0, l = i.length; u < l; u++) {
                        var h = i[u];
                        if (h.code === s) {
                            ++(c = h).usedTimes;
                            break
                        }
                    }
                    return void 0 === c && (c = new Er(t, e, s, r, a, o, n), i.push(c)), c
                }, this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = i.indexOf(t);
                        i[e] = i[i.length - 1], i.pop(), t.destroy()
                    }
                }, this.programs = i
            }

            function Lr() {
                var t = new WeakMap;
                return {
                    get: function(e) {
                        var n = t.get(e);
                        return void 0 === n && (n = {}, t.set(e, n)), n
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, n, i) {
                        t.get(e)[n] = i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }

            function Pr(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Or(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Cr() {
                var t = [],
                    e = 0,
                    n = [],
                    i = [];

                function r(n, i, r, a, o, s) {
                    var c = t[e];
                    return void 0 === c ? (c = {
                        id: n.id,
                        object: n,
                        geometry: i,
                        material: r,
                        program: r.program,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: o,
                        group: s
                    }, t[e] = c) : (c.id = n.id, c.object = n, c.geometry = i, c.material = r, c.program = r.program, c.groupOrder = a, c.renderOrder = n.renderOrder, c.z = o, c.group = s), e++, c
                }
                return {
                    opaque: n,
                    transparent: i,
                    init: function() {
                        e = 0, n.length = 0, i.length = 0
                    },
                    push: function(t, e, a, o, s, c) {
                        var u = r(t, e, a, o, s, c);
                        (!0 === a.transparent ? i : n).push(u)
                    },
                    unshift: function(t, e, a, o, s, c) {
                        var u = r(t, e, a, o, s, c);
                        (!0 === a.transparent ? i : n).unshift(u)
                    },
                    sort: function() {
                        n.length > 1 && n.sort(Pr), i.length > 1 && i.sort(Or)
                    }
                }
            }

            function Rr() {
                var t = {};

                function e(n) {
                    var i = n.target;
                    i.removeEventListener("dispose", e), delete t[i.id]
                }
                return {
                    get: function(n, i) {
                        var r, a = t[n.id];
                        return void 0 === a ? (r = new Cr, t[n.id] = {}, t[n.id][i.id] = r, n.addEventListener("dispose", e)) : void 0 === (r = a[i.id]) && (r = new Cr, a[i.id] = r), r
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }

            function Ir() {
                var t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        var n;
                        switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new ze,
                                    color: new hn,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new je
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new ze,
                                    direction: new ze,
                                    color: new hn,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new je
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new ze,
                                    color: new hn,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new je,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new ze,
                                    skyColor: new hn,
                                    groundColor: new hn
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new hn,
                                    position: new ze,
                                    halfWidth: new ze,
                                    halfHeight: new ze
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            }
            var Dr = 0;

            function jr() {
                var t = new Ir,
                    e = {
                        id: Dr++,
                        hash: {
                            stateID: -1,
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            shadowsLength: -1
                        },
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    n = new ze,
                    i = new Ne,
                    r = new Ne;
                return {
                    setup: function(a, o, s) {
                        for (var c = 0, u = 0, l = 0, h = 0, d = 0, p = 0, f = 0, m = 0, v = s.matrixWorldInverse, g = 0, y = a.length; g < y; g++) {
                            var x = a[g],
                                b = x.color,
                                _ = x.intensity,
                                w = x.distance,
                                M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                            if (x.isAmbientLight) c += b.r * _, u += b.g * _, l += b.b * _;
                            else if (x.isDirectionalLight) {
                                if ((S = t.get(x)).color.copy(x.color).multiplyScalar(x.intensity), S.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(v), S.shadow = x.castShadow, x.castShadow) {
                                    var T = x.shadow;
                                    S.shadowBias = T.bias, S.shadowRadius = T.radius, S.shadowMapSize = T.mapSize
                                }
                                e.directionalShadowMap[h] = M, e.directionalShadowMatrix[h] = x.shadow.matrix, e.directional[h] = S, h++
                            } else if (x.isSpotLight)(S = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(v), S.color.copy(b).multiplyScalar(_), S.distance = w, S.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(v), S.coneCos = Math.cos(x.angle), S.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), S.decay = x.decay, S.shadow = x.castShadow, x.castShadow && (T = x.shadow, S.shadowBias = T.bias, S.shadowRadius = T.radius, S.shadowMapSize = T.mapSize), e.spotShadowMap[p] = M, e.spotShadowMatrix[p] = x.shadow.matrix, e.spot[p] = S, p++;
                            else if (x.isRectAreaLight)(S = t.get(x)).color.copy(b).multiplyScalar(_), S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(v), r.identity(), i.copy(x.matrixWorld), i.premultiply(v), r.extractRotation(i), S.halfWidth.set(.5 * x.width, 0, 0), S.halfHeight.set(0, .5 * x.height, 0), S.halfWidth.applyMatrix4(r), S.halfHeight.applyMatrix4(r), e.rectArea[f] = S, f++;
                            else if (x.isPointLight)(S = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(v), S.color.copy(x.color).multiplyScalar(x.intensity), S.distance = x.distance, S.decay = x.decay, S.shadow = x.castShadow, x.castShadow && (T = x.shadow, S.shadowBias = T.bias, S.shadowRadius = T.radius, S.shadowMapSize = T.mapSize, S.shadowCameraNear = T.camera.near, S.shadowCameraFar = T.camera.far), e.pointShadowMap[d] = M, e.pointShadowMatrix[d] = x.shadow.matrix, e.point[d] = S, d++;
                            else if (x.isHemisphereLight) {
                                var S;
                                (S = t.get(x)).direction.setFromMatrixPosition(x.matrixWorld), S.direction.transformDirection(v), S.direction.normalize(), S.skyColor.copy(x.color).multiplyScalar(_), S.groundColor.copy(x.groundColor).multiplyScalar(_), e.hemi[m] = S, m++
                            }
                        }
                        e.ambient[0] = c, e.ambient[1] = u, e.ambient[2] = l, e.directional.length = h, e.spot.length = p, e.rectArea.length = f, e.point.length = d, e.hemi.length = m, e.hash.stateID = e.id, e.hash.directionalLength = h, e.hash.pointLength = d, e.hash.spotLength = p, e.hash.rectAreaLength = f, e.hash.hemiLength = m, e.hash.shadowsLength = o.length
                    },
                    state: e
                }
            }

            function Nr() {
                var t = new jr,
                    e = [],
                    n = [];
                return {
                    init: function() {
                        e.length = 0, n.length = 0
                    },
                    state: {
                        lightsArray: e,
                        shadowsArray: n,
                        lights: t
                    },
                    setupLights: function(i) {
                        t.setup(e, n, i)
                    },
                    pushLight: function(t) {
                        e.push(t)
                    },
                    pushShadow: function(t) {
                        n.push(t)
                    }
                }
            }

            function kr() {
                var t = {};

                function e(n) {
                    var i = n.target;
                    i.removeEventListener("dispose", e), delete t[i.id]
                }
                return {
                    get: function(n, i) {
                        var r;
                        return void 0 === t[n.id] ? (r = new Nr, t[n.id] = {}, t[n.id][i.id] = r, n.addEventListener("dispose", e)) : void 0 === t[n.id][i.id] ? (r = new Nr, t[n.id][i.id] = r) : r = t[n.id][i.id], r
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }

            function zr(t) {
                si.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Oe, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function Br(t) {
                si.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new ze, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function Ur(t, e, n) {
                for (var i = new nn, r = new Ne, a = new je, o = new je(n, n), s = new ze, c = new ze, u = 1, l = 2, h = 1 + (u | l), d = new Array(h), p = new Array(h), f = {}, m = {
                        0: M,
                        1: w,
                        2: T
                    }, v = [new ze(1, 0, 0), new ze(-1, 0, 0), new ze(0, 0, 1), new ze(0, 0, -1), new ze(0, 1, 0), new ze(0, -1, 0)], g = [new ze(0, 1, 0), new ze(0, 1, 0), new ze(0, 1, 0), new ze(0, 1, 0), new ze(0, 0, 1), new ze(0, 0, -1)], y = [new Ye, new Ye, new Ye, new Ye, new Ye, new Ye], x = 0; x !== h; ++x) {
                    var _ = 0 != (x & u),
                        S = 0 != (x & l),
                        E = new zr({
                            depthPacking: Ce,
                            morphTargets: _,
                            skinning: S
                        });
                    d[x] = E;
                    var A = new Br({
                        morphTargets: _,
                        skinning: S
                    });
                    p[x] = A
                }
                var P = this;

                function O(e, n, i, r, a, o) {
                    var s = e.geometry,
                        c = null,
                        h = d,
                        v = e.customDepthMaterial;
                    if (i && (h = p, v = e.customDistanceMaterial), v) c = v;
                    else {
                        var g = !1;
                        n.morphTargets && (s && s.isBufferGeometry ? g = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (g = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var y = e.isSkinnedMesh && n.skinning,
                            x = 0;
                        g && (x |= u), y && (x |= l), c = h[x]
                    }
                    if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                        var b = c.uuid,
                            _ = n.uuid,
                            w = f[b];
                        void 0 === w && (w = {}, f[b] = w);
                        var M = w[_];
                        void 0 === M && (M = c.clone(), w[_] = M), c = M
                    }
                    return c.visible = n.visible, c.wireframe = n.wireframe, c.side = null != n.shadowSide ? n.shadowSide : m[n.side], c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, i && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), c.nearDistance = a, c.farDistance = o), c
                }

                function C(n, r, a, o) {
                    if (!1 !== n.visible) {
                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                            var s = e.update(n),
                                u = n.material;
                            if (Array.isArray(u))
                                for (var l = s.groups, h = 0, d = l.length; h < d; h++) {
                                    var p = l[h],
                                        f = u[p.materialIndex];
                                    if (f && f.visible) {
                                        var m = O(n, f, o, c, a.near, a.far);
                                        t.renderBufferDirect(a, null, s, m, n, p)
                                    }
                                } else if (u.visible) {
                                    m = O(n, u, o, c, a.near, a.far);
                                    t.renderBufferDirect(a, null, s, m, n, null)
                                }
                        }
                        for (var v = n.children, g = 0, y = v.length; g < y; g++) C(v[g], r, a, o)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = b, this.render = function(e, n, u) {
                    if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== e.length) {
                        var l, h = t.state;
                        h.setBlending(L), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                        for (var d = 0, p = e.length; d < p; d++) {
                            var f = e[d],
                                m = f.shadow,
                                x = f && f.isPointLight;
                            if (void 0 !== m) {
                                var b = m.camera;
                                if (a.copy(m.mapSize), a.min(o), x) {
                                    var _ = a.x,
                                        w = a.y;
                                    y[0].set(2 * _, w, _, w), y[1].set(0, w, _, w), y[2].set(3 * _, w, _, w), y[3].set(_, w, _, w), y[4].set(3 * _, 0, _, w), y[5].set(_, 0, _, w), a.x *= 4, a.y *= 2
                                }
                                if (null === m.map) {
                                    var M = {
                                        minFilter: Mt,
                                        magFilter: Mt,
                                        format: Ht
                                    };
                                    m.map = new Ze(a.x, a.y, M), m.map.texture.name = f.name + ".shadowMap", b.updateProjectionMatrix()
                                }
                                m.isSpotLightShadow && m.update(f);
                                var T = m.map,
                                    S = m.matrix;
                                c.setFromMatrixPosition(f.matrixWorld), b.position.copy(c), x ? (l = 6, S.makeTranslation(-c.x, -c.y, -c.z)) : (l = 1, s.setFromMatrixPosition(f.target.matrixWorld), b.lookAt(s), b.updateMatrixWorld(), S.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), S.multiply(b.projectionMatrix), S.multiply(b.matrixWorldInverse)), t.setRenderTarget(T), t.clear();
                                for (var E = 0; E < l; E++) {
                                    if (x) {
                                        s.copy(b.position), s.add(v[E]), b.up.copy(g[E]), b.lookAt(s), b.updateMatrixWorld();
                                        var A = y[E];
                                        h.viewport(A)
                                    }
                                    r.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), i.setFromMatrix(r), C(n, u, b, x)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", f, "has no shadow.")
                        }
                        P.needsUpdate = !1
                    }
                }
            }

            function Gr(t, e, n, i) {
                var r = new function() {
                        var e = !1,
                            n = new Ye,
                            i = null,
                            r = new Ye(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                i === n || e || (t.colorMask(n, n, n, n), i = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, i, a, o, s) {
                                !0 === s && (e *= o, i *= o, a *= o), n.set(e, i, a, o), !1 === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n))
                            },
                            reset: function() {
                                e = !1, i = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    a = new function() {
                        var e = !1,
                            n = null,
                            i = null,
                            r = null;
                        return {
                            setTest: function(t) {
                                t ? at(2929) : ot(2929)
                            },
                            setMask: function(i) {
                                n === i || e || (t.depthMask(i), n = i)
                            },
                            setFunc: function(e) {
                                if (i !== e) {
                                    if (e) switch (e) {
                                        case J:
                                            t.depthFunc(512);
                                            break;
                                        case K:
                                            t.depthFunc(519);
                                            break;
                                        case Q:
                                            t.depthFunc(513);
                                            break;
                                        case $:
                                            t.depthFunc(515);
                                            break;
                                        case tt:
                                            t.depthFunc(514);
                                            break;
                                        case et:
                                            t.depthFunc(518);
                                            break;
                                        case nt:
                                            t.depthFunc(516);
                                            break;
                                        case it:
                                            t.depthFunc(517);
                                            break;
                                        default:
                                            t.depthFunc(515)
                                    } else t.depthFunc(515);
                                    i = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                r !== e && (t.clearDepth(e), r = e)
                            },
                            reset: function() {
                                e = !1, n = null, i = null, r = null
                            }
                        }
                    },
                    o = new function() {
                        var e = !1,
                            n = null,
                            i = null,
                            r = null,
                            a = null,
                            o = null,
                            s = null,
                            c = null,
                            u = null;
                        return {
                            setTest: function(t) {
                                t ? at(2960) : ot(2960)
                            },
                            setMask: function(i) {
                                n === i || e || (t.stencilMask(i), n = i)
                            },
                            setFunc: function(e, n, o) {
                                i === e && r === n && a === o || (t.stencilFunc(e, n, o), i = e, r = n, a = o)
                            },
                            setOp: function(e, n, i) {
                                o === e && s === n && c === i || (t.stencilOp(e, n, i), o = e, s = n, c = i)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                u !== e && (t.clearStencil(e), u = e)
                            },
                            reset: function() {
                                e = !1, n = null, i = null, r = null, a = null, o = null, s = null, c = null, u = null
                            }
                        }
                    },
                    s = t.getParameter(34921),
                    c = new Uint8Array(s),
                    u = new Uint8Array(s),
                    l = new Uint8Array(s),
                    h = {},
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    v = null,
                    b = null,
                    _ = null,
                    w = null,
                    S = null,
                    E = null,
                    A = !1,
                    j = null,
                    N = null,
                    k = null,
                    z = null,
                    B = null,
                    U = t.getParameter(35661),
                    G = !1,
                    F = 0,
                    H = t.getParameter(7938); - 1 !== H.indexOf("WebGL") ? (F = parseFloat(/^WebGL\ ([0-9])/.exec(H)[1]), G = F >= 1) : -1 !== H.indexOf("OpenGL ES") && (F = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(H)[1]), G = F >= 2);
                var V = null,
                    W = {},
                    q = new Ye,
                    X = new Ye;

                function Y(e, n, i) {
                    var r = new Uint8Array(4),
                        a = t.createTexture();
                    t.bindTexture(e, a), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (var o = 0; o < i; o++) t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return a
                }
                var Z = {};

                function rt(n, r) {
                    (c[n] = 1, 0 === u[n] && (t.enableVertexAttribArray(n), u[n] = 1), l[n] !== r) && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), l[n] = r)
                }

                function at(e) {
                    !0 !== h[e] && (t.enable(e), h[e] = !0)
                }

                function ot(e) {
                    !1 !== h[e] && (t.disable(e), h[e] = !1)
                }

                function st(e, i, r, a, o, s, c, u) {
                    if (e !== L) {
                        if (f || (at(3042), f = !0), e === I) o = o || i, s = s || r, c = c || a, i === v && o === w || (t.blendEquationSeparate(n.convert(i), n.convert(o)), v = i, w = o), r === b && a === _ && s === S && c === E || (t.blendFuncSeparate(n.convert(r), n.convert(a), n.convert(s), n.convert(c)), b = r, _ = a, S = s, E = c), m = e, A = null;
                        else if (e !== m || u !== A) {
                            if (v === D && w === D || (t.blendEquation(32774), v = D, w = D), u) switch (e) {
                                case P:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case O:
                                    t.blendFunc(1, 1);
                                    break;
                                case C:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case R:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case P:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case O:
                                    t.blendFunc(770, 1);
                                    break;
                                case C:
                                    t.blendFunc(0, 769);
                                    break;
                                case R:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            b = null, _ = null, S = null, E = null, m = e, A = u
                        }
                    } else f && (ot(3042), f = !1)
                }

                function ct(e) {
                    j !== e && (e ? t.frontFace(2304) : t.frontFace(2305), j = e)
                }

                function ut(e) {
                    e !== g ? (at(2884), e !== N && (e === y ? t.cullFace(1029) : e === x ? t.cullFace(1028) : t.cullFace(1032))) : ot(2884), N = e
                }

                function lt(e, n, i) {
                    e ? (at(32823), z === n && B === i || (t.polygonOffset(n, i), z = n, B = i)) : ot(32823)
                }

                function ht(e) {
                    void 0 === e && (e = 33984 + U - 1), V !== e && (t.activeTexture(e), V = e)
                }
                return Z[3553] = Y(3553, 3553, 1), Z[34067] = Y(34067, 34069, 6), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), at(2929), a.setFunc($), ct(!1), ut(y), at(2884), st(L), {
                    buffers: {
                        color: r,
                        depth: a,
                        stencil: o
                    },
                    initAttributes: function() {
                        for (var t = 0, e = c.length; t < e; t++) c[t] = 0
                    },
                    enableAttribute: function(t) {
                        rt(t, 0)
                    },
                    enableAttributeAndDivisor: rt,
                    disableUnusedAttributes: function() {
                        for (var e = 0, n = u.length; e !== n; ++e) u[e] !== c[e] && (t.disableVertexAttribArray(e), u[e] = 0)
                    },
                    enable: at,
                    disable: ot,
                    getCompressedTextureFormats: function() {
                        if (null === d && (d = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                            for (var n = t.getParameter(34467), i = 0; i < n.length; i++) d.push(n[i]);
                        return d
                    },
                    useProgram: function(e) {
                        return p !== e && (t.useProgram(e), p = e, !0)
                    },
                    setBlending: st,
                    setMaterial: function(t, e) {
                        t.side === T ? ot(2884) : at(2884);
                        var n = t.side === M;
                        e && (n = !n), ct(n), t.blending === P && !1 === t.transparent ? st(L) : st(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t.depthFunc), a.setTest(t.depthTest), a.setMask(t.depthWrite), r.setMask(t.colorWrite), lt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                    },
                    setFlipSided: ct,
                    setCullFace: ut,
                    setLineWidth: function(e) {
                        e !== k && (G && t.lineWidth(e), k = e)
                    },
                    setPolygonOffset: lt,
                    setScissorTest: function(t) {
                        t ? at(3089) : ot(3089)
                    },
                    activeTexture: ht,
                    bindTexture: function(e, n) {
                        null === V && ht();
                        var i = W[V];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, W[V] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || Z[e]), i.type = e, i.texture = n)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(e) {
                        !1 === q.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), q.copy(e))
                    },
                    viewport: function(e) {
                        !1 === X.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), X.copy(e))
                    },
                    reset: function() {
                        for (var e = 0; e < u.length; e++) 1 === u[e] && (t.disableVertexAttribArray(e), u[e] = 0);
                        h = {}, d = null, V = null, W = {}, p = null, m = null, j = null, N = null, r.reset(), a.reset(), o.reset()
                    }
                }
            }

            function Fr(t, e, n, i, r, a, o) {
                var s, c = {};

                function u(t, e, n, i) {
                    var r = 1;
                    if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                        if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap) {
                            void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"));
                            var a = n ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : s,
                                o = e ? De.floorPowerOfTwo : Math.floor;
                            return a.width = o(r * t.width), a.height = o(r * t.height), a.getContext("2d").drawImage(t, 0, 0, a.width, a.height), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a.width + "x" + a.height + ")."), a
                        }
                        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                    }
                    return t
                }

                function l(t) {
                    return De.isPowerOfTwo(t.width) && De.isPowerOfTwo(t.height)
                }

                function h(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== Mt && t.minFilter !== Et
                }

                function d(e, n, r, a) {
                    t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
                }

                function p(t, n) {
                    if (!r.isWebGL2) return t;
                    var i = t;
                    return 6403 === t && (5126 === n && (i = 33326), 5131 === n && (i = 33325), 5121 === n && (i = 33321)), 6407 === t && (5126 === n && (i = 34837), 5131 === n && (i = 34843), 5121 === n && (i = 32849)), 6408 === t && (5126 === n && (i = 34836), 5131 === n && (i = 34842), 5121 === n && (i = 32856)), 33325 === i || 33326 === i || 34842 === i || 34836 === i ? e.get("EXT_color_buffer_float") : 34843 !== i && 34837 !== i || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), i
                }

                function f(t) {
                    return t === Mt || t === Tt || t === St ? 9728 : 9729
                }

                function m(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", m),
                        function(e) {
                            var n = i.get(e);
                            if (e.image && n.__image__webglTextureCube) t.deleteTexture(n.__image__webglTextureCube);
                            else {
                                if (void 0 === n.__webglInit) return;
                                t.deleteTexture(n.__webglTexture)
                            }
                            i.remove(e)
                        }(n), n.isVideoTexture && delete c[n.id], o.memory.textures--
                }

                function v(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", v),
                        function(e) {
                            var n = i.get(e),
                                r = i.get(e.texture);
                            if (!e) return;
                            void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLRenderTargetCube)
                                for (var a = 0; a < 6; a++) t.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                            else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                            i.remove(e.texture), i.remove(e)
                        }(n), o.memory.textures--
                }

                function g(t, e) {
                    var r = i.get(t);
                    if (t.isVideoTexture && function(t) {
                            var e = t.id,
                                n = o.render.frame;
                            c[e] !== n && (c[e] = n, t.update())
                        }(t), t.version > 0 && r.__version !== t.version) {
                        var a = t.image;
                        if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== a.complete) return void x(r, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                }

                function y(n, o, s) {
                    var c;
                    if (s ? (t.texParameteri(n, 10242, a.convert(o.wrapS)), t.texParameteri(n, 10243, a.convert(o.wrapT)), t.texParameteri(n, 10240, a.convert(o.magFilter)), t.texParameteri(n, 10241, a.convert(o.minFilter))) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), o.wrapS === _t && o.wrapT === _t || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, f(o.magFilter)), t.texParameteri(n, 10241, f(o.minFilter)), o.minFilter !== Mt && o.minFilter !== Et && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = e.get("EXT_texture_filter_anisotropic")) {
                        if (o.type === jt && null === e.get("OES_texture_float_linear")) return;
                        if (o.type === Nt && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                        (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                    }
                }

                function x(e, i, s) {
                    var c;
                    c = i.isDataTexture3D ? 32879 : 3553, void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), o.memory.textures++), n.activeTexture(33984 + s), n.bindTexture(c, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment);
                    var f = function(t) {
                            return !r.isWebGL2 && (t.wrapS !== _t || t.wrapT !== _t || t.minFilter !== Mt && t.minFilter !== Et)
                        }(i) && !1 === l(i.image),
                        v = u(i.image, f, !1, r.maxTextureSize),
                        g = l(v) || r.isWebGL2,
                        x = a.convert(i.format),
                        b = a.convert(i.type),
                        _ = p(x, b);
                    y(c, i, g);
                    var w, M = i.mipmaps;
                    if (i.isDepthTexture) {
                        if (_ = 6402, i.type === jt) {
                            if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            _ = 36012
                        } else r.isWebGL2 && (_ = 33189);
                        i.format === qt && 6402 === _ && i.type !== Rt && i.type !== Dt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Rt, b = a.convert(i.type)), i.format === Xt && (_ = 34041, i.type !== Ut && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Ut, b = a.convert(i.type))), n.texImage2D(3553, 0, _, v.width, v.height, 0, x, b, null)
                    } else if (i.isDataTexture)
                        if (M.length > 0 && g) {
                            for (var T = 0, S = M.length; T < S; T++) w = M[T], n.texImage2D(3553, T, _, w.width, w.height, 0, x, b, w.data);
                            i.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                        } else n.texImage2D(3553, 0, _, v.width, v.height, 0, x, b, v.data), e.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (T = 0, S = M.length; T < S; T++) w = M[T], i.format !== Ht && i.format !== Ft ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(3553, T, _, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, T, _, w.width, w.height, 0, x, b, w.data);
                        e.__maxMipLevel = M.length - 1
                    } else if (i.isDataTexture3D) n.texImage3D(32879, 0, _, v.width, v.height, v.depth, 0, x, b, v.data), e.__maxMipLevel = 0;
                    else if (M.length > 0 && g) {
                        for (T = 0, S = M.length; T < S; T++) w = M[T], n.texImage2D(3553, T, _, x, b, w);
                        i.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                    } else n.texImage2D(3553, 0, _, x, b, v), e.__maxMipLevel = 0;
                    h(i, g) && d(3553, i, v.width, v.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function b(e, r, o, s) {
                    var c = a.convert(r.texture.format),
                        u = a.convert(r.texture.type),
                        l = p(c, u);
                    n.texImage2D(s, 0, l, r.width, r.height, 0, c, u, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, s, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function _(e, n, i) {
                    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                        if (i) {
                            var r = M(n);
                            t.renderbufferStorageMultisample(36161, r, 33189, n.width, n.height)
                        } else t.renderbufferStorage(36161, 33189, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (i) {
                            r = M(n);
                            t.renderbufferStorageMultisample(36161, r, 34041, n.width, n.height)
                        } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        var o = p(a.convert(n.texture.format), a.convert(n.texture.type));
                        if (i) {
                            r = M(n);
                            t.renderbufferStorageMultisample(36161, r, o, n.width, n.height)
                        } else t.renderbufferStorage(36161, o, n.width, n.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function w(e) {
                    var n = i.get(e),
                        r = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, n) {
                            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), g(n.depthTexture, 0);
                            var r = i.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === qt) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (n.depthTexture.format !== Xt) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(n.__webglFramebuffer, e)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (var a = 0; a < 6; a++) t.bindFramebuffer(36160, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = t.createRenderbuffer(), _(n.__webglDepthbuffer[a], e)
                    } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), _(n.__webglDepthbuffer, e);
                    t.bindFramebuffer(36160, null)
                }

                function M(t) {
                    return r.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, t.samples) : 0
                }
                this.setTexture2D = g, this.setTexture3D = function(t, e) {
                    var r = i.get(t);
                    t.version > 0 && r.__version !== t.version ? x(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = function(e, s) {
                    var c = i.get(e);
                    if (6 === e.image.length)
                        if (e.version > 0 && c.__version !== e.version) {
                            c.__image__webglTextureCube || (e.addEventListener("dispose", m), c.__image__webglTextureCube = t.createTexture(), o.memory.textures++), n.activeTexture(33984 + s), n.bindTexture(34067, c.__image__webglTextureCube), t.pixelStorei(37440, e.flipY);
                            for (var f = e && e.isCompressedTexture, v = e.image[0] && e.image[0].isDataTexture, g = [], x = 0; x < 6; x++) g[x] = f || v ? v ? e.image[x].image : e.image[x] : u(e.image[x], !1, !0, r.maxCubemapSize);
                            var b = g[0],
                                _ = l(b) || r.isWebGL2,
                                w = a.convert(e.format),
                                M = a.convert(e.type),
                                T = p(w, M);
                            for (y(34067, e, _), x = 0; x < 6; x++)
                                if (f)
                                    for (var S, E = g[x].mipmaps, A = 0, L = E.length; A < L; A++) S = E[A], e.format !== Ht && e.format !== Ft ? n.getCompressedTextureFormats().indexOf(w) > -1 ? n.compressedTexImage2D(34069 + x, A, T, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + x, A, T, S.width, S.height, 0, w, M, S.data);
                                else v ? n.texImage2D(34069 + x, 0, T, g[x].width, g[x].height, 0, w, M, g[x].data) : n.texImage2D(34069 + x, 0, T, w, M, g[x]);
                            c.__maxMipLevel = f ? E.length - 1 : 0, h(e, _) && d(34067, e, b.width, b.height), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else n.activeTexture(33984 + s), n.bindTexture(34067, c.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function(t, e) {
                    n.activeTexture(33984 + e), n.bindTexture(34067, i.get(t).__webglTexture)
                }, this.setupRenderTarget = function(e) {
                    var s = i.get(e),
                        c = i.get(e.texture);
                    e.addEventListener("dispose", v), c.__webglTexture = t.createTexture(), o.memory.textures++;
                    var u = !0 === e.isWebGLRenderTargetCube,
                        f = !0 === e.isWebGLMultisampleRenderTarget,
                        m = l(e) || r.isWebGL2;
                    if (u) {
                        s.__webglFramebuffer = [];
                        for (var g = 0; g < 6; g++) s.__webglFramebuffer[g] = t.createFramebuffer()
                    } else if (s.__webglFramebuffer = t.createFramebuffer(), f)
                        if (r.isWebGL2) {
                            s.__webglMultisampledFramebuffer = t.createFramebuffer(), s.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
                            var x = p(a.convert(e.texture.format), a.convert(e.texture.type)),
                                T = M(e);
                            t.renderbufferStorageMultisample(36161, T, x, e.width, e.height), t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(), _(s.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (u) {
                        for (n.bindTexture(34067, c.__webglTexture), y(34067, e.texture, m), g = 0; g < 6; g++) b(s.__webglFramebuffer[g], e, 36064, 34069 + g);
                        h(e.texture, m) && d(34067, e.texture, e.width, e.height), n.bindTexture(34067, null)
                    } else n.bindTexture(3553, c.__webglTexture), y(3553, e.texture, m), b(s.__webglFramebuffer, e, 36064, 3553), h(e.texture, m) && d(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);
                    e.depthBuffer && w(e)
                }, this.updateRenderTargetMipmap = function(t) {
                    var e = t.texture;
                    if (h(e, l(t) || r.isWebGL2)) {
                        var a = t.isWebGLRenderTargetCube ? 34067 : 3553,
                            o = i.get(e).__webglTexture;
                        n.bindTexture(a, o), d(a, e, t.width, t.height), n.bindTexture(a, null)
                    }
                }, this.updateMultisampleRenderTarget = function(e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (r.isWebGL2) {
                            var n = i.get(e);
                            t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                            var a = e.width,
                                o = e.height,
                                s = 16384;
                            e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, 9728)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }
            }

            function Hr(t, e, n) {
                return {
                    convert: function(t) {
                        var i;
                        if (t === bt) return 10497;
                        if (t === _t) return 33071;
                        if (t === wt) return 33648;
                        if (t === Mt) return 9728;
                        if (t === Tt) return 9984;
                        if (t === St) return 9986;
                        if (t === Et) return 9729;
                        if (t === At) return 9985;
                        if (t === Lt) return 9987;
                        if (t === Pt) return 5121;
                        if (t === kt) return 32819;
                        if (t === zt) return 32820;
                        if (t === Bt) return 33635;
                        if (t === Ot) return 5120;
                        if (t === Ct) return 5122;
                        if (t === Rt) return 5123;
                        if (t === It) return 5124;
                        if (t === Dt) return 5125;
                        if (t === jt) return 5126;
                        if (t === Nt) {
                            if (n.isWebGL2) return 5131;
                            if (null !== (i = e.get("OES_texture_half_float"))) return i.HALF_FLOAT_OES
                        }
                        if (t === Gt) return 6406;
                        if (t === Ft) return 6407;
                        if (t === Ht) return 6408;
                        if (t === Vt) return 6409;
                        if (t === Wt) return 6410;
                        if (t === qt) return 6402;
                        if (t === Xt) return 34041;
                        if (t === Yt) return 6403;
                        if (t === D) return 32774;
                        if (t === j) return 32778;
                        if (t === N) return 32779;
                        if (t === B) return 0;
                        if (t === U) return 1;
                        if (t === G) return 768;
                        if (t === F) return 769;
                        if (t === H) return 770;
                        if (t === V) return 771;
                        if (t === W) return 772;
                        if (t === q) return 773;
                        if (t === X) return 774;
                        if (t === Y) return 775;
                        if (t === Z) return 776;
                        if ((t === Zt || t === Jt || t === Kt || t === Qt) && null !== (i = e.get("WEBGL_compressed_texture_s3tc"))) {
                            if (t === Zt) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === Jt) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === Kt) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === Qt) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((t === $t || t === te || t === ee || t === ne) && null !== (i = e.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (t === $t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === te) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === ee) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === ne) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (t === ie && null !== (i = e.get("WEBGL_compressed_texture_etc1"))) return i.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((t === re || t === ae || t === oe || t === se || t === ce || t === ue || t === le || t === he || t === de || t === pe || t === fe || t === me || t === ve || t === ge) && null !== (i = e.get("WEBGL_compressed_texture_astc"))) return t;
                        if (t === k || t === z) {
                            if (n.isWebGL2) {
                                if (t === k) return 32775;
                                if (t === z) return 32776
                            }
                            if (null !== (i = e.get("EXT_blend_minmax"))) {
                                if (t === k) return i.MIN_EXT;
                                if (t === z) return i.MAX_EXT
                            }
                        }
                        if (t === Ut) {
                            if (n.isWebGL2) return 34042;
                            if (null !== (i = e.get("WEBGL_depth_texture"))) return i.UNSIGNED_INT_24_8_WEBGL
                        }
                        return 0
                    }
                }
            }

            function Vr() {
                Sn.call(this), this.type = "Group"
            }

            function Wr() {
                Sn.call(this), this.type = "Camera", this.matrixWorldInverse = new Ne, this.projectionMatrix = new Ne, this.projectionMatrixInverse = new Ne
            }

            function qr(t, e, n, i) {
                Wr.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function Xr(t) {
                qr.call(this), this.cameras = t || []
            }
            zr.prototype = Object.create(si.prototype), zr.prototype.constructor = zr, zr.prototype.isMeshDepthMaterial = !0, zr.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, Br.prototype = Object.create(si.prototype), Br.prototype.constructor = Br, Br.prototype.isMeshDistanceMaterial = !0, Br.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }, Vr.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: Vr,
                isGroup: !0
            }), Wr.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: Wr,
                isCamera: !0,
                copy: function(t, e) {
                    return Sn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new ze), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    Sn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), qr.prototype = Object.assign(Object.create(Wr.prototype), {
                constructor: qr,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return Wr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * De.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * De.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * De.RAD2DEG * Math.atan(Math.tan(.5 * De.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, i, r, a) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = this.near,
                        e = t * Math.tan(.5 * De.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        i = this.aspect * n,
                        r = -.5 * i,
                        a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var o = a.fullWidth,
                            s = a.fullHeight;
                        r += a.offsetX * i / o, e -= a.offsetY * n / s, i *= a.width / o, n *= a.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = Sn.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            }), Xr.prototype = Object.assign(Object.create(qr.prototype), {
                constructor: Xr,
                isArrayCamera: !0
            });
            var Yr, Zr, Jr, Kr, Qr, $r, ta = new ze,
                ea = new ze;

            function na(t, e, n) {
                ta.setFromMatrixPosition(e.matrixWorld), ea.setFromMatrixPosition(n.matrixWorld);
                var i = ta.distanceTo(ea),
                    r = e.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    c = (r[9] + 1) / r[5],
                    u = (r[9] - 1) / r[5],
                    l = (r[8] - 1) / r[0],
                    h = (a[8] + 1) / a[0],
                    d = o * l,
                    p = o * h,
                    f = i / (-l + h),
                    m = f * -l;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                var v = o + f,
                    g = s + f,
                    y = d - m,
                    x = p + (i - m),
                    b = c * s / g * v,
                    _ = u * s / g * v;
                t.projectionMatrix.makePerspective(y, x, b, _, v, g)
            }

            function ia(t) {
                var e = this,
                    n = null,
                    i = null,
                    r = null,
                    a = [],
                    o = new Ne,
                    s = new Ne,
                    c = 1,
                    u = "stage";
                "undefined" != typeof window && "VRFrameData" in window && (i = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", x, !1));
                var l = new Ne,
                    h = new ke,
                    d = new ze,
                    p = new qr;
                p.bounds = new Ye(0, 0, .5, 1), p.layers.enable(1);
                var f = new qr;
                f.bounds = new Ye(.5, 0, .5, 1), f.layers.enable(2);
                var m, v, g = new Xr([p, f]);

                function y() {
                    return null !== n && !0 === n.isPresenting
                }

                function x() {
                    if (y()) {
                        var i = n.getEyeParameters("left"),
                            r = i.renderWidth * c,
                            a = i.renderHeight * c;
                        v = t.getPixelRatio(), m = t.getSize(), t.setDrawingBufferSize(2 * r, a, 1), w.start()
                    } else e.enabled && t.setDrawingBufferSize(m.width, m.height, v), w.stop()
                }
                g.layers.enable(1), g.layers.enable(2);
                var b = [];

                function _(t) {
                    for (var e = navigator.getGamepads && navigator.getGamepads(), n = 0, i = 0, r = e.length; n < r; n++) {
                        var a = e[n];
                        if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
                            if (i === t) return a;
                            i++
                        }
                    }
                }
                this.enabled = !1, this.getController = function(t) {
                    var e = a[t];
                    return void 0 === e && ((e = new Vr).matrixAutoUpdate = !1, e.visible = !1, a[t] = e), e
                }, this.getDevice = function() {
                    return n
                }, this.setDevice = function(t) {
                    void 0 !== t && (n = t), w.setContext(t)
                }, this.setFramebufferScaleFactor = function(t) {
                    c = t
                }, this.setFrameOfReferenceType = function(t) {
                    u = t
                }, this.setPoseTarget = function(t) {
                    void 0 !== t && (r = t)
                }, this.getCamera = function(t) {
                    var e = "stage" === u ? 1.6 : 0;
                    if (null === n) return t.position.set(0, e, 0), t;
                    if (n.depthNear = t.near, n.depthFar = t.far, n.getFrameData(i), "stage" === u) {
                        var c = n.stageParameters;
                        c ? o.fromArray(c.sittingToStandingTransform) : o.makeTranslation(0, e, 0)
                    }
                    var m = i.pose,
                        v = null !== r ? r : t;
                    if (v.matrix.copy(o), v.matrix.decompose(v.position, v.quaternion, v.scale), null !== m.orientation && (h.fromArray(m.orientation), v.quaternion.multiply(h)), null !== m.position && (h.setFromRotationMatrix(o), d.fromArray(m.position), d.applyQuaternion(h), v.position.add(d)), v.updateMatrixWorld(), !1 === n.isPresenting) return t;
                    p.near = t.near, f.near = t.near, p.far = t.far, f.far = t.far, p.matrixWorldInverse.fromArray(i.leftViewMatrix), f.matrixWorldInverse.fromArray(i.rightViewMatrix), s.getInverse(o), "stage" === u && (p.matrixWorldInverse.multiply(s), f.matrixWorldInverse.multiply(s));
                    var y = v.parent;
                    null !== y && (l.getInverse(y.matrixWorld), p.matrixWorldInverse.multiply(l), f.matrixWorldInverse.multiply(l)), p.matrixWorld.getInverse(p.matrixWorldInverse), f.matrixWorld.getInverse(f.matrixWorldInverse), p.projectionMatrix.fromArray(i.leftProjectionMatrix), f.projectionMatrix.fromArray(i.rightProjectionMatrix), na(g, p, f);
                    var x = n.getLayers();
                    if (x.length) {
                        var w = x[0];
                        null !== w.leftBounds && 4 === w.leftBounds.length && p.bounds.fromArray(w.leftBounds), null !== w.rightBounds && 4 === w.rightBounds.length && f.bounds.fromArray(w.rightBounds)
                    }
                    return function() {
                        for (var t = 0; t < a.length; t++) {
                            var e = a[t],
                                n = _(t);
                            if (void 0 !== n && void 0 !== n.pose) {
                                if (null === n.pose) return;
                                var i = n.pose;
                                !1 === i.hasPosition && e.position.set(.2, -.6, -.05), null !== i.position && e.position.fromArray(i.position), null !== i.orientation && e.quaternion.fromArray(i.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(o), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                                var r = "Daydream Controller" === n.id ? 0 : 1;
                                b[t] !== n.buttons[r].pressed && (b[t] = n.buttons[r].pressed, !0 === b[t] ? e.dispatchEvent({
                                    type: "selectstart"
                                }) : (e.dispatchEvent({
                                    type: "selectend"
                                }), e.dispatchEvent({
                                    type: "select"
                                })))
                            } else e.visible = !1
                        }
                    }(), g
                }, this.getStandingMatrix = function() {
                    return o
                }, this.isPresenting = y;
                var w = new mn;
                this.setAnimationLoop = function(t) {
                    w.setAnimationLoop(t)
                }, this.submitFrame = function() {
                    y() && n.submitFrame()
                }, this.dispose = function() {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", x)
                }
            }

            function ra(t) {
                var e = t.context,
                    n = null,
                    i = null,
                    r = 1,
                    a = null,
                    o = "stage",
                    s = null,
                    c = [],
                    u = [];

                function l() {
                    return null !== i && null !== a
                }
                var h = new qr;
                h.layers.enable(1), h.viewport = new Ye;
                var d = new qr;
                d.layers.enable(2), d.viewport = new Ye;
                var p = new Xr([h, d]);

                function f(t) {
                    var e = c[u.indexOf(t.inputSource)];
                    e && e.dispatchEvent({
                        type: t.type
                    })
                }

                function m() {
                    t.setFramebuffer(null), y.stop()
                }

                function v(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                }
                p.layers.enable(1), p.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                    var e = c[t];
                    return void 0 === e && ((e = new Vr).matrixAutoUpdate = !1, e.visible = !1, c[t] = e), e
                }, this.getDevice = function() {
                    return n
                }, this.setDevice = function(t) {
                    void 0 !== t && (n = t), t instanceof XRDevice && e.setCompatibleXRDevice(t)
                }, this.setFramebufferScaleFactor = function(t) {
                    r = t
                }, this.setFrameOfReferenceType = function(t) {
                    o = t
                }, this.setSession = function(n) {
                    null !== (i = n) && (i.addEventListener("select", f), i.addEventListener("selectstart", f), i.addEventListener("selectend", f), i.addEventListener("end", m), i.baseLayer = new XRWebGLLayer(i, e, {
                        framebufferScaleFactor: r
                    }), i.requestFrameOfReference(o).then(function(e) {
                        a = e, t.setFramebuffer(i.baseLayer.framebuffer), y.setContext(i), y.start()
                    }), u = i.getInputSources(), i.addEventListener("inputsourceschange", function() {
                        u = i.getInputSources(), console.log(u);
                        for (var t = 0; t < c.length; t++) {
                            c[t].userData.inputSource = u[t]
                        }
                    }))
                }, this.getCamera = function(t) {
                    if (l()) {
                        var e = t.parent,
                            n = p.cameras;
                        v(p, e);
                        for (var i = 0; i < n.length; i++) v(n[i], e);
                        t.matrixWorld.copy(p.matrixWorld);
                        for (var r = t.children, a = (i = 0, r.length); i < a; i++) r[i].updateMatrixWorld(!0);
                        return na(p, h, d), p
                    }
                    return t
                }, this.isPresenting = l;
                var g = null;
                var y = new mn;
                y.setAnimationLoop(function(t, e) {
                    if (null !== (s = e.getDevicePose(a)))
                        for (var n = i.baseLayer, r = e.views, o = 0; o < r.length; o++) {
                            var l = r[o],
                                h = n.getViewport(l),
                                d = s.getViewMatrix(l),
                                f = p.cameras[o];
                            f.matrix.fromArray(d).getInverse(f.matrix), f.projectionMatrix.fromArray(l.projectionMatrix), f.viewport.set(h.x, h.y, h.width, h.height), 0 === o && p.matrix.copy(f.matrix)
                        }
                    for (o = 0; o < c.length; o++) {
                        var m = c[o],
                            v = u[o];
                        if (v) {
                            var y = e.getInputPose(v, a);
                            if (null !== y) {
                                "targetRay" in y ? m.matrix.elements = y.targetRay.transformMatrix : "pointerMatrix" in y && (m.matrix.elements = y.pointerMatrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.visible = !0;
                                continue
                            }
                        }
                        m.visible = !1
                    }
                    g && g(t)
                }), this.setAnimationLoop = function(t) {
                    g = t
                }, this.dispose = function() {}, this.getStandingMatrix = function() {
                    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4
                }, this.submitFrame = function() {}
            }

            function aa(t) {
                console.log("THREE.WebGLRenderer", v);
                var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== t.context ? t.context : null,
                    i = void 0 !== t.alpha && t.alpha,
                    r = void 0 === t.depth || t.depth,
                    a = void 0 === t.stencil || t.stencil,
                    o = void 0 !== t.antialias && t.antialias,
                    s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    u = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    l = null,
                    h = null;
                this.domElement = e, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = ct, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var d, p, f, m, g, y, x, b, _, w, T, S, E, A, L, P, O, C, R = this,
                    I = !1,
                    D = null,
                    j = null,
                    N = null,
                    k = -1,
                    z = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    B = null,
                    U = null,
                    G = new Ye,
                    F = new Ye,
                    H = null,
                    V = 0,
                    W = e.width,
                    q = e.height,
                    X = 1,
                    Y = new Ye(0, 0, W, q),
                    Z = new Ye(0, 0, W, q),
                    J = !1,
                    K = new nn,
                    Q = new vi,
                    $ = !1,
                    tt = !1,
                    et = new Ne,
                    nt = new ze;

                function it() {
                    return null === j ? X : 1
                }
                try {
                    var rt = {
                        alpha: i,
                        depth: r,
                        stencil: a,
                        antialias: o,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: c,
                        powerPreference: u
                    };
                    if (e.addEventListener("webglcontextlost", ut, !1), e.addEventListener("webglcontextrestored", lt, !1), null === (d = n || e.getContext("webgl", rt) || e.getContext("experimental-webgl", rt))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === d.getShaderPrecisionFormat && (d.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (Mt) {
                    console.error("THREE.WebGLRenderer: " + Mt.message)
                }

                function at() {
                    p = new gi(d), (f = new mi(d, p, t)).isWebGL2 || (p.get("WEBGL_depth_texture"), p.get("OES_texture_float"), p.get("OES_texture_half_float"), p.get("OES_texture_half_float_linear"), p.get("OES_standard_derivatives"), p.get("OES_element_index_uint"), p.get("ANGLE_instanced_arrays")), p.get("OES_texture_float_linear"), C = new Hr(d, p, f), (m = new Gr(d, p, C, f)).scissor(F.copy(Z).multiplyScalar(X)), m.viewport(G.copy(Y).multiplyScalar(X)), g = new bi(d), y = new Lr, x = new Fr(d, p, m, y, f, C, g), b = new vn(d), _ = new yi(d, b, g), w = new Mi(_, g), L = new wi(d), T = new Ar(R, p, f), S = new Rr, E = new kr, A = new pi(R, m, w, s), P = new fi(d, p, g, f), O = new xi(d, p, g, f), g.programs = T.programs, R.context = d, R.capabilities = f, R.extensions = p, R.properties = y, R.renderLists = S, R.state = m, R.info = g
                }
                at();
                var ot = null;
                "undefined" != typeof navigator && (ot = "xr" in navigator ? new ra(R) : new ia(R)), this.vr = ot;
                var st = new Ur(R, w, f.maxTextureSize);

                function ut(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), I = !0
                }

                function lt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), I = !1, at()
                }

                function ht(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", ht),
                        function(t) {
                            dt(t), y.remove(t)
                        }(e)
                }

                function dt(t) {
                    var e = y.get(t).program;
                    t.program = void 0, void 0 !== e && T.releaseProgram(e)
                }
                this.shadowMap = st, this.getContext = function() {
                    return d
                }, this.getContextAttributes = function() {
                    return d.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = p.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = p.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return X
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (X = t, this.setSize(W, q, !1))
                }, this.getSize = function() {
                    return {
                        width: W,
                        height: q
                    }
                }, this.setSize = function(t, n, i) {
                    ot.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (W = t, q = n, e.width = t * X, e.height = n * X, !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function() {
                    return {
                        width: W * X,
                        height: q * X
                    }
                }, this.setDrawingBufferSize = function(t, n, i) {
                    W = t, q = n, X = i, e.width = t * i, e.height = n * i, this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function() {
                    return G
                }, this.setViewport = function(t, e, n, i) {
                    Y.set(t, q - e - i, n, i), m.viewport(G.copy(Y).multiplyScalar(X))
                }, this.setScissor = function(t, e, n, i) {
                    Z.set(t, q - e - i, n, i), m.scissor(F.copy(Z).multiplyScalar(X))
                }, this.setScissorTest = function(t) {
                    m.setScissorTest(J = t)
                }, this.getClearColor = function() {
                    return A.getClearColor()
                }, this.setClearColor = function() {
                    A.setClearColor.apply(A, arguments)
                }, this.getClearAlpha = function() {
                    return A.getClearAlpha()
                }, this.setClearAlpha = function() {
                    A.setClearAlpha.apply(A, arguments)
                }, this.clear = function(t, e, n) {
                    var i = 0;
                    (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), d.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", ut, !1), e.removeEventListener("webglcontextrestored", lt, !1), S.dispose(), E.dispose(), y.dispose(), w.dispose(), ot.dispose(), mt.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    m.initAttributes();
                    var n = y.get(t);
                    t.hasPositions && !n.position && (n.position = d.createBuffer()), t.hasNormals && !n.normal && (n.normal = d.createBuffer()), t.hasUvs && !n.uv && (n.uv = d.createBuffer()), t.hasColors && !n.color && (n.color = d.createBuffer());
                    var i = e.getAttributes();
                    t.hasPositions && (d.bindBuffer(34962, n.position), d.bufferData(34962, t.positionArray, 35048), m.enableAttribute(i.position), d.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (d.bindBuffer(34962, n.normal), d.bufferData(34962, t.normalArray, 35048), m.enableAttribute(i.normal), d.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (d.bindBuffer(34962, n.uv), d.bufferData(34962, t.uvArray, 35048), m.enableAttribute(i.uv), d.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (d.bindBuffer(34962, n.color), d.bufferData(34962, t.colorArray, 35048), m.enableAttribute(i.color), d.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), m.disableUnusedAttributes(), d.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, i, r, a) {
                    var o = r.isMesh && r.normalMatrix.determinant() < 0;
                    m.setMaterial(i, o);
                    var s = xt(t, e, i, r),
                        c = !1;
                    z.geometry === n.id && z.program === s.id && z.wireframe === (!0 === i.wireframe) || (z.geometry = n.id, z.program = s.id, z.wireframe = !0 === i.wireframe, c = !0), r.morphTargetInfluences && (L.update(r, n, i, s), c = !0);
                    var u, l = n.index,
                        h = n.attributes.position,
                        v = 1;
                    !0 === i.wireframe && (l = _.getWireframeAttribute(n), v = 2);
                    var g = P;
                    null !== l && (u = b.get(l), (g = O).setIndex(u)), c && (! function(t, e, n) {
                        if (n && n.isInstancedBufferGeometry & !f.isWebGL2 && null === p.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        m.initAttributes();
                        var i = n.attributes,
                            r = e.getAttributes(),
                            a = t.defaultAttributeValues;
                        for (var o in r) {
                            var s = r[o];
                            if (s >= 0) {
                                var c = i[o];
                                if (void 0 !== c) {
                                    var u = c.normalized,
                                        l = c.itemSize,
                                        h = b.get(c);
                                    if (void 0 === h) continue;
                                    var v = h.buffer,
                                        g = h.type,
                                        y = h.bytesPerElement;
                                    if (c.isInterleavedBufferAttribute) {
                                        var x = c.data,
                                            _ = x.stride,
                                            w = c.offset;
                                        x && x.isInstancedInterleavedBuffer ? (m.enableAttributeAndDivisor(s, x.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = x.meshPerAttribute * x.count)) : m.enableAttribute(s), d.bindBuffer(34962, v), d.vertexAttribPointer(s, l, g, u, _ * y, w * y)
                                    } else c.isInstancedBufferAttribute ? (m.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : m.enableAttribute(s), d.bindBuffer(34962, v), d.vertexAttribPointer(s, l, g, u, 0, 0)
                                } else if (void 0 !== a) {
                                    var M = a[o];
                                    if (void 0 !== M) switch (M.length) {
                                        case 2:
                                            d.vertexAttrib2fv(s, M);
                                            break;
                                        case 3:
                                            d.vertexAttrib3fv(s, M);
                                            break;
                                        case 4:
                                            d.vertexAttrib4fv(s, M);
                                            break;
                                        default:
                                            d.vertexAttrib1fv(s, M)
                                    }
                                }
                            }
                        }
                        m.disableUnusedAttributes()
                    }(i, s, n), null !== l && d.bindBuffer(34963, u.buffer));
                    var y = 1 / 0;
                    null !== l ? y = l.count : void 0 !== h && (y = h.count);
                    var x = n.drawRange.start * v,
                        w = n.drawRange.count * v,
                        M = null !== a ? a.start * v : 0,
                        T = null !== a ? a.count * v : 1 / 0,
                        S = Math.max(x, M),
                        E = Math.min(y, x + w, M + T) - 1,
                        A = Math.max(0, E - S + 1);
                    if (0 !== A) {
                        if (r.isMesh)
                            if (!0 === i.wireframe) m.setLineWidth(i.wireframeLinewidth * it()), g.setMode(1);
                            else switch (r.drawMode) {
                                case be:
                                    g.setMode(4);
                                    break;
                                case _e:
                                    g.setMode(5);
                                    break;
                                case we:
                                    g.setMode(6)
                            } else if (r.isLine) {
                                var C = i.linewidth;
                                void 0 === C && (C = 1), m.setLineWidth(C * it()), r.isLineSegments ? g.setMode(1) : r.isLineLoop ? g.setMode(2) : g.setMode(3)
                            } else r.isPoints ? g.setMode(0) : r.isSprite && g.setMode(4);
                        n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && g.renderInstances(n, S, A) : g.render(S, A)
                    }
                }, this.compile = function(t, e) {
                    (h = E.get(t, e)).init(), t.traverse(function(t) {
                        t.isLight && (h.pushLight(t), t.castShadow && h.pushShadow(t))
                    }), h.setupLights(e), t.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var n = 0; n < e.material.length; n++) yt(e.material[n], t.fog, e);
                            else yt(e.material, t.fog, e)
                    })
                };
                var pt = null;
                var ft, mt = new mn;

                function vt(t, e, n, i) {
                    for (var r = 0, a = t.length; r < a; r++) {
                        var o = t[r],
                            s = o.object,
                            c = o.geometry,
                            u = void 0 === i ? o.material : i,
                            l = o.group;
                        if (n.isArrayCamera) {
                            U = n;
                            for (var d = n.cameras, p = 0, f = d.length; p < f; p++) {
                                var v = d[p];
                                if (s.layers.test(v.layers)) {
                                    if ("viewport" in v) m.viewport(G.copy(v.viewport));
                                    else {
                                        var g = v.bounds,
                                            y = g.x * W,
                                            x = g.y * q,
                                            b = g.z * W,
                                            _ = g.w * q;
                                        m.viewport(G.set(y, x, b, _).multiplyScalar(X))
                                    }
                                    h.setupLights(v), gt(s, e, v, c, u, l)
                                }
                            }
                        } else U = null, gt(s, e, n, c, u, l)
                    }
                }

                function gt(t, e, n, i, r, a) {
                    if (t.onBeforeRender(R, e, n, i, r, a), h = E.get(e, U || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        m.setMaterial(r);
                        var o = xt(n, e.fog, r, t);
                        z.geometry = null, z.program = null, z.wireframe = !1,
                            function(t, e) {
                                t.render(function(t) {
                                    R.renderBufferImmediate(t, e)
                                })
                            }(t, o)
                    } else R.renderBufferDirect(n, e.fog, i, r, t, a);
                    t.onAfterRender(R, e, n, i, r, a), h = E.get(e, U || n)
                }

                function yt(t, e, n) {
                    var i = y.get(t),
                        r = h.state.lights,
                        a = h.state.shadowsArray,
                        o = i.lightsHash,
                        s = r.state.hash,
                        c = T.getParameters(t, r.state, a, e, Q.numPlanes, Q.numIntersection, n),
                        u = T.getProgramCode(t, c),
                        l = i.program,
                        d = !0;
                    if (void 0 === l) t.addEventListener("dispose", ht);
                    else if (l.code !== u) dt(t);
                    else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, d = !1;
                    else {
                        if (void 0 !== c.shaderID) return;
                        d = !1
                    }
                    if (d) {
                        if (c.shaderID) {
                            var p = fn[c.shaderID];
                            i.shader = {
                                name: t.type,
                                uniforms: an(p.uniforms),
                                vertexShader: p.vertexShader,
                                fragmentShader: p.fragmentShader
                            }
                        } else i.shader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                        t.onBeforeCompile(i.shader, R), u = T.getProgramCode(t, c), l = T.acquireProgram(t, i.shader, c, u), i.program = l, t.program = l
                    }
                    var f = l.getAttributes();
                    if (t.morphTargets) {
                        t.numSupportedMorphTargets = 0;
                        for (var m = 0; m < R.maxMorphTargets; m++) f["morphTarget" + m] >= 0 && t.numSupportedMorphTargets++
                    }
                    if (t.morphNormals) {
                        t.numSupportedMorphNormals = 0;
                        for (m = 0; m < R.maxMorphNormals; m++) f["morphNormal" + m] >= 0 && t.numSupportedMorphNormals++
                    }
                    var v = i.shader.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = Q.numPlanes, i.numIntersection = Q.numIntersection, v.clippingPlanes = Q.uniform), i.fog = e, void 0 === o && (i.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, t.lights && (v.ambientLightColor.value = r.state.ambient, v.directionalLights.value = r.state.directional, v.spotLights.value = r.state.spot, v.rectAreaLights.value = r.state.rectArea, v.pointLights.value = r.state.point, v.hemisphereLights.value = r.state.hemi, v.directionalShadowMap.value = r.state.directionalShadowMap, v.directionalShadowMatrix.value = r.state.directionalShadowMatrix, v.spotShadowMap.value = r.state.spotShadowMap, v.spotShadowMatrix.value = r.state.spotShadowMatrix, v.pointShadowMap.value = r.state.pointShadowMap, v.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var g = i.program.getUniforms(),
                        x = mr.seqWithValue(g.seq, v);
                    i.uniformsList = x
                }

                function xt(t, e, n, i) {
                    V = 0;
                    var r = y.get(n),
                        a = h.state.lights,
                        o = r.lightsHash,
                        s = a.state.hash;
                    if ($ && (tt || t !== B)) {
                        var c = t === B && n.id === k;
                        Q.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, c)
                    }!1 === n.needsUpdate && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : (!n.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === Q.numPlanes && r.numIntersection === Q.numIntersection) || (n.needsUpdate = !0)), n.needsUpdate && (yt(n, e, i), n.needsUpdate = !1);
                    var u, l, p = !1,
                        v = !1,
                        g = !1,
                        x = r.program,
                        b = x.getUniforms(),
                        _ = r.shader.uniforms;
                    if (m.useProgram(x.program) && (p = !0, v = !0, g = !0), n.id !== k && (k = n.id, v = !0), p || B !== t) {
                        if (b.setValue(d, "projectionMatrix", t.projectionMatrix), f.logarithmicDepthBuffer && b.setValue(d, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), B !== t && (B = t, v = !0, g = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var w = b.map.cameraPosition;
                            void 0 !== w && w.setValue(d, nt.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && b.setValue(d, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        b.setOptional(d, i, "bindMatrix"), b.setOptional(d, i, "bindMatrixInverse");
                        var T = i.skeleton;
                        if (T) {
                            var S = T.bones;
                            if (f.floatVertexTextures) {
                                if (void 0 === T.boneTexture) {
                                    var E = Math.sqrt(4 * S.length);
                                    E = De.ceilPowerOfTwo(E), E = Math.max(E, 4);
                                    var A = new Float32Array(E * E * 4);
                                    A.set(T.boneMatrices);
                                    var L = new Qe(A, E, E, Ht, jt);
                                    L.needsUpdate = !0, T.boneMatrices = A, T.boneTexture = L, T.boneTextureSize = E
                                }
                                b.setValue(d, "boneTexture", T.boneTexture), b.setValue(d, "boneTextureSize", T.boneTextureSize)
                            } else b.setOptional(d, T, "boneMatrices")
                        }
                    }
                    return v && (b.setValue(d, "toneMappingExposure", R.toneMappingExposure), b.setValue(d, "toneMappingWhitePoint", R.toneMappingWhitePoint), n.lights && (l = g, (u = _).ambientLightColor.needsUpdate = l, u.directionalLights.needsUpdate = l, u.pointLights.needsUpdate = l, u.spotLights.needsUpdate = l, u.rectAreaLights.needsUpdate = l, u.hemisphereLights.needsUpdate = l), e && n.fog && function(t, e) {
                        t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    }(_, e), n.isMeshBasicMaterial ? bt(_, n) : n.isMeshLambertMaterial ? (bt(_, n), function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(_, n)) : n.isMeshPhongMaterial ? (bt(_, n), n.isMeshToonMaterial ? function(t, e) {
                        _t(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(_, n) : _t(_, n)) : n.isMeshStandardMaterial ? (bt(_, n), n.isMeshPhysicalMaterial ? function(t, e) {
                        wt(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
                    }(_, n) : wt(_, n)) : n.isMeshMatcapMaterial ? (bt(_, n), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === M && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === M && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(_, n)) : n.isMeshDepthMaterial ? (bt(_, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(_, n)) : n.isMeshDistanceMaterial ? (bt(_, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(_, n)) : n.isMeshNormalMaterial ? (bt(_, n), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === M && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === M && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(_, n)) : n.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity
                    }(_, n), n.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(_, n)) : n.isPointsMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * X, t.scale.value = .5 * q, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(_, n) : n.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(_, n) : n.isShadowMaterial && (_.color.value = n.color, _.opacity.value = n.opacity), void 0 !== _.ltc_1 && (_.ltc_1.value = pn.LTC_1), void 0 !== _.ltc_2 && (_.ltc_2.value = pn.LTC_2), mr.upload(d, r.uniformsList, _, R)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (mr.upload(d, r.uniformsList, _, R), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && b.setValue(d, "center", i.center), b.setValue(d, "modelViewMatrix", i.modelViewMatrix), b.setValue(d, "normalMatrix", i.normalMatrix), b.setValue(d, "modelMatrix", i.matrixWorld), x
                }

                function bt(t, e) {
                    var n;
                    t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = y.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }

                function _t(t, e) {
                    t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === M && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === M && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function wt(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === M && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === M && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                mt.setAnimationLoop(function(t) {
                    ot.isPresenting() || pt && pt(t)
                }), "undefined" != typeof window && mt.setContext(window), this.setAnimationLoop = function(t) {
                    pt = t, ot.setAnimationLoop(t), mt.start()
                }, this.render = function(t, e, n, i) {
                    if (e && e.isCamera) {
                        if (!I) {
                            z.geometry = null, z.program = null, z.wireframe = !1, k = -1, B = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), ot.enabled && (e = ot.getCamera(e)), (h = E.get(t, e)).init(), t.onBeforeRender(R, t, e, n), et.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), K.setFromMatrix(et), tt = this.localClippingEnabled, $ = Q.init(this.clippingPlanes, tt, e), (l = S.get(t, e)).init(),
                                function t(e, n, i, r) {
                                    if (!1 === e.visible) return;
                                    var a = e.layers.test(n.layers);
                                    if (a)
                                        if (e.isGroup) i = e.renderOrder;
                                        else if (e.isLight) h.pushLight(e), e.castShadow && h.pushShadow(e);
                                    else if (e.isSprite) {
                                        if (!e.frustumCulled || K.intersectsSprite(e)) {
                                            r && nt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(et);
                                            var o = w.update(e),
                                                s = e.material;
                                            l.push(e, o, s, i, nt.z, null)
                                        }
                                    } else if (e.isImmediateRenderObject) r && nt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(et), l.push(e, null, e.material, i, nt.z, null);
                                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || K.intersectsObject(e))) {
                                        r && nt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(et);
                                        var o = w.update(e),
                                            s = e.material;
                                        if (Array.isArray(s))
                                            for (var c = o.groups, u = 0, d = c.length; u < d; u++) {
                                                var p = c[u],
                                                    f = s[p.materialIndex];
                                                f && f.visible && l.push(e, o, f, i, nt.z, p)
                                            } else s.visible && l.push(e, o, s, i, nt.z, null)
                                    }
                                    var m = e.children;
                                    for (var u = 0, d = m.length; u < d; u++) t(m[u], n, i, r)
                                }(t, e, 0, R.sortObjects), !0 === R.sortObjects && l.sort(), $ && Q.beginShadows();
                            var r = h.state.shadowsArray;
                            st.render(r, t, e), h.setupLights(e), $ && Q.endShadows(), this.info.autoReset && this.info.reset(), void 0 === n && (n = null), this.setRenderTarget(n), A.render(l, t, e, i);
                            var a = l.opaque,
                                o = l.transparent;
                            if (t.overrideMaterial) {
                                var s = t.overrideMaterial;
                                a.length && vt(a, t, e, s), o.length && vt(o, t, e, s)
                            } else a.length && vt(a, t, e), o.length && vt(o, t, e);
                            n && (x.updateRenderTargetMipmap(n), x.updateMultisampleRenderTarget(n)), m.buffers.depth.setTest(!0), m.buffers.depth.setMask(!0), m.buffers.color.setMask(!0), m.setPolygonOffset(!1), t.onAfterRender(R, t, e), ot.enabled && ot.submitFrame(), l = null, h = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.allocTextureUnit = function() {
                    var t = V;
                    return t >= f.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + f.maxTextures), V += 1, t
                }, this.setTexture2D = (ft = !1, function(t, e) {
                    t && t.isWebGLRenderTarget && (ft || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), ft = !0), t = t.texture), x.setTexture2D(t, e)
                }), this.setTexture3D = function(t, e) {
                    x.setTexture3D(t, e)
                }, this.setTexture = function() {
                    var t = !1;
                    return function(e, n) {
                        t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), x.setTexture2D(e, n)
                    }
                }(), this.setTextureCube = function() {
                    var t = !1;
                    return function(e, n) {
                        e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? x.setTextureCube(e, n) : x.setTextureCubeDynamic(e, n)
                    }
                }(), this.setFramebuffer = function(t) {
                    D = t
                }, this.getRenderTarget = function() {
                    return j
                }, this.setRenderTarget = function(t) {
                    j = t, t && void 0 === y.get(t).__webglFramebuffer && x.setupRenderTarget(t);
                    var e = D,
                        n = !1;
                    if (t) {
                        var i = y.get(t).__webglFramebuffer;
                        t.isWebGLRenderTargetCube ? (e = i[t.activeCubeFace], n = !0) : e = t.isWebGLMultisampleRenderTarget ? y.get(t).__webglMultisampledFramebuffer : i, G.copy(t.viewport), F.copy(t.scissor), H = t.scissorTest
                    } else G.copy(Y).multiplyScalar(X), F.copy(Z).multiplyScalar(X), H = J;
                    if (N !== e && (d.bindFramebuffer(36160, e), N = e), m.viewport(G), m.scissor(F), m.setScissorTest(H), n) {
                        var r = y.get(t.texture);
                        d.framebufferTexture2D(36160, 36064, 34069 + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, i, r, a) {
                    if (t && t.isWebGLRenderTarget) {
                        var o = y.get(t).__webglFramebuffer;
                        if (o) {
                            var s = !1;
                            o !== N && (d.bindFramebuffer(36160, o), s = !0);
                            try {
                                var c = t.texture,
                                    u = c.format,
                                    l = c.type;
                                if (u !== Ht && C.convert(u) !== d.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(l === Pt || C.convert(l) === d.getParameter(35738) || l === jt && (f.isWebGL2 || p.get("OES_texture_float") || p.get("WEBGL_color_buffer_float")) || l === Nt && (f.isWebGL2 ? p.get("EXT_color_buffer_float") : p.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === d.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && d.readPixels(e, n, i, r, C.convert(u), C.convert(l), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                s && d.bindFramebuffer(36160, N)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(t, e, n) {
                    var i = e.image.width,
                        r = e.image.height,
                        a = C.convert(e.format);
                    this.setTexture2D(e, 0), d.copyTexImage2D(3553, n || 0, a, t.x, t.y, i, r, 0)
                }, this.copyTextureToTexture = function(t, e, n, i) {
                    var r = e.image.width,
                        a = e.image.height,
                        o = C.convert(n.format),
                        s = C.convert(n.type);
                    this.setTexture2D(n, 0), e.isDataTexture ? d.texSubImage2D(3553, i || 0, t.x, t.y, r, a, o, s, e.image.data) : d.texSubImage2D(3553, i || 0, t.x, t.y, o, s, e.image)
                }
            }

            function oa(t, e) {
                this.name = "", this.color = new hn(t), this.density = void 0 !== e ? e : 25e-5
            }

            function sa(t, e, n) {
                this.name = "", this.color = new hn(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
            }

            function ca() {
                Sn.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }

            function ua(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function la(t, e, n, i) {
                this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }

            function ha(t) {
                si.call(this), this.type = "SpriteMaterial", this.color = new hn(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
            }

            function da(t) {
                if (Sn.call(this), this.type = "Sprite", void 0 === Yr) {
                    Yr = new Hn;
                    var e = new ua(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    Yr.setIndex([0, 1, 2, 0, 2, 3]), Yr.addAttribute("position", new la(e, 3, 0, !1)), Yr.addAttribute("uv", new la(e, 2, 3, !1))
                }
                this.geometry = Yr, this.material = void 0 !== t ? t : new ha, this.center = new je(.5, .5)
            }

            function pa() {
                Sn.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function fa(t, e) {
                t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), di.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ne, this.bindMatrixInverse = new Ne
            }

            function ma(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Ne)
                }
            }

            function va() {
                Sn.call(this), this.type = "Bone"
            }

            function ga(t) {
                si.call(this), this.type = "LineBasicMaterial", this.color = new hn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
            }

            function ya(t, e, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Sn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Hn, this.material = void 0 !== e ? e : new ga({
                    color: 16777215 * Math.random()
                })
            }

            function xa(t, e) {
                ya.call(this, t, e), this.type = "LineSegments"
            }

            function ba(t, e) {
                ya.call(this, t, e), this.type = "LineLoop"
            }

            function _a(t) {
                si.call(this), this.type = "PointsMaterial", this.color = new hn(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function wa(t, e) {
                Sn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Hn, this.material = void 0 !== e ? e : new _a({
                    color: 16777215 * Math.random()
                })
            }

            function Ma(t, e, n, i, r, a, o, s, c) {
                Xe.call(this, t, e, n, i, r, a, o, s, c), this.format = void 0 !== o ? o : Ft, this.minFilter = void 0 !== a ? a : Et, this.magFilter = void 0 !== r ? r : Et, this.generateMipmaps = !1
            }

            function Ta(t, e, n, i, r, a, o, s, c, u, l, h) {
                Xe.call(this, null, a, o, s, c, u, i, r, l, h), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function Sa(t, e, n, i, r, a, o, s, c) {
                Xe.call(this, t, e, n, i, r, a, o, s, c), this.needsUpdate = !0
            }

            function Ea(t, e, n, i, r, a, o, s, c, u) {
                if ((u = void 0 !== u ? u : qt) !== qt && u !== Xt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && u === qt && (n = Rt), void 0 === n && u === Xt && (n = Ut), Xe.call(this, null, i, r, a, o, s, u, n, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== o ? o : Mt, this.minFilter = void 0 !== s ? s : Mt, this.flipY = !1, this.generateMipmaps = !1
            }

            function Aa(t) {
                Hn.call(this), this.type = "WireframeGeometry";
                var e, n, i, r, a, o, s, c, u, l, h = [],
                    d = [0, 0],
                    p = {},
                    f = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    var m = t.faces;
                    for (e = 0, i = m.length; e < i; e++) {
                        var v = m[e];
                        for (n = 0; n < 3; n++) s = v[f[n]], c = v[f[(n + 1) % 3]], d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[u = d[0] + "," + d[1]] && (p[u] = {
                            index1: d[0],
                            index2: d[1]
                        })
                    }
                    for (u in p) o = p[u], l = t.vertices[o.index1], h.push(l.x, l.y, l.z), l = t.vertices[o.index2], h.push(l.x, l.y, l.z)
                } else if (t && t.isBufferGeometry) {
                    var g, y, x, b, _, w, M;
                    if (l = new ze, null !== t.index) {
                        for (g = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), r = 0, a = x.length; r < a; ++r)
                            for (e = _ = (b = x[r]).start, i = _ + b.count; e < i; e += 3)
                                for (n = 0; n < 3; n++) s = y.getX(e + n), c = y.getX(e + (n + 1) % 3), d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[u = d[0] + "," + d[1]] && (p[u] = {
                                    index1: d[0],
                                    index2: d[1]
                                });
                        for (u in p) o = p[u], l.fromBufferAttribute(g, o.index1), h.push(l.x, l.y, l.z), l.fromBufferAttribute(g, o.index2), h.push(l.x, l.y, l.z)
                    } else
                        for (e = 0, i = (g = t.attributes.position).count / 3; e < i; e++)
                            for (n = 0; n < 3; n++) w = 3 * e + n, l.fromBufferAttribute(g, w), h.push(l.x, l.y, l.z), M = 3 * e + (n + 1) % 3, l.fromBufferAttribute(g, M), h.push(l.x, l.y, l.z)
                }
                this.addAttribute("position", new zn(h, 3))
            }

            function La(t, e, n) {
                Pn.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                }, this.fromBufferGeometry(new Pa(t, e, n)), this.mergeVertices()
            }

            function Pa(t, e, n) {
                Hn.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                var i, r, a = [],
                    o = [],
                    s = [],
                    c = [],
                    u = new ze,
                    l = new ze,
                    h = new ze,
                    d = new ze,
                    p = new ze;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var f = e + 1;
                for (i = 0; i <= n; i++) {
                    var m = i / n;
                    for (r = 0; r <= e; r++) {
                        var v = r / e;
                        t(v, m, l), o.push(l.x, l.y, l.z), v - 1e-5 >= 0 ? (t(v - 1e-5, m, h), d.subVectors(l, h)) : (t(v + 1e-5, m, h), d.subVectors(h, l)), m - 1e-5 >= 0 ? (t(v, m - 1e-5, h), p.subVectors(l, h)) : (t(v, m + 1e-5, h), p.subVectors(h, l)), u.crossVectors(d, p).normalize(), s.push(u.x, u.y, u.z), c.push(v, m)
                    }
                }
                for (i = 0; i < n; i++)
                    for (r = 0; r < e; r++) {
                        var g = i * f + r,
                            y = i * f + r + 1,
                            x = (i + 1) * f + r + 1,
                            b = (i + 1) * f + r;
                        a.push(g, y, b), a.push(y, x, b)
                    }
                this.setIndex(a), this.addAttribute("position", new zn(o, 3)), this.addAttribute("normal", new zn(s, 3)), this.addAttribute("uv", new zn(c, 2))
            }

            function Oa(t, e, n, i) {
                Pn.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, this.fromBufferGeometry(new Ca(t, e, n, i)), this.mergeVertices()
            }

            function Ca(t, e, n, i) {
                Hn.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: i
                }, n = n || 1;
                var r = [],
                    a = [];

                function o(t, e, n, i) {
                    var r, a, o = Math.pow(2, i),
                        c = [];
                    for (r = 0; r <= o; r++) {
                        c[r] = [];
                        var u = t.clone().lerp(n, r / o),
                            l = e.clone().lerp(n, r / o),
                            h = o - r;
                        for (a = 0; a <= h; a++) c[r][a] = 0 === a && r === o ? u : u.clone().lerp(l, a / h)
                    }
                    for (r = 0; r < o; r++)
                        for (a = 0; a < 2 * (o - r) - 1; a++) {
                            var d = Math.floor(a / 2);
                            a % 2 == 0 ? (s(c[r][d + 1]), s(c[r + 1][d]), s(c[r][d])) : (s(c[r][d + 1]), s(c[r + 1][d + 1]), s(c[r + 1][d]))
                        }
                }

                function s(t) {
                    r.push(t.x, t.y, t.z)
                }

                function c(e, n) {
                    var i = 3 * e;
                    n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
                }

                function u(t, e, n, i) {
                    i < 0 && 1 === t.x && (a[e] = t.x - 1), 0 === n.x && 0 === n.z && (a[e] = i / 2 / Math.PI + .5)
                }

                function l(t) {
                    return Math.atan2(t.z, -t.x)
                }! function(t) {
                    for (var n = new ze, i = new ze, r = new ze, a = 0; a < e.length; a += 3) c(e[a + 0], n), c(e[a + 1], i), c(e[a + 2], r), o(n, i, r, t)
                }(i = i || 0),
                function(t) {
                    for (var e = new ze, n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
                }(n),
                function() {
                    for (var t = new ze, e = 0; e < r.length; e += 3) {
                        t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                        var n = l(t) / 2 / Math.PI + .5,
                            i = (o = t, Math.atan2(-o.y, Math.sqrt(o.x * o.x + o.z * o.z)) / Math.PI + .5);
                        a.push(n, 1 - i)
                    }
                    var o;
                    (function() {
                        for (var t = new ze, e = new ze, n = new ze, i = new ze, o = new je, s = new je, c = new je, h = 0, d = 0; h < r.length; h += 9, d += 6) {
                            t.set(r[h + 0], r[h + 1], r[h + 2]), e.set(r[h + 3], r[h + 4], r[h + 5]), n.set(r[h + 6], r[h + 7], r[h + 8]), o.set(a[d + 0], a[d + 1]), s.set(a[d + 2], a[d + 3]), c.set(a[d + 4], a[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                            var p = l(i);
                            u(o, d + 0, t, p), u(s, d + 2, e, p), u(c, d + 4, n, p)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < a.length; t += 6) {
                            var e = a[t + 0],
                                n = a[t + 2],
                                i = a[t + 4],
                                r = Math.max(e, n, i),
                                o = Math.min(e, n, i);
                            r > .9 && o < .1 && (e < .2 && (a[t + 0] += 1), n < .2 && (a[t + 2] += 1), i < .2 && (a[t + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new zn(r, 3)), this.addAttribute("normal", new zn(r.slice(), 3)), this.addAttribute("uv", new zn(a, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function Ra(t, e) {
                Pn.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Ia(t, e)), this.mergeVertices()
            }

            function Ia(t, e) {
                Ca.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Da(t, e) {
                Pn.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new ja(t, e)), this.mergeVertices()
            }

            function ja(t, e) {
                Ca.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Na(t, e) {
                Pn.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new ka(t, e)), this.mergeVertices()
            }

            function ka(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                Ca.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function za(t, e) {
                Pn.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Ba(t, e)), this.mergeVertices()
            }

            function Ba(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
                Ca.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Ua(t, e, n, i, r, a) {
                Pn.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
                var o = new Ga(t, e, n, i, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
            }

            function Ga(t, e, n, i, r) {
                Hn.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, e = e || 64, n = n || 1, i = i || 8, r = r || !1;
                var a = t.computeFrenetFrames(e, r);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
                var o, s, c = new ze,
                    u = new ze,
                    l = new je,
                    h = new ze,
                    d = [],
                    p = [],
                    f = [],
                    m = [];

                function v(r) {
                    h = t.getPointAt(r / e, h);
                    var o = a.normals[r],
                        l = a.binormals[r];
                    for (s = 0; s <= i; s++) {
                        var f = s / i * Math.PI * 2,
                            m = Math.sin(f),
                            v = -Math.cos(f);
                        u.x = v * o.x + m * l.x, u.y = v * o.y + m * l.y, u.z = v * o.z + m * l.z, u.normalize(), p.push(u.x, u.y, u.z), c.x = h.x + n * u.x, c.y = h.y + n * u.y, c.z = h.z + n * u.z, d.push(c.x, c.y, c.z)
                    }
                }! function() {
                    for (o = 0; o < e; o++) v(o);
                    v(!1 === r ? e : 0),
                        function() {
                            for (o = 0; o <= e; o++)
                                for (s = 0; s <= i; s++) l.x = o / e, l.y = s / i, f.push(l.x, l.y)
                        }(),
                        function() {
                            for (s = 1; s <= e; s++)
                                for (o = 1; o <= i; o++) {
                                    var t = (i + 1) * (s - 1) + (o - 1),
                                        n = (i + 1) * s + (o - 1),
                                        r = (i + 1) * s + o,
                                        a = (i + 1) * (s - 1) + o;
                                    m.push(t, n, a), m.push(n, r, a)
                                }
                        }()
                }(), this.setIndex(m), this.addAttribute("position", new zn(d, 3)), this.addAttribute("normal", new zn(p, 3)), this.addAttribute("uv", new zn(f, 2))
            }

            function Fa(t, e, n, i, r, a, o) {
                Pn.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: a
                }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Ha(t, e, n, i, r, a)), this.mergeVertices()
            }

            function Ha(t, e, n, i, r, a) {
                Hn.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: a
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, a = a || 3;
                var o, s, c = [],
                    u = [],
                    l = [],
                    h = [],
                    d = new ze,
                    p = new ze,
                    f = new ze,
                    m = new ze,
                    v = new ze,
                    g = new ze,
                    y = new ze;
                for (o = 0; o <= n; ++o) {
                    var x = o / n * r * Math.PI * 2;
                    for (A(x, r, a, t, f), A(x + .01, r, a, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= i; ++s) {
                        var b = s / i * Math.PI * 2,
                            _ = -e * Math.cos(b),
                            w = e * Math.sin(b);
                        d.x = f.x + (_ * y.x + w * v.x), d.y = f.y + (_ * y.y + w * v.y), d.z = f.z + (_ * y.z + w * v.z), u.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), l.push(p.x, p.y, p.z), h.push(o / n), h.push(s / i)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (o = 1; o <= i; o++) {
                        var M = (i + 1) * (s - 1) + (o - 1),
                            T = (i + 1) * s + (o - 1),
                            S = (i + 1) * s + o,
                            E = (i + 1) * (s - 1) + o;
                        c.push(M, T, E), c.push(T, S, E)
                    }

                function A(t, e, n, i, r) {
                    var a = Math.cos(t),
                        o = Math.sin(t),
                        s = n / e * t,
                        c = Math.cos(s);
                    r.x = i * (2 + c) * .5 * a, r.y = i * (2 + c) * o * .5, r.z = i * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new zn(u, 3)), this.addAttribute("normal", new zn(l, 3)), this.addAttribute("uv", new zn(h, 2))
            }

            function Va(t, e, n, i, r) {
                Pn.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, this.fromBufferGeometry(new Wa(t, e, n, i, r)), this.mergeVertices()
            }

            function Wa(t, e, n, i, r) {
                Hn.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
                var a, o, s = [],
                    c = [],
                    u = [],
                    l = [],
                    h = new ze,
                    d = new ze,
                    p = new ze;
                for (a = 0; a <= n; a++)
                    for (o = 0; o <= i; o++) {
                        var f = o / i * r,
                            m = a / n * Math.PI * 2;
                        d.x = (t + e * Math.cos(m)) * Math.cos(f), d.y = (t + e * Math.cos(m)) * Math.sin(f), d.z = e * Math.sin(m), c.push(d.x, d.y, d.z), h.x = t * Math.cos(f), h.y = t * Math.sin(f), p.subVectors(d, h).normalize(), u.push(p.x, p.y, p.z), l.push(o / i), l.push(a / n)
                    }
                for (a = 1; a <= n; a++)
                    for (o = 1; o <= i; o++) {
                        var v = (i + 1) * a + o - 1,
                            g = (i + 1) * (a - 1) + o - 1,
                            y = (i + 1) * (a - 1) + o,
                            x = (i + 1) * a + o;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                this.setIndex(s), this.addAttribute("position", new zn(c, 3)), this.addAttribute("normal", new zn(u, 3)), this.addAttribute("uv", new zn(l, 2))
            }
            oa.prototype.isFogExp2 = !0, oa.prototype.clone = function() {
                return new oa(this.color, this.density)
            }, oa.prototype.toJSON = function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }, sa.prototype.isFog = !0, sa.prototype.clone = function() {
                return new sa(this.color, this.near, this.far)
            }, sa.prototype.toJSON = function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, ca.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: ca,
                isScene: !0,
                copy: function(t, e) {
                    return Sn.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                },
                toJSON: function(t) {
                    var e = Sn.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(ua.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(ua.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (var i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                }
            }), Object.defineProperties(la.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(la.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
                }
            }), ha.prototype = Object.create(si.prototype), ha.prototype.constructor = ha, ha.prototype.isSpriteMaterial = !0, ha.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            }, da.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: da,
                isSprite: !0,
                raycast: function() {
                    var t = new ze,
                        e = new ze,
                        n = new ze,
                        i = new je,
                        r = new je,
                        a = new Ne,
                        o = new ze,
                        s = new ze,
                        c = new ze,
                        u = new je,
                        l = new je,
                        h = new je;

                    function d(t, e, n, o, s, c) {
                        i.subVectors(t, n).addScalar(.5).multiply(o), void 0 !== s ? (r.x = c * i.x - s * i.y, r.y = s * i.x + c * i.y) : r.copy(i), t.copy(e), t.x += r.x, t.y += r.y, t.applyMatrix4(a)
                    }
                    return function(i, r) {
                        e.setFromMatrixScale(this.matrixWorld), a.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
                        var p, f, m = this.material.rotation;
                        0 !== m && (f = Math.cos(m), p = Math.sin(m));
                        var v = this.center;
                        d(o.set(-.5, -.5, 0), n, v, e, p, f), d(s.set(.5, -.5, 0), n, v, e, p, f), d(c.set(.5, .5, 0), n, v, e, p, f), u.set(0, 0), l.set(1, 0), h.set(1, 1);
                        var g = i.ray.intersectTriangle(o, s, c, !1, t);
                        if (null !== g || (d(s.set(-.5, .5, 0), n, v, e, p, f), l.set(0, 1), null !== (g = i.ray.intersectTriangle(o, c, s, !1, t)))) {
                            var y = i.ray.origin.distanceTo(t);
                            y < i.near || y > i.far || r.push({
                                distance: y,
                                point: t.clone(),
                                uv: li.getUV(t, o, s, c, u, l, h, new je),
                                face: null,
                                object: this
                            })
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(t) {
                    return Sn.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
                }
            }), pa.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: pa,
                copy: function(t) {
                    Sn.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++);
                    n.splice(i, 0, {
                        distance: e,
                        object: t
                    }), this.add(t)
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                    return e[n - 1].object
                },
                raycast: (Zr = new ze, function(t, e) {
                    Zr.setFromMatrixPosition(this.matrixWorld);
                    var n = t.ray.origin.distanceTo(Zr);
                    this.getObjectForDistance(n).raycast(t, e)
                }),
                update: function() {
                    var t = new ze,
                        e = new ze;
                    return function(n) {
                        var i = this.levels;
                        if (i.length > 1) {
                            t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                            var r = t.distanceTo(e);
                            i[0].object.visible = !0;
                            for (var a = 1, o = i.length; a < o && r >= i[a].distance; a++) i[a - 1].object.visible = !1, i[a].object.visible = !0;
                            for (; a < o; a++) i[a].object.visible = !1
                        }
                    }
                }(),
                toJSON: function(t) {
                    var e = Sn.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        e.object.levels.push({
                            object: a.object.uuid,
                            distance: a.distance
                        })
                    }
                    return e
                }
            }), fa.prototype = Object.assign(Object.create(di.prototype), {
                constructor: fa,
                isSkinnedMesh: !0,
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    for (var t = new Ye, e = this.geometry.attributes.skinWeight, n = 0, i = e.count; n < i; n++) {
                        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                        var r = 1 / t.manhattanLength();
                        r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    di.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Object.assign(ma.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var n = new Ne;
                        this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function() {
                    var t, e, n;
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: (Jr = new Ne, Kr = new Ne, function() {
                    for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, a = t.length; r < a; r++) {
                        var o = t[r] ? t[r].matrixWorld : Kr;
                        Jr.multiplyMatrices(o, e[r]), Jr.toArray(n, 16 * r)
                    }
                    void 0 !== i && (i.needsUpdate = !0)
                }),
                clone: function() {
                    return new ma(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (var e = 0, n = this.bones.length; e < n; e++) {
                        var i = this.bones[e];
                        if (i.name === t) return i
                    }
                }
            }), va.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: va,
                isBone: !0
            }), ga.prototype = Object.create(si.prototype), ga.prototype.constructor = ga, ga.prototype.isLineBasicMaterial = !0, ga.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }, ya.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: ya,
                isLine: !0,
                computeLineDistances: (Qr = new ze, $r = new ze, function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            for (var e = t.attributes.position, n = [0], i = 1, r = e.count; i < r; i++) Qr.fromBufferAttribute(e, i - 1), $r.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += Qr.distanceTo($r);
                            t.addAttribute("lineDistance", new zn(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (t.isGeometry) {
                        var a = t.vertices;
                        for ((n = t.lineDistances)[0] = 0, i = 1, r = a.length; i < r; i++) n[i] = n[i - 1], n[i] += a[i - 1].distanceTo(a[i])
                    }
                    return this
                }),
                raycast: function() {
                    var t = new Ne,
                        e = new ui,
                        n = new tn;
                    return function(i, r) {
                        var a = i.linePrecision,
                            o = this.geometry,
                            s = this.matrixWorld;
                        if (null === o.boundingSphere && o.computeBoundingSphere(), n.copy(o.boundingSphere), n.applyMatrix4(s), n.radius += a, !1 !== i.ray.intersectsSphere(n)) {
                            t.getInverse(s), e.copy(i.ray).applyMatrix4(t);
                            var c = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                u = c * c,
                                l = new ze,
                                h = new ze,
                                d = new ze,
                                p = new ze,
                                f = this && this.isLineSegments ? 2 : 1;
                            if (o.isBufferGeometry) {
                                var m = o.index,
                                    v = o.attributes.position.array;
                                if (null !== m)
                                    for (var g = m.array, y = 0, x = g.length - 1; y < x; y += f) {
                                        var b = g[y],
                                            _ = g[y + 1];
                                        if (l.fromArray(v, 3 * b), h.fromArray(v, 3 * _), !(e.distanceSqToSegment(l, h, p, d) > u)) p.applyMatrix4(this.matrixWorld), (T = i.ray.origin.distanceTo(p)) < i.near || T > i.far || r.push({
                                            distance: T,
                                            point: d.clone().applyMatrix4(this.matrixWorld),
                                            index: y,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    } else
                                        for (y = 0, x = v.length / 3 - 1; y < x; y += f) {
                                            if (l.fromArray(v, 3 * y), h.fromArray(v, 3 * y + 3), !(e.distanceSqToSegment(l, h, p, d) > u)) p.applyMatrix4(this.matrixWorld), (T = i.ray.origin.distanceTo(p)) < i.near || T > i.far || r.push({
                                                distance: T,
                                                point: d.clone().applyMatrix4(this.matrixWorld),
                                                index: y,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                            } else if (o.isGeometry) {
                                var w = o.vertices,
                                    M = w.length;
                                for (y = 0; y < M - 1; y += f) {
                                    var T;
                                    if (!(e.distanceSqToSegment(w[y], w[y + 1], p, d) > u)) p.applyMatrix4(this.matrixWorld), (T = i.ray.origin.distanceTo(p)) < i.near || T > i.far || r.push({
                                        distance: T,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                        }
                    }
                }(),
                copy: function(t) {
                    return Sn.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), xa.prototype = Object.assign(Object.create(ya.prototype), {
                constructor: xa,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var t = new ze,
                        e = new ze;
                    return function() {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var i = n.attributes.position, r = [], a = 0, o = i.count; a < o; a += 2) t.fromBufferAttribute(i, a), e.fromBufferAttribute(i, a + 1), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + t.distanceTo(e);
                                n.addAttribute("lineDistance", new zn(r, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry) {
                            var s = n.vertices;
                            for (r = n.lineDistances, a = 0, o = s.length; a < o; a += 2) t.copy(s[a]), e.copy(s[a + 1]), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + t.distanceTo(e)
                        }
                        return this
                    }
                }()
            }), ba.prototype = Object.assign(Object.create(ya.prototype), {
                constructor: ba,
                isLineLoop: !0
            }), _a.prototype = Object.create(si.prototype), _a.prototype.constructor = _a, _a.prototype.isPointsMaterial = !0, _a.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            }, wa.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: wa,
                isPoints: !0,
                raycast: function() {
                    var t = new Ne,
                        e = new ui,
                        n = new tn;
                    return function(i, r) {
                        var a = this,
                            o = this.geometry,
                            s = this.matrixWorld,
                            c = i.params.Points.threshold;
                        if (null === o.boundingSphere && o.computeBoundingSphere(), n.copy(o.boundingSphere), n.applyMatrix4(s), n.radius += c, !1 !== i.ray.intersectsSphere(n)) {
                            t.getInverse(s), e.copy(i.ray).applyMatrix4(t);
                            var u = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                l = u * u,
                                h = new ze,
                                d = new ze;
                            if (o.isBufferGeometry) {
                                var p = o.index,
                                    f = o.attributes.position.array;
                                if (null !== p)
                                    for (var m = p.array, v = 0, g = m.length; v < g; v++) {
                                        var y = m[v];
                                        h.fromArray(f, 3 * y), _(h, y)
                                    } else {
                                        v = 0;
                                        for (var x = f.length / 3; v < x; v++) h.fromArray(f, 3 * v), _(h, v)
                                    }
                            } else {
                                var b = o.vertices;
                                for (v = 0, x = b.length; v < x; v++) _(b[v], v)
                            }
                        }

                        function _(t, n) {
                            var o = e.distanceSqToPoint(t);
                            if (o < l) {
                                e.closestPointToPoint(t, d), d.applyMatrix4(s);
                                var c = i.ray.origin.distanceTo(d);
                                if (c < i.near || c > i.far) return;
                                r.push({
                                    distance: c,
                                    distanceToRay: Math.sqrt(o),
                                    point: d.clone(),
                                    index: n,
                                    face: null,
                                    object: a
                                })
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Ma.prototype = Object.assign(Object.create(Xe.prototype), {
                constructor: Ma,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), Ta.prototype = Object.create(Xe.prototype), Ta.prototype.constructor = Ta, Ta.prototype.isCompressedTexture = !0, Sa.prototype = Object.create(Xe.prototype), Sa.prototype.constructor = Sa, Sa.prototype.isCanvasTexture = !0, Ea.prototype = Object.create(Xe.prototype), Ea.prototype.constructor = Ea, Ea.prototype.isDepthTexture = !0, Aa.prototype = Object.create(Hn.prototype), Aa.prototype.constructor = Aa, La.prototype = Object.create(Pn.prototype), La.prototype.constructor = La, Pa.prototype = Object.create(Hn.prototype), Pa.prototype.constructor = Pa, Oa.prototype = Object.create(Pn.prototype), Oa.prototype.constructor = Oa, Ca.prototype = Object.create(Hn.prototype), Ca.prototype.constructor = Ca, Ra.prototype = Object.create(Pn.prototype), Ra.prototype.constructor = Ra, Ia.prototype = Object.create(Ca.prototype), Ia.prototype.constructor = Ia, Da.prototype = Object.create(Pn.prototype), Da.prototype.constructor = Da, ja.prototype = Object.create(Ca.prototype), ja.prototype.constructor = ja, Na.prototype = Object.create(Pn.prototype), Na.prototype.constructor = Na, ka.prototype = Object.create(Ca.prototype), ka.prototype.constructor = ka, za.prototype = Object.create(Pn.prototype), za.prototype.constructor = za, Ba.prototype = Object.create(Ca.prototype), Ba.prototype.constructor = Ba, Ua.prototype = Object.create(Pn.prototype), Ua.prototype.constructor = Ua, Ga.prototype = Object.create(Hn.prototype), Ga.prototype.constructor = Ga, Fa.prototype = Object.create(Pn.prototype), Fa.prototype.constructor = Fa, Ha.prototype = Object.create(Hn.prototype), Ha.prototype.constructor = Ha, Va.prototype = Object.create(Pn.prototype), Va.prototype.constructor = Va, Wa.prototype = Object.create(Hn.prototype), Wa.prototype.constructor = Wa;
            var qa = function(t, e, n) {
                n = n || 2;
                var i, r, a, o, s, c, u, l = e && e.length,
                    h = l ? e[0] * n : t.length,
                    d = Xa(t, 0, h, n, !0),
                    p = [];
                if (!d) return p;
                if (l && (d = function(t, e, n, i) {
                        var r, a, o, s, c, u = [];
                        for (r = 0, a = e.length; r < a; r++) o = e[r] * i, s = r < a - 1 ? e[r + 1] * i : t.length, (c = Xa(t, o, s, i, !1)) === c.next && (c.steiner = !0), u.push(io(c));
                        for (u.sort(to), r = 0; r < u.length; r++) eo(u[r], n), n = Ya(n, n.next);
                        return n
                    }(t, e, d, n)), t.length > 80 * n) {
                    i = a = t[0], r = o = t[1];
                    for (var f = n; f < h; f += n)(s = t[f]) < i && (i = s), (c = t[f + 1]) < r && (r = c), s > a && (a = s), c > o && (o = c);
                    u = 0 !== (u = Math.max(a - i, o - r)) ? 1 / u : 0
                }
                return Za(d, p, n, i, r, u), p
            };

            function Xa(t, e, n, i, r) {
                var a, o;
                if (r === function(t, e, n, i) {
                        for (var r = 0, a = e, o = n - i; a < n; a += i) r += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;
                        return r
                    }(t, e, n, i) > 0)
                    for (a = e; a < n; a += i) o = ho(a, t[a], t[a + 1], o);
                else
                    for (a = n - i; a >= e; a -= i) o = ho(a, t[a], t[a + 1], o);
                return o && so(o, o.next) && (po(o), o = o.next), o
            }

            function Ya(t, e) {
                if (!t) return t;
                e || (e = t);
                var n, i = t;
                do {
                    if (n = !1, i.steiner || !so(i, i.next) && 0 !== oo(i.prev, i, i.next)) i = i.next;
                    else {
                        if (po(i), (i = e = i.prev) === i.next) break;
                        n = !0
                    }
                } while (n || i !== e);
                return e
            }

            function Za(t, e, n, i, r, a, o) {
                if (t) {
                    !o && a && function(t, e, n, i) {
                        var r = t;
                        do {
                            null === r.z && (r.z = no(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                var e, n, i, r, a, o, s, c, u = 1;
                                do {
                                    for (n = t, t = null, a = null, o = 0; n;) {
                                        for (o++, i = n, s = 0, e = 0; e < u && (s++, i = i.nextZ); e++);
                                        for (c = u; s > 0 || c > 0 && i;) 0 !== s && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, c--), a ? a.nextZ = r : t = r, r.prevZ = a, a = r;
                                        n = i
                                    }
                                    a.nextZ = null, u *= 2
                                } while (o > 1)
                            }(r)
                    }(t, i, r, a);
                    for (var s, c, u = t; t.prev !== t.next;)
                        if (s = t.prev, c = t.next, a ? Ka(t, i, r, a) : Ja(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), po(t), t = c.next, u = c.next;
                        else if ((t = c) === u) {
                        o ? 1 === o ? Za(t = Qa(t, e, n), e, n, i, r, a, 2) : 2 === o && $a(t, e, n, i, r, a) : Za(Ya(t), e, n, i, r, a, 1);
                        break
                    }
                }
            }

            function Ja(t) {
                var e = t.prev,
                    n = t,
                    i = t.next;
                if (oo(e, n, i) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev;) {
                    if (ro(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && oo(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function Ka(t, e, n, i) {
                var r = t.prev,
                    a = t,
                    o = t.next;
                if (oo(r, a, o) >= 0) return !1;
                for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, c = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, u = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, l = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, h = no(s, c, e, n, i), d = no(u, l, e, n, i), p = t.nextZ; p && p.z <= d;) {
                    if (p !== t.prev && p !== t.next && ro(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && oo(p.prev, p, p.next) >= 0) return !1;
                    p = p.nextZ
                }
                for (p = t.prevZ; p && p.z >= h;) {
                    if (p !== t.prev && p !== t.next && ro(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && oo(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                return !0
            }

            function Qa(t, e, n) {
                var i = t;
                do {
                    var r = i.prev,
                        a = i.next.next;
                    !so(r, a) && co(r, i, i.next, a) && uo(r, a) && uo(a, r) && (e.push(r.i / n), e.push(i.i / n), e.push(a.i / n), po(i), po(i.next), i = t = a), i = i.next
                } while (i !== t);
                return i
            }

            function $a(t, e, n, i, r, a) {
                var o = t;
                do {
                    for (var s = o.next.next; s !== o.prev;) {
                        if (o.i !== s.i && ao(o, s)) {
                            var c = lo(o, s);
                            return o = Ya(o, o.next), c = Ya(c, c.next), Za(o, e, n, i, r, a), void Za(c, e, n, i, r, a)
                        }
                        s = s.next
                    }
                    o = o.next
                } while (o !== t)
            }

            function to(t, e) {
                return t.x - e.x
            }

            function eo(t, e) {
                if (e = function(t, e) {
                        var n, i = e,
                            r = t.x,
                            a = t.y,
                            o = -1 / 0;
                        do {
                            if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                                var s = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (s <= r && s > o) {
                                    if (o = s, s === r) {
                                        if (a === i.y) return i;
                                        if (a === i.next.y) return i.next
                                    }
                                    n = i.x < i.next.x ? i : i.next
                                }
                            }
                            i = i.next
                        } while (i !== e);
                        if (!n) return null;
                        if (r === o) return n.prev;
                        var c, u = n,
                            l = n.x,
                            h = n.y,
                            d = 1 / 0;
                        i = n.next;
                        for (; i !== u;) r >= i.x && i.x >= l && r !== i.x && ro(a < h ? r : o, a, l, h, a < h ? o : r, a, i.x, i.y) && ((c = Math.abs(a - i.y) / (r - i.x)) < d || c === d && i.x > n.x) && uo(i, t) && (n = i, d = c), i = i.next;
                        return n
                    }(t, e)) {
                    var n = lo(e, t);
                    Ya(n, n.next)
                }
            }

            function no(t, e, n, i, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function io(t) {
                var e = t,
                    n = t;
                do {
                    e.x < n.x && (n = e), e = e.next
                } while (e !== t);
                return n
            }

            function ro(t, e, n, i, r, a, o, s) {
                return (r - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (i - s) - (n - o) * (e - s) >= 0 && (n - o) * (a - s) - (r - o) * (i - s) >= 0
            }

            function ao(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    var n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && co(n, n.next, t, e)) return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(t, e) && uo(t, e) && uo(e, t) && function(t, e) {
                    var n = t,
                        i = !1,
                        r = (t.x + e.x) / 2,
                        a = (t.y + e.y) / 2;
                    do {
                        n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== t);
                    return i
                }(t, e)
            }

            function oo(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }

            function so(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function co(t, e, n, i) {
                return !!(so(t, e) && so(n, i) || so(t, i) && so(n, e)) || oo(t, e, n) > 0 != oo(t, e, i) > 0 && oo(n, i, t) > 0 != oo(n, i, e) > 0
            }

            function uo(t, e) {
                return oo(t.prev, t, t.next) < 0 ? oo(t, e, t.next) >= 0 && oo(t, t.prev, e) >= 0 : oo(t, e, t.prev) < 0 || oo(t, t.next, e) < 0
            }

            function lo(t, e) {
                var n = new fo(t.i, t.x, t.y),
                    i = new fo(e.i, e.x, e.y),
                    r = t.next,
                    a = e.prev;
                return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i
            }

            function ho(t, e, n, i) {
                var r = new fo(t, e, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function po(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function fo(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var mo = {
                area: function(t) {
                    for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return mo.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var n = [],
                        i = [],
                        r = [];
                    vo(t), go(n, t);
                    var a = t.length;
                    e.forEach(vo);
                    for (var o = 0; o < e.length; o++) i.push(a), a += e[o].length, go(n, e[o]);
                    var s = qa(n, i);
                    for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
                    return r
                }
            };

            function vo(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function go(t, e) {
                for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
            }

            function yo(t, e) {
                Pn.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new xo(t, e)), this.mergeVertices()
            }

            function xo(t, e) {
                Hn.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, t = Array.isArray(t) ? t : [t];
                for (var n = this, i = [], r = [], a = 0, o = t.length; a < o; a++) {
                    s(t[a])
                }

                function s(t) {
                    var a = [],
                        o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        s = void 0 !== e.steps ? e.steps : 1,
                        c = void 0 !== e.depth ? e.depth : 100,
                        u = void 0 === e.bevelEnabled || e.bevelEnabled,
                        l = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        h = void 0 !== e.bevelSize ? e.bevelSize : l - 2,
                        d = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                        p = e.extrudePath,
                        f = void 0 !== e.UVGenerator ? e.UVGenerator : bo;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                    var m, v, g, y, x, b, _, w, M = !1;
                    p && (m = p.getSpacedPoints(s), M = !0, u = !1, v = p.computeFrenetFrames(s, !1), g = new ze, y = new ze, x = new ze), u || (d = 0, l = 0, h = 0);
                    var T = t.extractPoints(o),
                        S = T.shape,
                        E = T.holes;
                    if (!mo.isClockWise(S))
                        for (S = S.reverse(), _ = 0, w = E.length; _ < w; _++) b = E[_], mo.isClockWise(b) && (E[_] = b.reverse());
                    var A = mo.triangulateShape(S, E),
                        L = S;
                    for (_ = 0, w = E.length; _ < w; _++) b = E[_], S = S.concat(b);

                    function P(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                    }
                    var O, C, R, I, D, j, N = S.length,
                        k = A.length;

                    function z(t, e, n) {
                        var i, r, a, o = t.x - e.x,
                            s = t.y - e.y,
                            c = n.x - t.x,
                            u = n.y - t.y,
                            l = o * o + s * s,
                            h = o * u - s * c;
                        if (Math.abs(h) > Number.EPSILON) {
                            var d = Math.sqrt(l),
                                p = Math.sqrt(c * c + u * u),
                                f = e.x - s / d,
                                m = e.y + o / d,
                                v = ((n.x - u / p - f) * u - (n.y + c / p - m) * c) / (o * u - s * c),
                                g = (i = f + o * v - t.x) * i + (r = m + s * v - t.y) * r;
                            if (g <= 2) return new je(i, r);
                            a = Math.sqrt(g / 2)
                        } else {
                            var y = !1;
                            o > Number.EPSILON ? c > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(u) && (y = !0), y ? (i = -s, r = o, a = Math.sqrt(l)) : (i = o, r = s, a = Math.sqrt(l / 2))
                        }
                        return new je(i / a, r / a)
                    }
                    for (var B = [], U = 0, G = L.length, F = G - 1, H = U + 1; U < G; U++, F++, H++) F === G && (F = 0), H === G && (H = 0), B[U] = z(L[U], L[F], L[H]);
                    var V, W, q = [],
                        X = B.concat();
                    for (_ = 0, w = E.length; _ < w; _++) {
                        for (b = E[_], V = [], U = 0, F = (G = b.length) - 1, H = U + 1; U < G; U++, F++, H++) F === G && (F = 0), H === G && (H = 0), V[U] = z(b[U], b[F], b[H]);
                        q.push(V), X = X.concat(V)
                    }
                    for (O = 0; O < d; O++) {
                        for (R = O / d, I = l * Math.cos(R * Math.PI / 2), C = h * Math.sin(R * Math.PI / 2), U = 0, G = L.length; U < G; U++) Z((D = P(L[U], B[U], C)).x, D.y, -I);
                        for (_ = 0, w = E.length; _ < w; _++)
                            for (b = E[_], V = q[_], U = 0, G = b.length; U < G; U++) Z((D = P(b[U], V[U], C)).x, D.y, -I)
                    }
                    for (C = h, U = 0; U < N; U++) D = u ? P(S[U], X[U], C) : S[U], M ? (y.copy(v.normals[0]).multiplyScalar(D.x), g.copy(v.binormals[0]).multiplyScalar(D.y), x.copy(m[0]).add(y).add(g), Z(x.x, x.y, x.z)) : Z(D.x, D.y, 0);
                    for (W = 1; W <= s; W++)
                        for (U = 0; U < N; U++) D = u ? P(S[U], X[U], C) : S[U], M ? (y.copy(v.normals[W]).multiplyScalar(D.x), g.copy(v.binormals[W]).multiplyScalar(D.y), x.copy(m[W]).add(y).add(g), Z(x.x, x.y, x.z)) : Z(D.x, D.y, c / s * W);
                    for (O = d - 1; O >= 0; O--) {
                        for (R = O / d, I = l * Math.cos(R * Math.PI / 2), C = h * Math.sin(R * Math.PI / 2), U = 0, G = L.length; U < G; U++) Z((D = P(L[U], B[U], C)).x, D.y, c + I);
                        for (_ = 0, w = E.length; _ < w; _++)
                            for (b = E[_], V = q[_], U = 0, G = b.length; U < G; U++) D = P(b[U], V[U], C), M ? Z(D.x, D.y + m[s - 1].y, m[s - 1].x + I) : Z(D.x, D.y, c + I)
                    }

                    function Y(t, e) {
                        var n, i;
                        for (U = t.length; --U >= 0;) {
                            n = U, (i = U - 1) < 0 && (i = t.length - 1);
                            var r = 0,
                                a = s + 2 * d;
                            for (r = 0; r < a; r++) {
                                var o = N * r,
                                    c = N * (r + 1);
                                K(e + n + o, e + i + o, e + i + c, e + n + c)
                            }
                        }
                    }

                    function Z(t, e, n) {
                        a.push(t), a.push(e), a.push(n)
                    }

                    function J(t, e, r) {
                        Q(t), Q(e), Q(r);
                        var a = i.length / 3,
                            o = f.generateTopUV(n, i, a - 3, a - 2, a - 1);
                        $(o[0]), $(o[1]), $(o[2])
                    }

                    function K(t, e, r, a) {
                        Q(t), Q(e), Q(a), Q(e), Q(r), Q(a);
                        var o = i.length / 3,
                            s = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                        $(s[0]), $(s[1]), $(s[3]), $(s[1]), $(s[2]), $(s[3])
                    }

                    function Q(t) {
                        i.push(a[3 * t + 0]), i.push(a[3 * t + 1]), i.push(a[3 * t + 2])
                    }

                    function $(t) {
                        r.push(t.x), r.push(t.y)
                    }! function() {
                        var t = i.length / 3;
                        if (u) {
                            var e = 0,
                                r = N * e;
                            for (U = 0; U < k; U++) J((j = A[U])[2] + r, j[1] + r, j[0] + r);
                            for (r = N * (e = s + 2 * d), U = 0; U < k; U++) J((j = A[U])[0] + r, j[1] + r, j[2] + r)
                        } else {
                            for (U = 0; U < k; U++) J((j = A[U])[2], j[1], j[0]);
                            for (U = 0; U < k; U++) J((j = A[U])[0] + N * s, j[1] + N * s, j[2] + N * s)
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }(),
                    function() {
                        var t = i.length / 3,
                            e = 0;
                        for (Y(L, e), e += L.length, _ = 0, w = E.length; _ < w; _++) Y(b = E[_], e), e += b.length;
                        n.addGroup(t, i.length / 3 - t, 1)
                    }()
                }
                this.addAttribute("position", new zn(i, 3)), this.addAttribute("uv", new zn(r, 2)), this.computeVertexNormals()
            }
            yo.prototype = Object.create(Pn.prototype), yo.prototype.constructor = yo, yo.prototype.toJSON = function() {
                var t = Pn.prototype.toJSON.call(this);
                return _o(this.parameters.shapes, this.parameters.options, t)
            }, xo.prototype = Object.create(Hn.prototype), xo.prototype.constructor = xo, xo.prototype.toJSON = function() {
                var t = Hn.prototype.toJSON.call(this);
                return _o(this.parameters.shapes, this.parameters.options, t)
            };
            var bo = {
                generateTopUV: function(t, e, n, i, r) {
                    var a = e[3 * n],
                        o = e[3 * n + 1],
                        s = e[3 * i],
                        c = e[3 * i + 1],
                        u = e[3 * r],
                        l = e[3 * r + 1];
                    return [new je(a, o), new je(s, c), new je(u, l)]
                },
                generateSideWallUV: function(t, e, n, i, r, a) {
                    var o = e[3 * n],
                        s = e[3 * n + 1],
                        c = e[3 * n + 2],
                        u = e[3 * i],
                        l = e[3 * i + 1],
                        h = e[3 * i + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * a],
                        v = e[3 * a + 1],
                        g = e[3 * a + 2];
                    return Math.abs(s - l) < .01 ? [new je(o, 1 - c), new je(u, 1 - h), new je(d, 1 - f), new je(m, 1 - g)] : [new je(s, 1 - c), new je(l, 1 - h), new je(p, 1 - f), new je(v, 1 - g)]
                }
            };

            function _o(t, e, n) {
                if (n.shapes = [], Array.isArray(t))
                    for (var i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        n.shapes.push(a.uuid)
                    } else n.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
            }

            function wo(t, e) {
                Pn.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new Mo(t, e)), this.mergeVertices()
            }

            function Mo(t, e) {
                var n = (e = e || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Pn;
                var i = n.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), xo.call(this, i, e), this.type = "TextBufferGeometry"
            }

            function To(t, e, n, i, r, a, o) {
                Pn.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: o
                }, this.fromBufferGeometry(new So(t, e, n, i, r, a, o)), this.mergeVertices()
            }

            function So(t, e, n, i, r, a, o) {
                Hn.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: o
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var s, c, u = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI),
                    l = 0,
                    h = [],
                    d = new ze,
                    p = new ze,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (c = 0; c <= n; c++) {
                    var y = [],
                        x = c / n;
                    for (s = 0; s <= e; s++) {
                        var b = s / e;
                        d.x = -t * Math.cos(i + b * r) * Math.sin(a + x * o), d.y = t * Math.cos(a + x * o), d.z = t * Math.sin(i + b * r) * Math.sin(a + x * o), m.push(d.x, d.y, d.z), p.set(d.x, d.y, d.z).normalize(), v.push(p.x, p.y, p.z), g.push(b, 1 - x), y.push(l++)
                    }
                    h.push(y)
                }
                for (c = 0; c < n; c++)
                    for (s = 0; s < e; s++) {
                        var _ = h[c][s + 1],
                            w = h[c][s],
                            M = h[c + 1][s],
                            T = h[c + 1][s + 1];
                        (0 !== c || a > 0) && f.push(_, w, T), (c !== n - 1 || u < Math.PI) && f.push(w, M, T)
                    }
                this.setIndex(f), this.addAttribute("position", new zn(m, 3)), this.addAttribute("normal", new zn(v, 3)), this.addAttribute("uv", new zn(g, 2))
            }

            function Eo(t, e, n, i, r, a) {
                Pn.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: a
                }, this.fromBufferGeometry(new Ao(t, e, n, i, r, a)), this.mergeVertices()
            }

            function Ao(t, e, n, i, r, a) {
                Hn.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: a
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
                var o, s, c, u = [],
                    l = [],
                    h = [],
                    d = [],
                    p = t,
                    f = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
                    m = new ze,
                    v = new je;
                for (s = 0; s <= i; s++) {
                    for (c = 0; c <= n; c++) o = r + c / n * a, m.x = p * Math.cos(o), m.y = p * Math.sin(o), l.push(m.x, m.y, m.z), h.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, d.push(v.x, v.y);
                    p += f
                }
                for (s = 0; s < i; s++) {
                    var g = s * (n + 1);
                    for (c = 0; c < n; c++) {
                        var y = o = c + g,
                            x = o + n + 1,
                            b = o + n + 2,
                            _ = o + 1;
                        u.push(y, x, _), u.push(x, b, _)
                    }
                }
                this.setIndex(u), this.addAttribute("position", new zn(l, 3)), this.addAttribute("normal", new zn(h, 3)), this.addAttribute("uv", new zn(d, 2))
            }

            function Lo(t, e, n, i) {
                Pn.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, this.fromBufferGeometry(new Po(t, e, n, i)), this.mergeVertices()
            }

            function Po(t, e, n, i) {
                Hn.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: i
                }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = De.clamp(i, 0, 2 * Math.PI);
                var r, a, o, s = [],
                    c = [],
                    u = [],
                    l = 1 / e,
                    h = new ze,
                    d = new je;
                for (a = 0; a <= e; a++) {
                    var p = n + a * l * i,
                        f = Math.sin(p),
                        m = Math.cos(p);
                    for (o = 0; o <= t.length - 1; o++) h.x = t[o].x * f, h.y = t[o].y, h.z = t[o].x * m, c.push(h.x, h.y, h.z), d.x = a / e, d.y = o / (t.length - 1), u.push(d.x, d.y)
                }
                for (a = 0; a < e; a++)
                    for (o = 0; o < t.length - 1; o++) {
                        var v = r = o + a * t.length,
                            g = r + t.length,
                            y = r + t.length + 1,
                            x = r + 1;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                if (this.setIndex(s), this.addAttribute("position", new zn(c, 3)), this.addAttribute("uv", new zn(u, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                    var b = this.attributes.normal.array,
                        _ = new ze,
                        w = new ze,
                        M = new ze;
                    for (r = e * t.length * 3, a = 0, o = 0; a < t.length; a++, o += 3) _.x = b[o + 0], _.y = b[o + 1], _.z = b[o + 2], w.x = b[r + o + 0], w.y = b[r + o + 1], w.z = b[r + o + 2], M.addVectors(_, w).normalize(), b[o + 0] = b[r + o + 0] = M.x, b[o + 1] = b[r + o + 1] = M.y, b[o + 2] = b[r + o + 2] = M.z
                }
            }

            function Oo(t, e) {
                Pn.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new Co(t, e)), this.mergeVertices()
            }

            function Co(t, e) {
                Hn.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, e = e || 12;
                var n = [],
                    i = [],
                    r = [],
                    a = [],
                    o = 0,
                    s = 0;
                if (!1 === Array.isArray(t)) u(t);
                else
                    for (var c = 0; c < t.length; c++) u(t[c]), this.addGroup(o, s, c), o += s, s = 0;

                function u(t) {
                    var o, c, u, l = i.length / 3,
                        h = t.extractPoints(e),
                        d = h.shape,
                        p = h.holes;
                    for (!1 === mo.isClockWise(d) && (d = d.reverse()), o = 0, c = p.length; o < c; o++) u = p[o], !0 === mo.isClockWise(u) && (p[o] = u.reverse());
                    var f = mo.triangulateShape(d, p);
                    for (o = 0, c = p.length; o < c; o++) u = p[o], d = d.concat(u);
                    for (o = 0, c = d.length; o < c; o++) {
                        var m = d[o];
                        i.push(m.x, m.y, 0), r.push(0, 0, 1), a.push(m.x, m.y)
                    }
                    for (o = 0, c = f.length; o < c; o++) {
                        var v = f[o],
                            g = v[0] + l,
                            y = v[1] + l,
                            x = v[2] + l;
                        n.push(g, y, x), s += 3
                    }
                }
                this.setIndex(n), this.addAttribute("position", new zn(i, 3)), this.addAttribute("normal", new zn(r, 3)), this.addAttribute("uv", new zn(a, 2))
            }

            function Ro(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }

            function Io(t, e) {
                Hn.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var n, i, r, a, o = [],
                    s = Math.cos(De.DEG2RAD * e),
                    c = [0, 0],
                    u = {},
                    l = ["a", "b", "c"];
                t.isBufferGeometry ? (a = new Pn).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a.computeFaceNormals();
                for (var h = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], v = 0; v < 3; v++) n = m[l[v]], i = m[l[(v + 1) % 3]], c[0] = Math.min(n, i), c[1] = Math.max(n, i), void 0 === u[r = c[0] + "," + c[1]] ? u[r] = {
                        index1: c[0],
                        index2: c[1],
                        face1: p,
                        face2: void 0
                    } : u[r].face2 = p;
                for (r in u) {
                    var g = u[r];
                    if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
                        var y = h[g.index1];
                        o.push(y.x, y.y, y.z), y = h[g.index2], o.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new zn(o, 3))
            }

            function Do(t, e, n, i, r, a, o, s) {
                Pn.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                }, this.fromBufferGeometry(new jo(t, e, n, i, r, a, o, s)), this.mergeVertices()
            }

            function jo(t, e, n, i, r, a, o, s) {
                Hn.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                };
                var c = this;
                t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, a = void 0 !== a && a, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var u = [],
                    l = [],
                    h = [],
                    d = [],
                    p = 0,
                    f = [],
                    m = n / 2,
                    v = 0;

                function g(n) {
                    var r, a, f, g = new je,
                        y = new ze,
                        x = 0,
                        b = !0 === n ? t : e,
                        _ = !0 === n ? 1 : -1;
                    for (a = p, r = 1; r <= i; r++) l.push(0, m * _, 0), h.push(0, _, 0), d.push(.5, .5), p++;
                    for (f = p, r = 0; r <= i; r++) {
                        var w = r / i * s + o,
                            M = Math.cos(w),
                            T = Math.sin(w);
                        y.x = b * T, y.y = m * _, y.z = b * M, l.push(y.x, y.y, y.z), h.push(0, _, 0), g.x = .5 * M + .5, g.y = .5 * T * _ + .5, d.push(g.x, g.y), p++
                    }
                    for (r = 0; r < i; r++) {
                        var S = a + r,
                            E = f + r;
                        !0 === n ? u.push(E, E + 1, S) : u.push(E + 1, E, S), x += 3
                    }
                    c.addGroup(v, x, !0 === n ? 1 : 2), v += x
                }! function() {
                    var a, g, y = new ze,
                        x = new ze,
                        b = 0,
                        _ = (e - t) / n;
                    for (g = 0; g <= r; g++) {
                        var w = [],
                            M = g / r,
                            T = M * (e - t) + t;
                        for (a = 0; a <= i; a++) {
                            var S = a / i,
                                E = S * s + o,
                                A = Math.sin(E),
                                L = Math.cos(E);
                            x.x = T * A, x.y = -M * n + m, x.z = T * L, l.push(x.x, x.y, x.z), y.set(A, _, L).normalize(), h.push(y.x, y.y, y.z), d.push(S, 1 - M), w.push(p++)
                        }
                        f.push(w)
                    }
                    for (a = 0; a < i; a++)
                        for (g = 0; g < r; g++) {
                            var P = f[g][a],
                                O = f[g + 1][a],
                                C = f[g + 1][a + 1],
                                R = f[g][a + 1];
                            u.push(P, O, R), u.push(O, C, R), b += 6
                        }
                    c.addGroup(v, b, 0), v += b
                }(), !1 === a && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(u), this.addAttribute("position", new zn(l, 3)), this.addAttribute("normal", new zn(h, 3)), this.addAttribute("uv", new zn(d, 2))
            }

            function No(t, e, n, i, r, a, o) {
                Do.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }

            function ko(t, e, n, i, r, a, o) {
                jo.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }

            function zo(t, e, n, i) {
                Pn.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, this.fromBufferGeometry(new Bo(t, e, n, i)), this.mergeVertices()
            }

            function Bo(t, e, n, i) {
                Hn.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: i
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
                var r, a, o = [],
                    s = [],
                    c = [],
                    u = [],
                    l = new ze,
                    h = new je;
                for (s.push(0, 0, 0), c.push(0, 0, 1), u.push(.5, .5), a = 0, r = 3; a <= e; a++, r += 3) {
                    var d = n + a / e * i;
                    l.x = t * Math.cos(d), l.y = t * Math.sin(d), s.push(l.x, l.y, l.z), c.push(0, 0, 1), h.x = (s[r] / t + 1) / 2, h.y = (s[r + 1] / t + 1) / 2, u.push(h.x, h.y)
                }
                for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
                this.setIndex(o), this.addAttribute("position", new zn(s, 3)), this.addAttribute("normal", new zn(c, 3)), this.addAttribute("uv", new zn(u, 2))
            }
            wo.prototype = Object.create(Pn.prototype), wo.prototype.constructor = wo, Mo.prototype = Object.create(xo.prototype), Mo.prototype.constructor = Mo, To.prototype = Object.create(Pn.prototype), To.prototype.constructor = To, So.prototype = Object.create(Hn.prototype), So.prototype.constructor = So, Eo.prototype = Object.create(Pn.prototype), Eo.prototype.constructor = Eo, Ao.prototype = Object.create(Hn.prototype), Ao.prototype.constructor = Ao, Lo.prototype = Object.create(Pn.prototype), Lo.prototype.constructor = Lo, Po.prototype = Object.create(Hn.prototype), Po.prototype.constructor = Po, Oo.prototype = Object.create(Pn.prototype), Oo.prototype.constructor = Oo, Oo.prototype.toJSON = function() {
                var t = Pn.prototype.toJSON.call(this);
                return Ro(this.parameters.shapes, t)
            }, Co.prototype = Object.create(Hn.prototype), Co.prototype.constructor = Co, Co.prototype.toJSON = function() {
                var t = Hn.prototype.toJSON.call(this);
                return Ro(this.parameters.shapes, t)
            }, Io.prototype = Object.create(Hn.prototype), Io.prototype.constructor = Io, Do.prototype = Object.create(Pn.prototype), Do.prototype.constructor = Do, jo.prototype = Object.create(Hn.prototype), jo.prototype.constructor = jo, No.prototype = Object.create(Do.prototype), No.prototype.constructor = No, ko.prototype = Object.create(jo.prototype), ko.prototype.constructor = ko, zo.prototype = Object.create(Pn.prototype), zo.prototype.constructor = zo, Bo.prototype = Object.create(Hn.prototype), Bo.prototype.constructor = Bo;
            var Uo = Object.freeze({
                WireframeGeometry: Aa,
                ParametricGeometry: La,
                ParametricBufferGeometry: Pa,
                TetrahedronGeometry: Ra,
                TetrahedronBufferGeometry: Ia,
                OctahedronGeometry: Da,
                OctahedronBufferGeometry: ja,
                IcosahedronGeometry: Na,
                IcosahedronBufferGeometry: ka,
                DodecahedronGeometry: za,
                DodecahedronBufferGeometry: Ba,
                PolyhedronGeometry: Oa,
                PolyhedronBufferGeometry: Ca,
                TubeGeometry: Ua,
                TubeBufferGeometry: Ga,
                TorusKnotGeometry: Fa,
                TorusKnotBufferGeometry: Ha,
                TorusGeometry: Va,
                TorusBufferGeometry: Wa,
                TextGeometry: wo,
                TextBufferGeometry: Mo,
                SphereGeometry: To,
                SphereBufferGeometry: So,
                RingGeometry: Eo,
                RingBufferGeometry: Ao,
                PlaneGeometry: qn,
                PlaneBufferGeometry: Xn,
                LatheGeometry: Lo,
                LatheBufferGeometry: Po,
                ShapeGeometry: Oo,
                ShapeBufferGeometry: Co,
                ExtrudeGeometry: yo,
                ExtrudeBufferGeometry: xo,
                EdgesGeometry: Io,
                ConeGeometry: No,
                ConeBufferGeometry: ko,
                CylinderGeometry: Do,
                CylinderBufferGeometry: jo,
                CircleGeometry: zo,
                CircleBufferGeometry: Bo,
                BoxGeometry: Vn,
                BoxBufferGeometry: Wn
            });

            function Go(t) {
                si.call(this), this.type = "ShadowMaterial", this.color = new hn(0), this.transparent = !0, this.setValues(t)
            }

            function Fo(t) {
                ci.call(this, t), this.type = "RawShaderMaterial"
            }

            function Ho(t) {
                si.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new hn(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Re, this.normalScale = new je(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Vo(t) {
                Ho.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
            }

            function Wo(t) {
                si.call(this), this.type = "MeshPhongMaterial", this.color = new hn(16777215), this.specular = new hn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Re, this.normalScale = new je(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = rt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function qo(t) {
                Wo.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
            }

            function Xo(t) {
                si.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Re, this.normalScale = new je(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Yo(t) {
                si.call(this), this.type = "MeshLambertMaterial", this.color = new hn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = rt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Zo(t) {
                si.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new hn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Re, this.normalScale = new je(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
            }

            function Jo(t) {
                ga.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            Go.prototype = Object.create(si.prototype), Go.prototype.constructor = Go, Go.prototype.isShadowMaterial = !0, Go.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, Fo.prototype = Object.create(ci.prototype), Fo.prototype.constructor = Fo, Fo.prototype.isRawShaderMaterial = !0, Ho.prototype = Object.create(si.prototype), Ho.prototype.constructor = Ho, Ho.prototype.isMeshStandardMaterial = !0, Ho.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Vo.prototype = Object.create(Ho.prototype), Vo.prototype.constructor = Vo, Vo.prototype.isMeshPhysicalMaterial = !0, Vo.prototype.copy = function(t) {
                return Ho.prototype.copy.call(this, t), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
            }, Wo.prototype = Object.create(si.prototype), Wo.prototype.constructor = Wo, Wo.prototype.isMeshPhongMaterial = !0, Wo.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, qo.prototype = Object.create(Wo.prototype), qo.prototype.constructor = qo, qo.prototype.isMeshToonMaterial = !0, qo.prototype.copy = function(t) {
                return Wo.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
            }, Xo.prototype = Object.create(si.prototype), Xo.prototype.constructor = Xo, Xo.prototype.isMeshNormalMaterial = !0, Xo.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Yo.prototype = Object.create(si.prototype), Yo.prototype.constructor = Yo, Yo.prototype.isMeshLambertMaterial = !0, Yo.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Zo.prototype = Object.create(si.prototype), Zo.prototype.constructor = Zo, Zo.prototype.isMeshMatcapMaterial = !0, Zo.prototype.copy = function(t) {
                return si.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Jo.prototype = Object.create(ga.prototype), Jo.prototype.constructor = Jo, Jo.prototype.isLineDashedMaterial = !0, Jo.prototype.copy = function(t) {
                return ga.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var Ko = Object.freeze({
                    ShadowMaterial: Go,
                    SpriteMaterial: ha,
                    RawShaderMaterial: Fo,
                    ShaderMaterial: ci,
                    PointsMaterial: _a,
                    MeshPhysicalMaterial: Vo,
                    MeshStandardMaterial: Ho,
                    MeshPhongMaterial: Wo,
                    MeshToonMaterial: qo,
                    MeshNormalMaterial: Xo,
                    MeshLambertMaterial: Yo,
                    MeshDepthMaterial: zr,
                    MeshDistanceMaterial: Br,
                    MeshBasicMaterial: hi,
                    MeshMatcapMaterial: Zo,
                    LineDashedMaterial: Jo,
                    LineBasicMaterial: ga,
                    Material: si
                }),
                Qo = {
                    arraySlice: function(t, e, n) {
                        return Qo.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                    },
                    convertArray: function(t, e, n) {
                        return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i) n[i] = i;
                        return n.sort(function(e, n) {
                            return t[e] - t[n]
                        }), n
                    },
                    sortedArray: function(t, e, n) {
                        for (var i = t.length, r = new t.constructor(i), a = 0, o = 0; o !== i; ++a)
                            for (var s = n[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
                        return r
                    },
                    flattenJSON: function(t, e, n, i) {
                        for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[i];) a = t[r++];
                        if (void 0 !== a) {
                            var o = a[i];
                            if (void 0 !== o)
                                if (Array.isArray(o))
                                    do {
                                        void 0 !== (o = a[i]) && (e.push(a.time), n.push.apply(n, o)), a = t[r++]
                                    } while (void 0 !== a);
                                else if (void 0 !== o.toArray)
                                do {
                                    void 0 !== (o = a[i]) && (e.push(a.time), o.toArray(n, n.length)), a = t[r++]
                                } while (void 0 !== a);
                            else
                                do {
                                    void 0 !== (o = a[i]) && (e.push(a.time), n.push(o)), a = t[r++]
                                } while (void 0 !== a)
                        }
                    }
                };

            function $o(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }

            function ts(t, e, n, i) {
                $o.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function es(t, e, n, i) {
                $o.call(this, t, e, n, i)
            }

            function ns(t, e, n, i) {
                $o.call(this, t, e, n, i)
            }

            function is(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Qo.convertArray(e, this.TimeBufferType), this.values = Qo.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            function rs(t, e, n) {
                is.call(this, t, e, n)
            }

            function as(t, e, n, i) {
                is.call(this, t, e, n, i)
            }

            function os(t, e, n, i) {
                is.call(this, t, e, n, i)
            }

            function ss(t, e, n, i) {
                $o.call(this, t, e, n, i)
            }

            function cs(t, e, n, i) {
                is.call(this, t, e, n, i)
            }

            function us(t, e, n, i) {
                is.call(this, t, e, n, i)
            }

            function ls(t, e, n, i) {
                is.call(this, t, e, n, i)
            }

            function hs(t, e, n) {
                this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = De.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function ds(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return os;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return ls;
                        case "color":
                            return as;
                        case "quaternion":
                            return cs;
                        case "bool":
                        case "boolean":
                            return rs;
                        case "string":
                            return us
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    var n = [],
                        i = [];
                    Qo.flattenJSON(t.keys, n, i, "value"), t.times = n, t.values = i
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign($o.prototype, {
                    evaluate: function(t) {
                        var e = this.parameterPositions,
                            n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                var a;n: {
                                    i: if (!(t < i)) {
                                        for (var o = n + 2;;) {
                                            if (void 0 === i) {
                                                if (t < r) break i;
                                                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                            }
                                            if (n === o) break;
                                            if (r = i, t < (i = e[++n])) break e
                                        }
                                        a = e.length;
                                        break n
                                    }if (t >= r) break t;
                                    var s = e[1];t < s && (n = 2, r = s);
                                    for (o = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                        if (n === o) break;
                                        if (i = r, t >= (r = e[--n - 1])) break e
                                    }
                                    a = n,
                                    n = 0
                                }
                                for (; n < a;) {
                                    var c = n + a >>> 1;
                                    t < e[c] ? a = c : n = c + 1
                                }
                                if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0,
                                this.beforeStart_(0, t, i);
                                if (void 0 === i) return n = e.length,
                                this._cachedIndex = n,
                                this.afterEnd_(n - 1, r, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, i)
                        }
                        return this.interpolate_(n, r, t, i)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function() {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function(t) {
                        for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, a = 0; a !== i; ++a) e[a] = n[r + a];
                        return e
                    },
                    interpolate_: function() {
                        throw new Error("call to abstract method")
                    },
                    intervalChanged_: function() {}
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign($o.prototype, {
                    beforeStart_: $o.prototype.copySampleValue_,
                    afterEnd_: $o.prototype.copySampleValue_
                }), ts.prototype = Object.assign(Object.create($o.prototype), {
                    constructor: ts,
                    DefaultSettings_: {
                        endingStart: xe,
                        endingEnd: xe
                    },
                    intervalChanged_: function(t, e, n) {
                        var i = this.parameterPositions,
                            r = t - 2,
                            a = t + 1,
                            o = i[r],
                            s = i[a];
                        if (void 0 === o) switch (this.getSettings_().endingStart) {
                            case 2401:
                                r = t, o = 2 * e - n;
                                break;
                            case 2402:
                                o = e + i[r = i.length - 2] - i[r + 1];
                                break;
                            default:
                                r = t, o = n
                        }
                        if (void 0 === s) switch (this.getSettings_().endingEnd) {
                            case 2401:
                                a = t, s = 2 * n - e;
                                break;
                            case 2402:
                                a = 1, s = n + i[1] - i[0];
                                break;
                            default:
                                a = t - 1, s = e
                        }
                        var c = .5 * (n - e),
                            u = this.valueSize;
                        this._weightPrev = c / (e - o), this._weightNext = c / (s - n), this._offsetPrev = r * u, this._offsetNext = a * u
                    },
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, u = this._offsetPrev, l = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - e) / (i - e), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f, b = 0; b !== o; ++b) r[b] = v * a[u + b] + g * a[c + b] + y * a[s + b] + x * a[l + b];
                        return r
                    }
                }), es.prototype = Object.assign(Object.create($o.prototype), {
                    constructor: es,
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, u = (n - e) / (i - e), l = 1 - u, h = 0; h !== o; ++h) r[h] = a[c + h] * l + a[s + h] * u;
                        return r
                    }
                }), ns.prototype = Object.assign(Object.create($o.prototype), {
                    constructor: ns,
                    interpolate_: function(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }), Object.assign(is, {
                    toJSON: function(t) {
                        var e, n = t.constructor;
                        if (void 0 !== n.toJSON) e = n.toJSON(t);
                        else {
                            e = {
                                name: t.name,
                                times: Qo.convertArray(t.times, Array),
                                values: Qo.convertArray(t.values, Array)
                            };
                            var i = t.getInterpolation();
                            i !== t.DefaultInterpolation && (e.interpolation = i)
                        }
                        return e.type = t.ValueTypeName, e
                    }
                }), Object.assign(is.prototype, {
                    constructor: is,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodDiscrete: function(t) {
                        return new ns(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodLinear: function(t) {
                        return new es(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: function(t) {
                        return new ts(this.times, this.values, this.getValueSize(), t)
                    },
                    setInterpolation: function(t) {
                        var e;
                        switch (t) {
                            case 2300:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case 2301:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case 2302:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(n);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", n), this
                        }
                        return this.createInterpolant = e, this
                    },
                    getInterpolation: function() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return 2300;
                            case this.InterpolantFactoryMethodLinear:
                                return 2301;
                            case this.InterpolantFactoryMethodSmooth:
                                return 2302
                        }
                    },
                    getValueSize: function() {
                        return this.values.length / this.times.length
                    },
                    shift: function(t) {
                        if (0 !== t)
                            for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] += t;
                        return this
                    },
                    scale: function(t) {
                        if (1 !== t)
                            for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] *= t;
                        return this
                    },
                    trim: function(t, e) {
                        for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < t;) ++r;
                        for (; - 1 !== a && n[a] > e;) --a;
                        if (++a, 0 !== r || a !== i) {
                            r >= a && (r = (a = Math.max(a, 1)) - 1);
                            var o = this.getValueSize();
                            this.times = Qo.arraySlice(n, r, a), this.values = Qo.arraySlice(this.values, r * o, a * o)
                        }
                        return this
                    },
                    validate: function() {
                        var t = !0,
                            e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        var n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        for (var a = null, o = 0; o !== r; o++) {
                            var s = n[o];
                            if ("number" == typeof s && isNaN(s)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), t = !1;
                                break
                            }
                            if (null !== a && a > s) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), t = !1;
                                break
                            }
                            a = s
                        }
                        if (void 0 !== i && Qo.isTypedArray(i)) {
                            o = 0;
                            for (var c = i.length; o !== c; ++o) {
                                var u = i[o];
                                if (isNaN(u)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, u), t = !1;
                                    break
                                }
                            }
                        }
                        return t
                    },
                    optimize: function() {
                        for (var t = this.times, e = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, a = t.length - 1, o = 1; o < a; ++o) {
                            var s = !1,
                                c = t[o];
                            if (c !== t[o + 1] && (1 !== o || c !== c[0]))
                                if (i) s = !0;
                                else
                                    for (var u = o * n, l = u - n, h = u + n, d = 0; d !== n; ++d) {
                                        var p = e[u + d];
                                        if (p !== e[l + d] || p !== e[h + d]) {
                                            s = !0;
                                            break
                                        }
                                    }
                            if (s) {
                                if (o !== r) {
                                    t[r] = t[o];
                                    var f = o * n,
                                        m = r * n;
                                    for (d = 0; d !== n; ++d) e[m + d] = e[f + d]
                                }++r
                            }
                        }
                        if (a > 0) {
                            t[r] = t[a];
                            for (f = a * n, m = r * n, d = 0; d !== n; ++d) e[m + d] = e[f + d];
                            ++r
                        }
                        return r !== t.length && (this.times = Qo.arraySlice(t, 0, r), this.values = Qo.arraySlice(e, 0, r * n)), this
                    },
                    clone: function() {
                        var t = Qo.arraySlice(this.times, 0),
                            e = Qo.arraySlice(this.values, 0),
                            n = new(0, this.constructor)(this.name, t, e);
                        return n.createInterpolant = this.createInterpolant, n
                    }
                }), rs.prototype = Object.assign(Object.create(is.prototype), {
                    constructor: rs,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), as.prototype = Object.assign(Object.create(is.prototype), {
                    constructor: as,
                    ValueTypeName: "color"
                }), os.prototype = Object.assign(Object.create(is.prototype), {
                    constructor: os,
                    ValueTypeName: "number"
                }), ss.prototype = Object.assign(Object.create($o.prototype), {
                    constructor: ss,
                    interpolate_: function(t, e, n, i) {
                        for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = (n - e) / (i - e), u = s + o; s !== u; s += 4) ke.slerpFlat(r, 0, a, s - o, a, s, c);
                        return r
                    }
                }), cs.prototype = Object.assign(Object.create(is.prototype), {
                    constructor: cs,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodLinear: function(t) {
                        return new ss(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }), us.prototype = Object.assign(Object.create(is.prototype), {
                    constructor: us,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), ls.prototype = Object.assign(Object.create(is.prototype), {
                    constructor: ls,
                    ValueTypeName: "vector"
                }), Object.assign(hs, {
                    parse: function(t) {
                        for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, a = n.length; r !== a; ++r) e.push(ds(n[r]).scale(i));
                        return new hs(t.name, t.duration, e)
                    },
                    toJSON: function(t) {
                        for (var e = [], n = t.tracks, i = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid
                            }, r = 0, a = n.length; r !== a; ++r) e.push(is.toJSON(n[r]));
                        return i
                    },
                    CreateFromMorphTargetSequence: function(t, e, n, i) {
                        for (var r = e.length, a = [], o = 0; o < r; o++) {
                            var s = [],
                                c = [];
                            s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
                            var u = Qo.getKeyframeOrder(s);
                            s = Qo.sortedArray(s, 1, u), c = Qo.sortedArray(c, 1, u), i || 0 !== s[0] || (s.push(r), c.push(c[0])), a.push(new os(".morphTargetInfluences[" + e[o].name + "]", s, c).scale(1 / n))
                        }
                        return new hs(t, -1, a)
                    },
                    findByName: function(t, e) {
                        var n = t;
                        if (!Array.isArray(t)) {
                            var i = t;
                            n = i.geometry && i.geometry.animations || i.animations
                        }
                        for (var r = 0; r < n.length; r++)
                            if (n[r].name === e) return n[r];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function(t, e, n) {
                        for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
                            var s = t[a],
                                c = s.name.match(r);
                            if (c && c.length > 1) {
                                var u = i[h = c[1]];
                                u || (i[h] = u = []), u.push(s)
                            }
                        }
                        var l = [];
                        for (var h in i) l.push(hs.CreateFromMorphTargetSequence(h, i[h], e, n));
                        return l
                    },
                    parseAnimation: function(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        for (var n = function(t, e, n, i, r) {
                                if (0 !== n.length) {
                                    var a = [],
                                        o = [];
                                    Qo.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new t(e, a, o))
                                }
                            }, i = [], r = t.name || "default", a = t.length || -1, o = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                            var u = s[c].keys;
                            if (u && 0 !== u.length)
                                if (u[0].morphTargets) {
                                    for (var l = {}, h = 0; h < u.length; h++)
                                        if (u[h].morphTargets)
                                            for (var d = 0; d < u[h].morphTargets.length; d++) l[u[h].morphTargets[d]] = -1;
                                    for (var p in l) {
                                        var f = [],
                                            m = [];
                                        for (d = 0; d !== u[h].morphTargets.length; ++d) {
                                            var v = u[h];
                                            f.push(v.time), m.push(v.morphTarget === p ? 1 : 0)
                                        }
                                        i.push(new os(".morphTargetInfluence[" + p + "]", f, m))
                                    }
                                    a = l.length * (o || 1)
                                } else {
                                    var g = ".bones[" + e[c].name + "]";
                                    n(ls, g + ".position", u, "pos", i), n(cs, g + ".quaternion", u, "rot", i), n(ls, g + ".scale", u, "scl", i)
                                }
                        }
                        return 0 === i.length ? null : new hs(r, a, i)
                    }
                }), Object.assign(hs.prototype, {
                    resetDuration: function() {
                        for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
                            var i = this.tracks[e];
                            t = Math.max(t, i.times[i.times.length - 1])
                        }
                        return this.duration = t, this
                    },
                    trim: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    },
                    validate: function() {
                        for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    },
                    optimize: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    },
                    clone: function() {
                        for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                        return new hs(this.name, this.duration, t)
                    }
                });
            var ps = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function fs(t, e, n) {
                var i = this,
                    r = !1,
                    a = 0,
                    o = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    o++, !1 === r && void 0 !== i.onStart && i.onStart(t, a, o), r = !0
                }, this.itemEnd = function(t) {
                    a++, void 0 !== i.onProgress && i.onProgress(t, a, o), a === o && (r = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }
            }
            var ms = new fs,
                vs = {};

            function gs(t) {
                this.manager = void 0 !== t ? t : ms
            }

            function ys(t) {
                this.manager = void 0 !== t ? t : ms, this._parser = null
            }

            function xs(t) {
                this.manager = void 0 !== t ? t : ms
            }

            function bs(t) {
                this.manager = void 0 !== t ? t : ms
            }

            function _s(t) {
                this.manager = void 0 !== t ? t : ms
            }

            function ws() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function Ms(t, e, n, i, r, a, o, s) {
                ws.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
            }

            function Ts(t, e, n, i, r, a) {
                Ms.call(this, t, e, n, n, i, r, a), this.type = "ArcCurve"
            }

            function Ss() {
                var t = 0,
                    e = 0,
                    n = 0,
                    i = 0;

                function r(r, a, o, s) {
                    t = r, e = o, n = -3 * r + 3 * a - 2 * o - s, i = 2 * r - 2 * a + o + s
                }
                return {
                    initCatmullRom: function(t, e, n, i, a) {
                        r(e, n, a * (n - t), a * (i - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, i, a, o, s) {
                        var c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
                            u = (n - e) / o - (i - e) / (o + s) + (i - n) / s;
                        r(e, n, c *= o, u *= o)
                    },
                    calc: function(r) {
                        var a = r * r;
                        return t + e * r + n * a + i * (a * r)
                    }
                }
            }
            Object.assign(gs.prototype, {
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        a = ps.get(t);
                    if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(a), r.manager.itemEnd(t)
                    }, 0), a;
                    if (void 0 === vs[t]) {
                        var o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (o) {
                            var s = o[1],
                                c = !!o[2],
                                u = o[3];
                            u = decodeURIComponent(u), c && (u = atob(u));
                            try {
                                var l, h = (this.responseType || "").toLowerCase();
                                switch (h) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var d = new Uint8Array(u.length), p = 0; p < u.length; p++) d[p] = u.charCodeAt(p);
                                        l = "blob" === h ? new Blob([d.buffer], {
                                            type: s
                                        }) : d.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        l = f.parseFromString(u, s);
                                        break;
                                    case "json":
                                        l = JSON.parse(u);
                                        break;
                                    default:
                                        l = u
                                }
                                setTimeout(function() {
                                    e && e(l), r.manager.itemEnd(t)
                                }, 0)
                            } catch (g) {
                                setTimeout(function() {
                                    i && i(g), r.manager.itemError(t), r.manager.itemEnd(t)
                                }, 0)
                            }
                        } else {
                            vs[t] = [], vs[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i
                            });
                            var m = new XMLHttpRequest;
                            for (var v in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                                    var n = this.response;
                                    ps.add(t, n);
                                    var i = vs[t];
                                    if (delete vs[t], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (var a = 0, o = i.length; a < o; a++) {
                                            (s = i[a]).onLoad && s.onLoad(n)
                                        }
                                        r.manager.itemEnd(t)
                                    } else {
                                        for (a = 0, o = i.length; a < o; a++) {
                                            var s;
                                            (s = i[a]).onError && s.onError(e)
                                        }
                                        r.manager.itemError(t), r.manager.itemEnd(t)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var n = vs[t], i = 0, r = n.length; i < r; i++) {
                                        var a = n[i];
                                        a.onProgress && a.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var n = vs[t];
                                    delete vs[t];
                                    for (var i = 0, a = n.length; i < a; i++) {
                                        var o = n[i];
                                        o.onError && o.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), m.addEventListener("abort", function(e) {
                                    var n = vs[t];
                                    delete vs[t];
                                    for (var i = 0, a = n.length; i < a; i++) {
                                        var o = n[i];
                                        o.onError && o.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                            m.send(null)
                        }
                        return r.manager.itemStart(t), m
                    }
                    vs[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    })
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            }), Object.assign(function(t) {
                this.manager = void 0 !== t ? t : ms
            }.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = new gs(r.manager);
                    a.setPath(r.path), a.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                parse: function(t, e) {
                    for (var n = [], i = 0; i < t.length; i++) {
                        var r = hs.parse(t[i]);
                        n.push(r)
                    }
                    e(n)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(function(t) {
                this.manager = void 0 !== t ? t : ms, this._parser = null
            }.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = [],
                        o = new Ta;
                    o.image = a;
                    var s = new gs(this.manager);

                    function c(c) {
                        s.load(t[c], function(t) {
                            var n = r._parser(t, !0);
                            a[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, 6 === (u += 1) && (1 === n.mipmapCount && (o.minFilter = Et), o.format = n.format, o.needsUpdate = !0, e && e(o))
                        }, n, i)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                        for (var u = 0, l = 0, h = t.length; l < h; ++l) c(l);
                    else s.load(t, function(t) {
                        var n = r._parser(t, !0);
                        if (n.isCubemap)
                            for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                                a[s] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < n.mipmapCount; c++) a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), a[s].format = n.format, a[s].width = n.width, a[s].height = n.height
                            } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (o.minFilter = Et), o.format = n.format, o.needsUpdate = !0, e && e(o)
                    }, n, i);
                    return o
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(ys.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = new Qe,
                        o = new gs(this.manager);
                    return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(t, function(t) {
                        var n = r._parser(t);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : _t, a.wrapT = void 0 !== n.wrapT ? n.wrapT : _t, a.magFilter = void 0 !== n.magFilter ? n.magFilter : Et, a.minFilter = void 0 !== n.minFilter ? n.minFilter : Lt, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps), 1 === n.mipmapCount && (a.minFilter = Et), a.needsUpdate = !0, e && e(a, n))
                    }, n, i), a
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(xs.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        a = ps.get(t);
                    if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(a), r.manager.itemEnd(t)
                    }, 0), a;
                    var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1), ps.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function c(e) {
                        o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                    return o.addEventListener("load", s, !1), o.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(bs.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    var r = new Ti,
                        a = new xs(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                    var o = 0;

                    function s(n) {
                        a.load(t[n], function(t) {
                            r.images[n] = t, 6 === ++o && (r.needsUpdate = !0, e && e(r))
                        }, void 0, i)
                    }
                    for (var c = 0; c < t.length; ++c) s(c);
                    return r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(_s.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    var r = new Xe,
                        a = new xs(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function(n) {
                        r.image = n;
                        var i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = i ? Ft : Ht, r.needsUpdate = !0, void 0 !== e && e(r)
                    }, n, i), r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(ws.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    var n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, n, i = [],
                        r = this.getPoint(0),
                        a = 0;
                    for (i.push(0), n = 1; n <= t; n++) a += (e = this.getPoint(n / t)).distanceTo(r), i.push(a), r = e;
                    return this.cacheArcLengths = i, i
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var n, i = this.getLengths(),
                        r = 0,
                        a = i.length;
                    n = e || t * i[a - 1];
                    for (var o, s = 0, c = a - 1; s <= c;)
                        if ((o = i[r = Math.floor(s + (c - s) / 2)] - n) < 0) s = r + 1;
                        else {
                            if (!(o > 0)) {
                                c = r;
                                break
                            }
                            c = r - 1
                        } if (i[r = c] === n) return r / (a - 1);
                    var u = i[r];
                    return (r + (n - u) / (i[r + 1] - u)) / (a - 1)
                },
                getTangent: function(t) {
                    var e = t - 1e-4,
                        n = t + 1e-4;
                    e < 0 && (e = 0), n > 1 && (n = 1);
                    var i = this.getPoint(e);
                    return this.getPoint(n).clone().sub(i).normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                },
                computeFrenetFrames: function(t, e) {
                    var n, i, r, a = new ze,
                        o = [],
                        s = [],
                        c = [],
                        u = new ze,
                        l = new Ne;
                    for (n = 0; n <= t; n++) i = n / t, o[n] = this.getTangentAt(i), o[n].normalize();
                    s[0] = new ze, c[0] = new ze;
                    var h = Number.MAX_VALUE,
                        d = Math.abs(o[0].x),
                        p = Math.abs(o[0].y),
                        f = Math.abs(o[0].z);
                    for (d <= h && (h = d, a.set(1, 0, 0)), p <= h && (h = p, a.set(0, 1, 0)), f <= h && a.set(0, 0, 1), u.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], u), c[0].crossVectors(o[0], s[0]), n = 1; n <= t; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), u.crossVectors(o[n - 1], o[n]), u.length() > Number.EPSILON && (u.normalize(), r = Math.acos(De.clamp(o[n - 1].dot(o[n]), -1, 1)), s[n].applyMatrix4(l.makeRotationAxis(u, r))), c[n].crossVectors(o[n], s[n]);
                    if (!0 === e)
                        for (r = Math.acos(De.clamp(s[0].dot(s[t]), -1, 1)), r /= t, o[0].dot(u.crossVectors(s[0], s[t])) > 0 && (r = -r), n = 1; n <= t; n++) s[n].applyMatrix4(l.makeRotationAxis(o[n], r * n)), c[n].crossVectors(o[n], s[n]);
                    return {
                        tangents: o,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), Ms.prototype = Object.create(ws.prototype), Ms.prototype.constructor = Ms, Ms.prototype.isEllipseCurve = !0, Ms.prototype.getPoint = function(t, e) {
                for (var n = e || new je, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (r = a ? 0 : i), !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
                var o = this.aStartAngle + t * r,
                    s = this.aX + this.xRadius * Math.cos(o),
                    c = this.aY + this.yRadius * Math.sin(o);
                if (0 !== this.aRotation) {
                    var u = Math.cos(this.aRotation),
                        l = Math.sin(this.aRotation),
                        h = s - this.aX,
                        d = c - this.aY;
                    s = h * u - d * l + this.aX, c = h * l + d * u + this.aY
                }
                return n.set(s, c)
            }, Ms.prototype.copy = function(t) {
                return ws.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ms.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, Ms.prototype.fromJSON = function(t) {
                return ws.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ts.prototype = Object.create(Ms.prototype), Ts.prototype.constructor = Ts, Ts.prototype.isArcCurve = !0;
            var Es = new ze,
                As = new Ss,
                Ls = new Ss,
                Ps = new Ss;

            function Os(t, e, n, i) {
                ws.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5
            }

            function Cs(t, e, n, i, r) {
                var a = .5 * (i - e),
                    o = .5 * (r - n),
                    s = t * t;
                return (2 * n - 2 * i + a + o) * (t * s) + (-3 * n + 3 * i - 2 * a - o) * s + a * t + n
            }

            function Rs(t, e, n, i) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, n) + function(t, e) {
                    return t * t * e
                }(t, i)
            }

            function Is(t, e, n, i, r) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * n * e
                }(t, e) + function(t, e) {
                    var n = 1 - t;
                    return 3 * n * n * t * e
                }(t, n) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, i) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }

            function Ds(t, e, n, i) {
                ws.call(this), this.type = "CubicBezierCurve", this.v0 = t || new je, this.v1 = e || new je, this.v2 = n || new je, this.v3 = i || new je
            }

            function js(t, e, n, i) {
                ws.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new ze, this.v1 = e || new ze, this.v2 = n || new ze, this.v3 = i || new ze
            }

            function Ns(t, e) {
                ws.call(this), this.type = "LineCurve", this.v1 = t || new je, this.v2 = e || new je
            }

            function ks(t, e) {
                ws.call(this), this.type = "LineCurve3", this.v1 = t || new ze, this.v2 = e || new ze
            }

            function zs(t, e, n) {
                ws.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new je, this.v1 = e || new je, this.v2 = n || new je
            }

            function Bs(t, e, n) {
                ws.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new ze, this.v1 = e || new ze, this.v2 = n || new ze
            }

            function Us(t) {
                ws.call(this), this.type = "SplineCurve", this.points = t || []
            }
            Os.prototype = Object.create(ws.prototype), Os.prototype.constructor = Os, Os.prototype.isCatmullRomCurve3 = !0, Os.prototype.getPoint = function(t, e) {
                var n, i, r, a, o = e || new ze,
                    s = this.points,
                    c = s.length,
                    u = (c - (this.closed ? 0 : 1)) * t,
                    l = Math.floor(u),
                    h = u - l;
                if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === h && l === c - 1 && (l = c - 2, h = 1), this.closed || l > 0 ? n = s[(l - 1) % c] : (Es.subVectors(s[0], s[1]).add(s[0]), n = Es), i = s[l % c], r = s[(l + 1) % c], this.closed || l + 2 < c ? a = s[(l + 2) % c] : (Es.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), a = Es), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var d = "chordal" === this.curveType ? .5 : .25,
                        p = Math.pow(n.distanceToSquared(i), d),
                        f = Math.pow(i.distanceToSquared(r), d),
                        m = Math.pow(r.distanceToSquared(a), d);
                    f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), As.initNonuniformCatmullRom(n.x, i.x, r.x, a.x, p, f, m), Ls.initNonuniformCatmullRom(n.y, i.y, r.y, a.y, p, f, m), Ps.initNonuniformCatmullRom(n.z, i.z, r.z, a.z, p, f, m)
                } else "catmullrom" === this.curveType && (As.initCatmullRom(n.x, i.x, r.x, a.x, this.tension), Ls.initCatmullRom(n.y, i.y, r.y, a.y, this.tension), Ps.initCatmullRom(n.z, i.z, r.z, a.z, this.tension));
                return o.set(As.calc(h), Ls.calc(h), Ps.calc(h)), o
            }, Os.prototype.copy = function(t) {
                ws.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Os.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, Os.prototype.fromJSON = function(t) {
                ws.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new ze).fromArray(i))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Ds.prototype = Object.create(ws.prototype), Ds.prototype.constructor = Ds, Ds.prototype.isCubicBezierCurve = !0, Ds.prototype.getPoint = function(t, e) {
                var n = e || new je,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3;
                return n.set(Is(t, i.x, r.x, a.x, o.x), Is(t, i.y, r.y, a.y, o.y)), n
            }, Ds.prototype.copy = function(t) {
                return ws.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, Ds.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, Ds.prototype.fromJSON = function(t) {
                return ws.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, js.prototype = Object.create(ws.prototype), js.prototype.constructor = js, js.prototype.isCubicBezierCurve3 = !0, js.prototype.getPoint = function(t, e) {
                var n = e || new ze,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3;
                return n.set(Is(t, i.x, r.x, a.x, o.x), Is(t, i.y, r.y, a.y, o.y), Is(t, i.z, r.z, a.z, o.z)), n
            }, js.prototype.copy = function(t) {
                return ws.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, js.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, js.prototype.fromJSON = function(t) {
                return ws.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Ns.prototype = Object.create(ws.prototype), Ns.prototype.constructor = Ns, Ns.prototype.isLineCurve = !0, Ns.prototype.getPoint = function(t, e) {
                var n = e || new je;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, Ns.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Ns.prototype.getTangent = function() {
                return this.v2.clone().sub(this.v1).normalize()
            }, Ns.prototype.copy = function(t) {
                return ws.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ns.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ns.prototype.fromJSON = function(t) {
                return ws.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, ks.prototype = Object.create(ws.prototype), ks.prototype.constructor = ks, ks.prototype.isLineCurve3 = !0, ks.prototype.getPoint = function(t, e) {
                var n = e || new ze;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, ks.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, ks.prototype.copy = function(t) {
                return ws.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, ks.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, ks.prototype.fromJSON = function(t) {
                return ws.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, zs.prototype = Object.create(ws.prototype), zs.prototype.constructor = zs, zs.prototype.isQuadraticBezierCurve = !0, zs.prototype.getPoint = function(t, e) {
                var n = e || new je,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2;
                return n.set(Rs(t, i.x, r.x, a.x), Rs(t, i.y, r.y, a.y)), n
            }, zs.prototype.copy = function(t) {
                return ws.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, zs.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, zs.prototype.fromJSON = function(t) {
                return ws.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Bs.prototype = Object.create(ws.prototype), Bs.prototype.constructor = Bs, Bs.prototype.isQuadraticBezierCurve3 = !0, Bs.prototype.getPoint = function(t, e) {
                var n = e || new ze,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2;
                return n.set(Rs(t, i.x, r.x, a.x), Rs(t, i.y, r.y, a.y), Rs(t, i.z, r.z, a.z)), n
            }, Bs.prototype.copy = function(t) {
                return ws.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Bs.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Bs.prototype.fromJSON = function(t) {
                return ws.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Us.prototype = Object.create(ws.prototype), Us.prototype.constructor = Us, Us.prototype.isSplineCurve = !0, Us.prototype.getPoint = function(t, e) {
                var n = e || new je,
                    i = this.points,
                    r = (i.length - 1) * t,
                    a = Math.floor(r),
                    o = r - a,
                    s = i[0 === a ? a : a - 1],
                    c = i[a],
                    u = i[a > i.length - 2 ? i.length - 1 : a + 1],
                    l = i[a > i.length - 3 ? i.length - 1 : a + 2];
                return n.set(Cs(o, s.x, c.x, u.x, l.x), Cs(o, s.y, c.y, u.y, l.y)), n
            }, Us.prototype.copy = function(t) {
                ws.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push(i.clone())
                }
                return this
            }, Us.prototype.toJSON = function() {
                var t = ws.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t
            }, Us.prototype.fromJSON = function(t) {
                ws.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var i = t.points[e];
                    this.points.push((new je).fromArray(i))
                }
                return this
            };
            var Gs = Object.freeze({
                ArcCurve: Ts,
                CatmullRomCurve3: Os,
                CubicBezierCurve: Ds,
                CubicBezierCurve3: js,
                EllipseCurve: Ms,
                LineCurve: Ns,
                LineCurve3: ks,
                QuadraticBezierCurve: zs,
                QuadraticBezierCurve3: Bs,
                SplineCurve: Us
            });

            function Fs() {
                ws.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function Hs(t) {
                Fs.call(this), this.type = "Path", this.currentPoint = new je, t && this.setFromPoints(t)
            }

            function Vs(t) {
                Hs.call(this, t), this.uuid = De.generateUUID(), this.type = "Shape", this.holes = []
            }

            function Ws(t, e) {
                Sn.call(this), this.type = "Light", this.color = new hn(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }

            function qs(t, e, n) {
                Ws.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Sn.DefaultUp), this.updateMatrix(), this.groundColor = new hn(e)
            }

            function Xs(t) {
                this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new je(512, 512), this.map = null, this.matrix = new Ne
            }

            function Ys() {
                Xs.call(this, new qr(50, 1, .5, 500))
            }

            function Zs(t, e, n, i, r, a) {
                Ws.call(this, t, e), this.type = "SpotLight", this.position.copy(Sn.DefaultUp), this.updateMatrix(), this.target = new Sn, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Ys
            }

            function Js(t, e, n, i) {
                Ws.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Xs(new qr(90, 1, .5, 500))
            }

            function Ks(t, e, n, i, r, a) {
                Wr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
            }

            function Qs() {
                Xs.call(this, new Ks(-5, 5, 5, -5, .5, 500))
            }

            function $s(t, e) {
                Ws.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Sn.DefaultUp), this.updateMatrix(), this.target = new Sn, this.shadow = new Qs
            }

            function tc(t, e) {
                Ws.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }

            function ec(t, e, n, i) {
                Ws.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }

            function nc(t) {
                this.manager = void 0 !== t ? t : ms, this.textures = {}
            }
            Fs.prototype = Object.assign(Object.create(ws.prototype), {
                constructor: Fs,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new Ns(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                        if (n[i] >= e) {
                            var r = n[i] - e,
                                a = this.curves[i],
                                o = a.getLength(),
                                s = 0 === o ? 0 : 1 - r / o;
                            return a.getPointAt(s)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
                        for (var a = r[i], o = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), c = 0; c < s.length; c++) {
                            var u = s[c];
                            e && e.equals(u) || (n.push(u), e = u)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function(t) {
                    ws.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = ws.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, n = this.curves.length; e < n; e++) {
                        var i = this.curves[e];
                        t.curves.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    ws.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var i = t.curves[e];
                        this.curves.push((new Gs[i.type]).fromJSON(i))
                    }
                    return this
                }
            }), Hs.prototype = Object.assign(Object.create(Fs.prototype), {
                constructor: Hs,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var n = new Ns(this.currentPoint.clone(), new je(t, e));
                    this.curves.push(n), this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    var r = new zs(this.currentPoint.clone(), new je(t, e), new je(n, i));
                    this.curves.push(r), this.currentPoint.set(n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, a) {
                    var o = new Ds(this.currentPoint.clone(), new je(t, e), new je(n, i), new je(r, a));
                    this.curves.push(o), this.currentPoint.set(r, a)
                },
                splineThru: function(t) {
                    var e = new Us([this.currentPoint.clone()].concat(t));
                    this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, n, i, r, a) {
                    var o = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(t + o, e + s, n, i, r, a)
                },
                absarc: function(t, e, n, i, r, a) {
                    this.absellipse(t, e, n, n, i, r, a)
                },
                ellipse: function(t, e, n, i, r, a, o, s) {
                    var c = this.currentPoint.x,
                        u = this.currentPoint.y;
                    this.absellipse(t + c, e + u, n, i, r, a, o, s)
                },
                absellipse: function(t, e, n, i, r, a, o, s) {
                    var c = new Ms(t, e, n, i, r, a, o, s);
                    if (this.curves.length > 0) {
                        var u = c.getPoint(0);
                        u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
                    }
                    this.curves.push(c);
                    var l = c.getPoint(1);
                    this.currentPoint.copy(l)
                },
                copy: function(t) {
                    return Fs.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = Fs.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return Fs.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), Vs.prototype = Object.assign(Object.create(Hs.prototype), {
                constructor: Vs,
                getPointsHoles: function(t) {
                    for (var e = [], n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    Hs.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push(i.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = Hs.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, n = this.holes.length; e < n; e++) {
                        var i = this.holes[e];
                        t.holes.push(i.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    Hs.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var i = t.holes[e];
                        this.holes.push((new Hs).fromJSON(i))
                    }
                    return this
                }
            }), Ws.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: Ws,
                isLight: !0,
                copy: function(t) {
                    return Sn.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = Sn.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), qs.prototype = Object.assign(Object.create(Ws.prototype), {
                constructor: qs,
                isHemisphereLight: !0,
                copy: function(t) {
                    return Ws.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(Xs.prototype, {
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), Ys.prototype = Object.assign(Object.create(Xs.prototype), {
                constructor: Ys,
                isSpotLightShadow: !0,
                update: function(t) {
                    var e = this.camera,
                        n = 2 * De.RAD2DEG * t.angle,
                        i = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix())
                }
            }), Zs.prototype = Object.assign(Object.create(Ws.prototype), {
                constructor: Zs,
                isSpotLight: !0,
                copy: function(t) {
                    return Ws.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Js.prototype = Object.assign(Object.create(Ws.prototype), {
                constructor: Js,
                isPointLight: !0,
                copy: function(t) {
                    return Ws.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), Ks.prototype = Object.assign(Object.create(Wr.prototype), {
                constructor: Ks,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return Wr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, n, i, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - t,
                        a = n + t,
                        o = i + e,
                        s = i - e;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            u = this.zoom / (this.view.height / this.view.fullHeight),
                            l = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        a = (r += l * (this.view.offsetX / c)) + l * (this.view.width / c), s = (o -= h * (this.view.offsetY / u)) - h * (this.view.height / u)
                    }
                    this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = Sn.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), Qs.prototype = Object.assign(Object.create(Xs.prototype), {
                constructor: Qs
            }), $s.prototype = Object.assign(Object.create(Ws.prototype), {
                constructor: $s,
                isDirectionalLight: !0,
                copy: function(t) {
                    return Ws.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), tc.prototype = Object.assign(Object.create(Ws.prototype), {
                constructor: tc,
                isAmbientLight: !0
            }), ec.prototype = Object.assign(Object.create(Ws.prototype), {
                constructor: ec,
                isRectAreaLight: !0,
                copy: function(t) {
                    return Ws.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = Ws.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }), Object.assign(nc.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = new gs(r.manager);
                    a.setPath(r.path), a.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                parse: function(t) {
                    var e = this.textures;

                    function n(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    var i = new Ko[t.type];
                    if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearCoat && (i.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (i.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (i.vertexColors = t.vertexColors), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.uniforms)
                        for (var r in t.uniforms) {
                            var a = t.uniforms[r];
                            switch (i.uniforms[r] = {}, a.type) {
                                case "t":
                                    i.uniforms[r].value = n(a.value);
                                    break;
                                case "c":
                                    i.uniforms[r].value = (new hn).setHex(a.value);
                                    break;
                                case "v2":
                                    i.uniforms[r].value = (new je).fromArray(a.value);
                                    break;
                                case "v3":
                                    i.uniforms[r].value = (new ze).fromArray(a.value);
                                    break;
                                case "v4":
                                    i.uniforms[r].value = (new Ye).fromArray(a.value);
                                    break;
                                case "m3":
                                    i.uniforms[r].value = (new Be).fromArray(a.value);
                                case "m4":
                                    i.uniforms[r].value = (new Ne).fromArray(a.value);
                                    break;
                                default:
                                    i.uniforms[r].value = a.value
                            }
                        }
                    if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                        for (var o in t.extensions) i.extensions[o] = t.extensions[o];
                    if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap), i.transparent = !0), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                        var s = t.normalScale;
                        !1 === Array.isArray(s) && (s = [s, s]), i.normalScale = (new je).fromArray(s)
                    }
                    return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), i
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            var ic = function(t) {
                var e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            };

            function rc(t) {
                this.manager = void 0 !== t ? t : ms
            }
            Object.assign(rc.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = new gs(r.manager);
                    a.setPath(r.path), a.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, n, i)
                },
                parse: function(t) {
                    var e = new Hn,
                        n = t.data.index;
                    if (void 0 !== n) {
                        var i = new ac[n.type](n.array);
                        e.setIndex(new On(i, 1))
                    }
                    var r = t.data.attributes;
                    for (var a in r) {
                        var o = r[a];
                        i = new ac[o.type](o.array);
                        e.addAttribute(a, new On(i, o.itemSize, o.normalized))
                    }
                    var s = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== s)
                        for (var c = 0, u = s.length; c !== u; ++c) {
                            var l = s[c];
                            e.addGroup(l.start, l.count, l.materialIndex)
                        }
                    var h = t.data.boundingSphere;
                    if (void 0 !== h) {
                        var d = new ze;
                        void 0 !== h.center && d.fromArray(h.center), e.boundingSphere = new tn(d, h.radius)
                    }
                    return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            });
            var ac = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function oc(t) {
                this.manager = void 0 !== t ? t : ms, this.resourcePath = ""
            }
            Object.assign(oc.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, i) {
                    var r = this,
                        a = void 0 === this.path ? ic(t) : this.path;
                    this.resourcePath = this.resourcePath || a;
                    var o = new gs(r.manager);
                    o.setPath(this.path), o.load(t, function(n) {
                        var a = null;
                        try {
                            a = JSON.parse(n)
                        } catch (s) {
                            return void 0 !== i && i(s), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", s.message)
                        }
                        var o = a.metadata;
                        void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? r.parse(a, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                    }, n, i)
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(t, e) {
                    var n = this.parseShape(t.shapes),
                        i = this.parseGeometries(t.geometries, n),
                        r = this.parseImages(t.images, function() {
                            void 0 !== e && e(s)
                        }),
                        a = this.parseTextures(t.textures, r),
                        o = this.parseMaterials(t.materials, a),
                        s = this.parseObject(t.object, i, o);
                    return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var n = 0, i = t.length; n < i; n++) {
                            var r = (new Vs).fromJSON(t[n]);
                            e[r.uuid] = r
                        }
                    return e
                },
                parseGeometries: function(t, e) {
                    var n = {};
                    if (void 0 !== t)
                        for (var i = new rc, r = 0, a = t.length; r < a; r++) {
                            var o, s = t[r];
                            switch (s.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    o = new Uo[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    o = new Uo[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    o = new Uo[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    o = new Uo[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    o = new Uo[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    o = new Uo[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    o = new Uo[s.type](s.radius, s.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    o = new Uo[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    o = new Uo[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    o = new Uo[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    o = new Uo[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    o = new Uo[s.type](s.vertices, s.indices, s.radius, s.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var c = [], u = 0, l = s.shapes.length; u < l; u++) {
                                        var h = e[s.shapes[u]];
                                        c.push(h)
                                    }
                                    o = new Uo[s.type](c, s.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (c = [], u = 0, l = s.shapes.length; u < l; u++) {
                                        h = e[s.shapes[u]];
                                        c.push(h)
                                    }
                                    var d = s.options.extrudePath;
                                    void 0 !== d && (s.options.extrudePath = (new Gs[d.type]).fromJSON(d)), o = new Uo[s.type](c, s.options);
                                    break;
                                case "BufferGeometry":
                                    o = i.parse(s);
                                    break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in THREE) o = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                                    else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                    continue
                            }
                            o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData), n[s.uuid] = o
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var n = {},
                        i = {};
                    if (void 0 !== t) {
                        var r = new nc;
                        r.setTextures(e);
                        for (var a = 0, o = t.length; a < o; a++) {
                            var s = t[a];
                            if ("MultiMaterial" === s.type) {
                                for (var c = [], u = 0; u < s.materials.length; u++) {
                                    var l = s.materials[u];
                                    void 0 === n[l.uuid] && (n[l.uuid] = r.parse(l)), c.push(n[l.uuid])
                                }
                                i[s.uuid] = c
                            } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid]
                        }
                    }
                    return i
                },
                parseAnimations: function(t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                        var i = t[n],
                            r = hs.parse(i);
                        void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var n = this,
                        i = {};

                    function r(t) {
                        return n.manager.itemStart(t), a.load(t, function() {
                            n.manager.itemEnd(t)
                        }, void 0, function() {
                            n.manager.itemError(t), n.manager.itemEnd(t)
                        })
                    }
                    if (void 0 !== t && t.length > 0) {
                        var a = new xs(new fs(e));
                        a.setCrossOrigin(this.crossOrigin);
                        for (var o = 0, s = t.length; o < s; o++) {
                            var c = t[o],
                                u = c.url;
                            if (Array.isArray(u)) {
                                i[c.uuid] = [];
                                for (var l = 0, h = u.length; l < h; l++) {
                                    var d = u[l],
                                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                                    i[c.uuid].push(r(p))
                                }
                            } else {
                                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.resourcePath + c.url;
                                i[c.uuid] = r(p)
                            }
                        }
                    }
                    return i
                },
                parseTextures: function(t, e) {
                    function n(t, e) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                    }
                    var i = {};
                    if (void 0 !== t)
                        for (var r = 0, a = t.length; r < a; r++) {
                            var o, s = t[r];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (o = Array.isArray(e[s.image]) ? new Ti(e[s.image]) : new Xe(e[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = n(s.mapping, dc)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], pc), o.wrapT = n(s.wrap[1], pc)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, fc)), void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, fc)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), i[s.uuid] = o
                        }
                    return i
                },
                parseObject: function(t, e, n) {
                    var i;

                    function r(t) {
                        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                    }

                    function a(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], i = 0, r = t.length; i < r; i++) {
                                    var a = t[i];
                                    void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), e.push(n[a])
                                }
                                return e
                            }
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            i = new ca, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new hn(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new sa(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new oa(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            i = new qr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            i = new Ks(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            i = new tc(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            i = new $s(t.color, t.intensity);
                            break;
                        case "PointLight":
                            i = new Js(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            i = new ec(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            i = new Zs(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            i = new qs(t.color, t.groundColor, t.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var o = r(t.geometry),
                                s = a(t.material);
                            i = o.bones && o.bones.length > 0 ? new fa(o, s) : new di(o, s), void 0 !== t.drawMode && i.setDrawMode(t.drawMode);
                            break;
                        case "LOD":
                            i = new pa;
                            break;
                        case "Line":
                            i = new ya(r(t.geometry), a(t.material), t.mode);
                            break;
                        case "LineLoop":
                            i = new ba(r(t.geometry), a(t.material));
                            break;
                        case "LineSegments":
                            i = new xa(r(t.geometry), a(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            i = new wa(r(t.geometry), a(t.material));
                            break;
                        case "Sprite":
                            i = new da(a(t.material));
                            break;
                        case "Group":
                            i = new Vr;
                            break;
                        default:
                            i = new Sn
                    }
                    if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children)
                        for (var c = t.children, u = 0; u < c.length; u++) i.add(this.parseObject(c[u], e, n));
                    if ("LOD" === t.type)
                        for (var l = t.levels, h = 0; h < l.length; h++) {
                            var d = l[h],
                                p = i.getObjectByProperty("uuid", d.object);
                            void 0 !== p && i.addLevel(p, d.distance)
                        }
                    return i
                }
            });
            var sc, cc, uc, lc, hc, dc = {
                    UVMapping: 300,
                    CubeReflectionMapping: pt,
                    CubeRefractionMapping: ft,
                    EquirectangularReflectionMapping: mt,
                    EquirectangularRefractionMapping: vt,
                    SphericalReflectionMapping: gt,
                    CubeUVReflectionMapping: yt,
                    CubeUVRefractionMapping: xt
                },
                pc = {
                    RepeatWrapping: bt,
                    ClampToEdgeWrapping: _t,
                    MirroredRepeatWrapping: wt
                },
                fc = {
                    NearestFilter: Mt,
                    NearestMipMapNearestFilter: Tt,
                    NearestMipMapLinearFilter: St,
                    LinearFilter: Et,
                    LinearMipMapNearestFilter: At,
                    LinearMipMapLinearFilter: Lt
                };

            function mc(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : ms, this.options = void 0
            }

            function vc() {
                this.type = "ShapePath", this.color = new hn, this.subPaths = [], this.currentPath = null
            }

            function gc(t) {
                this.type = "Font", this.data = t
            }

            function yc(t, e, n, i, r) {
                var a = r.glyphs[t] || r.glyphs["?"];
                if (a) {
                    var o, s, c, u, l, h, d, p, f = new vc;
                    if (a.o)
                        for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g;) {
                            switch (m[v++]) {
                                case "m":
                                    o = m[v++] * e + n, s = m[v++] * e + i, f.moveTo(o, s);
                                    break;
                                case "l":
                                    o = m[v++] * e + n, s = m[v++] * e + i, f.lineTo(o, s);
                                    break;
                                case "q":
                                    c = m[v++] * e + n, u = m[v++] * e + i, l = m[v++] * e + n, h = m[v++] * e + i, f.quadraticCurveTo(l, h, c, u);
                                    break;
                                case "b":
                                    c = m[v++] * e + n, u = m[v++] * e + i, l = m[v++] * e + n, h = m[v++] * e + i, d = m[v++] * e + n, p = m[v++] * e + i, f.bezierCurveTo(l, h, d, p, c, u)
                            }
                        }
                    return {
                        offsetX: a.ha * e,
                        path: f
                    }
                }
            }

            function xc() {}
            mc.prototype = {
                constructor: mc,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        a = ps.get(t);
                    if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(a), r.manager.itemEnd(t)
                    }, 0), a;
                    fetch(t).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return createImageBitmap(t, r.options)
                    }).then(function(n) {
                        ps.add(t, n), e && e(n), r.manager.itemEnd(t)
                    }).catch(function(e) {
                        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    })
                },
                setCrossOrigin: function() {
                    return this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }, Object.assign(vc.prototype, {
                moveTo: function(t, e) {
                    this.currentPath = new Hs, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, n, i) {
                    this.currentPath.quadraticCurveTo(t, e, n, i)
                },
                bezierCurveTo: function(t, e, n, i, r, a) {
                    this.currentPath.bezierCurveTo(t, e, n, i, r, a)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(t, e) {
                    function n(t) {
                        for (var e = [], n = 0, i = t.length; n < i; n++) {
                            var r = t[n],
                                a = new Vs;
                            a.curves = r.curves, e.push(a)
                        }
                        return e
                    }

                    function i(t, e) {
                        for (var n = e.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
                            var o = e[r],
                                s = e[a],
                                c = s.x - o.x,
                                u = s.y - o.y;
                            if (Math.abs(u) > Number.EPSILON) {
                                if (u < 0 && (o = e[a], c = -c, s = e[r], u = -u), t.y < o.y || t.y > s.y) continue;
                                if (t.y === o.y) {
                                    if (t.x === o.x) return !0
                                } else {
                                    var l = u * (t.x - o.x) - c * (t.y - o.y);
                                    if (0 === l) return !0;
                                    if (l < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== o.y) continue;
                                if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !0
                            }
                        }
                        return i
                    }
                    var r = mo.isClockWise,
                        a = this.subPaths;
                    if (0 === a.length) return [];
                    if (!0 === e) return n(a);
                    var o, s, c, u = [];
                    if (1 === a.length) return s = a[0], (c = new Vs).curves = s.curves, u.push(c), u;
                    var l = !r(a[0].getPoints());
                    l = t ? !l : l;
                    var h, d, p = [],
                        f = [],
                        m = [],
                        v = 0;
                    f[v] = void 0, m[v] = [];
                    for (var g = 0, y = a.length; g < y; g++) o = r(h = (s = a[g]).getPoints()), (o = t ? !o : o) ? (!l && f[v] && v++, f[v] = {
                        s: new Vs,
                        p: h
                    }, f[v].s.curves = s.curves, l && v++, m[v] = []) : m[v].push({
                        h: s,
                        p: h[0]
                    });
                    if (!f[0]) return n(a);
                    if (f.length > 1) {
                        for (var x = !1, b = [], _ = 0, w = f.length; _ < w; _++) p[_] = [];
                        for (_ = 0, w = f.length; _ < w; _++)
                            for (var M = m[_], T = 0; T < M.length; T++) {
                                for (var S = M[T], E = !0, A = 0; A < f.length; A++) i(S.p, f[A].p) && (_ !== A && b.push({
                                    froms: _,
                                    tos: A,
                                    hole: T
                                }), E ? (E = !1, p[A].push(S)) : x = !0);
                                E && p[_].push(S)
                            }
                        b.length > 0 && (x || (m = p))
                    }
                    g = 0;
                    for (var L = f.length; g < L; g++) {
                        c = f[g].s, u.push(c);
                        for (var P = 0, O = (d = m[g]).length; P < O; P++) c.holes.push(d[P].h)
                    }
                    return u
                }
            }), Object.assign(gc.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    for (var n = [], i = function(t, e, n) {
                            for (var i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, o = [], s = 0, c = 0, u = 0; u < i.length; u++) {
                                var l = i[u];
                                if ("\n" === l) s = 0, c -= a;
                                else {
                                    var h = yc(l, r, s, c, n);
                                    s += h.offsetX, o.push(h.path)
                                }
                            }
                            return o
                        }(t, e, this.data), r = 0, a = i.length; r < a; r++) Array.prototype.push.apply(n, i[r].toShapes());
                    return n
                }
            }), Object.assign(function(t) {
                this.manager = void 0 !== t ? t : ms
            }.prototype, {
                load: function(t, e, n, i) {
                    var r = this,
                        a = new gs(this.manager);
                    a.setPath(this.path), a.load(t, function(t) {
                        var n;
                        try {
                            n = JSON.parse(t)
                        } catch (a) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var i = r.parse(n);
                        e && e(i)
                    }, n, i)
                },
                parse: function(t) {
                    return new gc(t)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), xc.Handlers = {
                handlers: [],
                add: function(t, e) {
                    this.handlers.push(t, e)
                },
                get: function(t) {
                    for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
                        var r = e[n],
                            a = e[n + 1];
                        if (r.test(t)) return a
                    }
                    return null
                }
            }, Object.assign(xc.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function() {},
                onLoadProgress: function() {},
                onLoadComplete: function() {},
                initMaterials: function(t, e, n) {
                    for (var i = [], r = 0; r < t.length; ++r) i[r] = this.createMaterial(t[r], e, n);
                    return i
                },
                createMaterial: (sc = {
                    NoBlending: L,
                    NormalBlending: P,
                    AdditiveBlending: O,
                    SubtractiveBlending: C,
                    MultiplyBlending: R,
                    CustomBlending: I
                }, cc = new hn, uc = new _s, lc = new nc, function(t, e, n) {
                    var i = {};

                    function r(t, r, a, o, s) {
                        var c, u = e + t,
                            l = xc.Handlers.get(u);
                        null !== l ? c = l.load(u) : (uc.setCrossOrigin(n), c = uc.load(u)), void 0 !== r && (c.repeat.fromArray(r), 1 !== r[0] && (c.wrapS = bt), 1 !== r[1] && (c.wrapT = bt)), void 0 !== a && c.offset.fromArray(a), void 0 !== o && ("repeat" === o[0] && (c.wrapS = bt), "mirror" === o[0] && (c.wrapS = wt), "repeat" === o[1] && (c.wrapT = bt), "mirror" === o[1] && (c.wrapT = wt)), void 0 !== s && (c.anisotropy = s);
                        var h = De.generateUUID();
                        return i[h] = c, h
                    }
                    var a = {
                        uuid: De.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                    for (var o in t) {
                        var s = t[o];
                        switch (o) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                a.name = s;
                                break;
                            case "blending":
                                a.blending = sc[s];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", o, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                a.color = cc.fromArray(s).getHex();
                                break;
                            case "colorSpecular":
                                a.specular = cc.fromArray(s).getHex();
                                break;
                            case "colorEmissive":
                                a.emissive = cc.fromArray(s).getHex();
                                break;
                            case "specularCoef":
                                a.shininess = s;
                                break;
                            case "shading":
                                "basic" === s.toLowerCase() && (a.type = "MeshBasicMaterial"), "phong" === s.toLowerCase() && (a.type = "MeshPhongMaterial"), "standard" === s.toLowerCase() && (a.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                a.map = r(s, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                a.emissiveMap = r(s, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                a.lightMap = r(s, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                a.aoMap = r(s, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                a.bumpMap = r(s, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                a.bumpScale = s;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                a.normalMap = r(s, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                a.normalScale = s;
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                a.specularMap = r(s, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                a.metalnessMap = r(s, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                a.roughnessMap = r(s, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                a.alphaMap = r(s, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                a.side = M;
                                break;
                            case "doubleSided":
                                a.side = T;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), a.opacity = s;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                a[o] = s;
                                break;
                            case "vertexColors":
                                !0 === s && (a.vertexColors = A), "face" === s && (a.vertexColors = E);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", o, s)
                        }
                    }
                    return "MeshBasicMaterial" === a.type && delete a.emissive, "MeshPhongMaterial" !== a.type && delete a.specular, a.opacity < 1 && (a.transparent = !0), lc.setTextures(i), lc.parse(a)
                })
            });
            var bc, _c, wc, Mc, Tc, Sc, Ec, Ac, Lc, Pc, Oc = {
                getContext: function() {
                    return void 0 === hc && (hc = new(window.AudioContext || window.webkitAudioContext)), hc
                },
                setContext: function(t) {
                    hc = t
                }
            };

            function Cc(t) {
                this.manager = void 0 !== t ? t : ms
            }

            function Rc(t, e, n, i) {
                Sn.call(this), this.type = "CubeCamera";
                var r = new qr(90, 1, t, e);
                r.up.set(0, -1, 0), r.lookAt(new ze(1, 0, 0)), this.add(r);
                var a = new qr(90, 1, t, e);
                a.up.set(0, -1, 0), a.lookAt(new ze(-1, 0, 0)), this.add(a);
                var o = new qr(90, 1, t, e);
                o.up.set(0, 0, 1), o.lookAt(new ze(0, 1, 0)), this.add(o);
                var s = new qr(90, 1, t, e);
                s.up.set(0, 0, -1), s.lookAt(new ze(0, -1, 0)), this.add(s);
                var c = new qr(90, 1, t, e);
                c.up.set(0, -1, 0), c.lookAt(new ze(0, 0, 1)), this.add(c);
                var u = new qr(90, 1, t, e);
                u.up.set(0, -1, 0), u.lookAt(new ze(0, 0, -1)), this.add(u), i = i || {
                    format: Ft,
                    magFilter: Et,
                    minFilter: Et
                }, this.renderTarget = new Ke(n, n, i), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = t.getRenderTarget(),
                        i = this.renderTarget,
                        l = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, r, i), i.activeCubeFace = 1, t.render(e, a, i), i.activeCubeFace = 2, t.render(e, o, i), i.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, c, i), i.texture.generateMipmaps = l, i.activeCubeFace = 5, t.render(e, u, i), t.setRenderTarget(n)
                }, this.clear = function(t, e, n, i) {
                    for (var r = t.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++) a.activeCubeFace = o, t.setRenderTarget(a), t.clear(e, n, i);
                    t.setRenderTarget(r)
                }
            }

            function Ic(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function Dc() {
                Sn.call(this), this.type = "AudioListener", this.context = Oc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
            }

            function jc(t) {
                Sn.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function Nc(t) {
                jc.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function kc(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }

            function zc(t, e, n) {
                this.binding = t, this.valueSize = n;
                var i, r = Float64Array;
                switch (e) {
                    case "quaternion":
                        i = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, i = this._select;
                        break;
                    default:
                        i = this._lerp
                }
                this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(Cc.prototype, {
                load: function(t, e, n, i) {
                    var r = new gs(this.manager);
                    r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function(t) {
                        var n = t.slice(0);
                        Oc.getContext().decodeAudioData(n, function(t) {
                            e(t)
                        })
                    }, n, i)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(function() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new qr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new qr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }.prototype, {
                update: (Lc = new Ne, Pc = new Ne, function(t) {
                    if (bc !== this || _c !== t.focus || wc !== t.fov || Mc !== t.aspect * this.aspect || Tc !== t.near || Sc !== t.far || Ec !== t.zoom || Ac !== this.eyeSep) {
                        bc = this, _c = t.focus, wc = t.fov, Mc = t.aspect * this.aspect, Tc = t.near, Sc = t.far, Ec = t.zoom;
                        var e, n, i = t.projectionMatrix.clone(),
                            r = (Ac = this.eyeSep / 2) * Tc / _c,
                            a = Tc * Math.tan(De.DEG2RAD * wc * .5) / Ec;
                        Pc.elements[12] = -Ac, Lc.elements[12] = Ac, e = -a * Mc + r, n = a * Mc + r, i.elements[0] = 2 * Tc / (n - e), i.elements[8] = (n + e) / (n - e), this.cameraL.projectionMatrix.copy(i), e = -a * Mc - r, n = a * Mc - r, i.elements[0] = 2 * Tc / (n - e), i.elements[8] = (n + e) / (n - e), this.cameraR.projectionMatrix.copy(i)
                    }
                    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Pc), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Lc)
                })
            }), Rc.prototype = Object.create(Sn.prototype), Rc.prototype.constructor = Rc, Object.assign(Ic.prototype, {
                start: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var e = ("undefined" == typeof performance ? Date : performance).now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }), Dc.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: Dc,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(t) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function() {
                    var t = new ze,
                        e = new ke,
                        n = new ze,
                        i = new ze,
                        r = new Ic;
                    return function(a) {
                        Sn.prototype.updateMatrixWorld.call(this, a);
                        var o = this.context.listener,
                            s = this.up;
                        if (this.timeDelta = r.getDelta(), this.matrixWorld.decompose(t, e, n), i.set(0, 0, -1).applyQuaternion(e), o.positionX) {
                            var c = this.context.currentTime + this.timeDelta;
                            o.positionX.linearRampToValueAtTime(t.x, c), o.positionY.linearRampToValueAtTime(t.y, c), o.positionZ.linearRampToValueAtTime(t.z, c), o.forwardX.linearRampToValueAtTime(i.x, c), o.forwardY.linearRampToValueAtTime(i.y, c), o.forwardZ.linearRampToValueAtTime(i.z, c), o.upX.linearRampToValueAtTime(s.x, c), o.upY.linearRampToValueAtTime(s.y, c), o.upZ.linearRampToValueAtTime(s.z, c)
                        } else o.setPosition(t.x, t.y, t.z), o.setOrientation(i.x, i.y, i.z, s.x, s.y, s.z)
                    }
                }()
            }), jc.prototype = Object.assign(Object.create(Sn.prototype), {
                constructor: jc,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                },
                setMediaElementSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                },
                setBuffer: function(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function() {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(t) {
                    return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                },
                setDetune: function(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                },
                getDetune: function() {
                    return this.detune
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(t) {
                    return this.setFilters(t ? [t] : [])
                },
                setPlaybackRate: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }), Nc.prototype = Object.assign(Object.create(jc.prototype), {
                constructor: Nc,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(t) {
                    return this.panner.refDistance = t, this
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(t) {
                    return this.panner.rolloffFactor = t, this
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(t) {
                    return this.panner.distanceModel = t, this
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(t) {
                    return this.panner.maxDistance = t, this
                },
                setDirectionalCone: function(t, e, n) {
                    return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                },
                updateMatrixWorld: function() {
                    var t = new ze,
                        e = new ke,
                        n = new ze,
                        i = new ze;
                    return function(r) {
                        if (Sn.prototype.updateMatrixWorld.call(this, r), !1 !== this.isPlaying) {
                            this.matrixWorld.decompose(t, e, n), i.set(0, 0, 1).applyQuaternion(e);
                            var a = this.panner;
                            if (a.positionX) {
                                var o = this.context.currentTime + this.listener.timeDelta;
                                a.positionX.linearRampToValueAtTime(t.x, o), a.positionY.linearRampToValueAtTime(t.y, o), a.positionZ.linearRampToValueAtTime(t.z, o), a.orientationX.linearRampToValueAtTime(i.x, o), a.orientationY.linearRampToValueAtTime(i.y, o), a.orientationZ.linearRampToValueAtTime(i.z, o)
                            } else a.setPosition(t.x, t.y, t.z), a.setOrientation(i.x, i.y, i.z)
                        }
                    }
                }()
            }), Object.assign(kc.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
                    return t / e.length
                }
            }), Object.assign(zc.prototype, {
                accumulate: function(t, e) {
                    var n = this.buffer,
                        i = this.valueSize,
                        r = t * i + i,
                        a = this.cumulativeWeight;
                    if (0 === a) {
                        for (var o = 0; o !== i; ++o) n[r + o] = n[o];
                        a = e
                    } else {
                        var s = e / (a += e);
                        this._mixBufferRegion(n, r, 0, s, i)
                    }
                    this.cumulativeWeight = a
                },
                apply: function(t) {
                    var e = this.valueSize,
                        n = this.buffer,
                        i = t * e + e,
                        r = this.cumulativeWeight,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, r < 1) {
                        var o = 3 * e;
                        this._mixBufferRegion(n, i, o, 1 - r, e)
                    }
                    for (var s = e, c = e + e; s !== c; ++s)
                        if (n[s] !== n[s + e]) {
                            a.setValue(n, i);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        i = 3 * n;
                    t.getValue(e, i);
                    for (var r = n, a = i; r !== a; ++r) e[r] = e[i + r % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _select: function(t, e, n, i, r) {
                    if (i >= .5)
                        for (var a = 0; a !== r; ++a) t[e + a] = t[n + a]
                },
                _slerp: function(t, e, n, i) {
                    ke.slerpFlat(t, e, t, e, t, n, i)
                },
                _lerp: function(t, e, n, i, r) {
                    for (var a = 1 - i, o = 0; o !== r; ++o) {
                        var s = e + o;
                        t[s] = t[s] * a + t[n + o] * i
                    }
                }
            });
            var Bc, Uc, Gc, Fc, Hc, Vc, Wc, qc, Xc, Yc, Zc, Jc, Kc, Qc, $c;

            function tu(t, e, n) {
                var i = n || eu.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }

            function eu(t, e, n) {
                this.path = e, this.parsedPath = n || eu.parseTrackName(e), this.node = eu.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function nu(t, e, n) {
                this._mixer = t, this._clip = e, this._localRoot = n || null;
                for (var i = e.tracks, r = i.length, a = new Array(r), o = {
                        endingStart: xe,
                        endingEnd: xe
                    }, s = 0; s !== r; ++s) {
                    var c = i[s].createInterpolant(null);
                    a[s] = c, c.settings = o
                }
                this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ye, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function iu(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function ru(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }

            function au() {
                Hn.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function ou(t, e, n) {
                ua.call(this, t, e), this.meshPerAttribute = n || 1
            }

            function su(t, e, n, i) {
                "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), On.call(this, t, e, n), this.meshPerAttribute = i || 1
            }

            function cu(t, e) {
                return t.distance - e.distance
            }

            function uu(t, e, n, i) {
                if (!1 !== t.visible && (t.raycast(e, n), !0 === i))
                    for (var r = t.children, a = 0, o = r.length; a < o; a++) uu(r[a], e, n, !0)
            }

            function lu(t, e) {
                this.min = void 0 !== t ? t : new je(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new je(-1 / 0, -1 / 0)
            }

            function hu(t, e) {
                this.start = void 0 !== t ? t : new ze, this.end = void 0 !== e ? e : new ze
            }

            function du(t) {
                Sn.call(this), this.material = t, this.render = function() {}
            }

            function pu(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16711680,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
                var c = new Hn,
                    u = new zn(2 * o * 3, 3);
                c.addAttribute("position", u), xa.call(this, c, new ga({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function fu(t, e) {
                Sn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var n = new Hn, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1; r < 32; r++, a++) {
                    var o = r / 32 * Math.PI * 2,
                        s = a / 32 * Math.PI * 2;
                    i.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.addAttribute("position", new zn(i, 3));
                var c = new ga({
                    fog: !1
                });
                this.cone = new xa(n, c), this.add(this.cone), this.update()
            }

            function mu(t) {
                for (var e = function t(e) {
                        var n = [];
                        e && e.isBone && n.push(e);
                        for (var i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                        return n
                    }(t), n = new Hn, i = [], r = [], a = new hn(0, 0, 1), o = new hn(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
                }
                n.addAttribute("position", new zn(i, 3)), n.addAttribute("color", new zn(r, 3));
                var u = new ga({
                    vertexColors: A,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                xa.call(this, n, u), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            function vu(t, e, n) {
                this.light = t, this.light.updateMatrixWorld(), this.color = n;
                var i = new So(e, 4, 2),
                    r = new hi({
                        wireframe: !0,
                        fog: !1
                    });
                di.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function gu(t, e) {
                this.type = "RectAreaLightHelper", this.light = t, this.color = e;
                var n = new Hn;
                n.addAttribute("position", new zn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), n.computeBoundingSphere();
                var i = new ga({
                    fog: !1
                });
                ya.call(this, n, i);
                var r = new Hn;
                r.addAttribute("position", new zn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), r.computeBoundingSphere(), this.add(new di(r, new hi({
                    side: M,
                    fog: !1
                }))), this.update()
            }

            function yu(t, e, n) {
                Sn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var i = new ja(e);
                i.rotateY(.5 * Math.PI), this.material = new hi({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = A);
                var r = i.getAttribute("position"),
                    a = new Float32Array(3 * r.count);
                i.addAttribute("color", new On(a, 3)), this.add(new di(i, this.material)), this.update()
            }

            function xu(t, e, n, i) {
                t = t || 10, e = e || 10, n = new hn(void 0 !== n ? n : 4473924), i = new hn(void 0 !== i ? i : 8947848);
                for (var r = e / 2, a = t / e, o = t / 2, s = [], c = [], u = 0, l = 0, h = -o; u <= e; u++, h += a) {
                    s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o);
                    var d = u === r ? n : i;
                    d.toArray(c, l), l += 3, d.toArray(c, l), l += 3, d.toArray(c, l), l += 3, d.toArray(c, l), l += 3
                }
                var p = new Hn;
                p.addAttribute("position", new zn(s, 3)), p.addAttribute("color", new zn(c, 3));
                var f = new ga({
                    vertexColors: A
                });
                xa.call(this, p, f)
            }

            function bu(t, e, n, i, r, a) {
                t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new hn(void 0 !== r ? r : 4473924), a = new hn(void 0 !== a ? a : 8947848);
                var o, s, c, u, l, h, d, p = [],
                    f = [];
                for (u = 0; u <= e; u++) c = u / e * (2 * Math.PI), o = Math.sin(c) * t, s = Math.cos(c) * t, p.push(0, 0, 0), p.push(o, 0, s), d = 1 & u ? r : a, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (u = 0; u <= n; u++)
                    for (d = 1 & u ? r : a, h = t - t / n * u, l = 0; l < i; l++) c = l / i * (2 * Math.PI), o = Math.sin(c) * h, s = Math.cos(c) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b), c = (l + 1) / i * (2 * Math.PI), o = Math.sin(c) * h, s = Math.cos(c) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b);
                var m = new Hn;
                m.addAttribute("position", new zn(p, 3)), m.addAttribute("color", new zn(f, 3));
                var v = new ga({
                    vertexColors: A
                });
                xa.call(this, m, v)
            }

            function _u(t, e, n, i) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== n ? n : 16776960,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new Hn,
                    u = new zn(2 * o * 3, 3);
                c.addAttribute("position", u), xa.call(this, c, new ga({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function wu(t, e, n) {
                Sn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                var i = new Hn;
                i.addAttribute("position", new zn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var r = new ga({
                    fog: !1
                });
                this.lightPlane = new ya(i, r), this.add(this.lightPlane), (i = new Hn).addAttribute("position", new zn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ya(i, r), this.add(this.targetLine), this.update()
            }

            function Mu(t) {
                var e = new Hn,
                    n = new ga({
                        color: 16777215,
                        vertexColors: E
                    }),
                    i = [],
                    r = [],
                    a = {},
                    o = new hn(16755200),
                    s = new hn(16711680),
                    c = new hn(43775),
                    u = new hn(16777215),
                    l = new hn(3355443);

                function h(t, e, n) {
                    d(t, n), d(e, n)
                }

                function d(t, e) {
                    i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(i.length / 3 - 1)
                }
                h("n1", "n2", o), h("n2", "n4", o), h("n4", "n3", o), h("n3", "n1", o), h("f1", "f2", o), h("f2", "f4", o), h("f4", "f3", o), h("f3", "f1", o), h("n1", "f1", o), h("n2", "f2", o), h("n3", "f3", o), h("n4", "f4", o), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", u), h("p", "c", l), h("cn1", "cn2", l), h("cn3", "cn4", l), h("cf1", "cf2", l), h("cf3", "cf4", l), e.addAttribute("position", new zn(i, 3)), e.addAttribute("color", new zn(r, 3)), xa.call(this, e, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
            }

            function Tu(t, e) {
                this.object = t, void 0 === e && (e = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Float32Array(24),
                    r = new Hn;
                r.setIndex(new On(n, 1)), r.addAttribute("position", new On(i, 3)), xa.call(this, r, new ga({
                    color: e
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Su(t, e) {
                this.type = "Box3Helper", this.box = t;
                var n = void 0 !== e ? e : 16776960,
                    i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Hn;
                r.setIndex(new On(i, 1)), r.addAttribute("position", new zn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), xa.call(this, r, new ga({
                    color: n
                })), this.geometry.computeBoundingSphere()
            }

            function Eu(t, e, n) {
                this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var i = void 0 !== n ? n : 16776960,
                    r = new Hn;
                r.addAttribute("position", new zn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), ya.call(this, r, new ga({
                    color: i
                }));
                var a = new Hn;
                a.addAttribute("position", new zn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new di(a, new hi({
                    color: i,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function Au(t, e, n, i, r, a) {
                Sn.call(this), void 0 === t && (t = new ze(0, 0, 1)), void 0 === e && (e = new ze(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === a && (a = .2 * r), void 0 === Jc && ((Jc = new Hn).addAttribute("position", new zn([0, 0, 0, 0, 1, 0], 3)), (Kc = new jo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new ya(Jc, new ga({
                    color: i
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new di(Kc, new hi({
                    color: i
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, a)
            }

            function Lu(t) {
                var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    n = new Hn;
                n.addAttribute("position", new zn(e, 3)), n.addAttribute("color", new zn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var i = new ga({
                    vertexColors: A
                });
                xa.call(this, n, i)
            }
            Object.assign(tu.prototype, {
                    getValue: function(t, e) {
                        this.bind();
                        var n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
                    },
                    bind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                    },
                    unbind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                    }
                }), Object.assign(eu, {
                    Composite: tu,
                    create: function(t, e, n) {
                        return t && t.isAnimationObjectGroup ? new eu.Composite(t, e, n) : new eu(t, e, n)
                    },
                    sanitizeNodeName: (Xc = new RegExp("[\\[\\]\\.:\\/]", "g"), function(t) {
                        return t.replace(/\s/g, "_").replace(Xc, "")
                    }),
                    parseTrackName: (Bc = "[^\\[\\]\\.:\\/]", Uc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Gc = /((?:WC+[\/:])*)/.source.replace("WC", Bc), Fc = /(WCOD+)?/.source.replace("WCOD", Uc), Hc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Bc), Vc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Bc), Wc = new RegExp("^" + Gc + Fc + Hc + Vc + "$"), qc = ["material", "materials", "bones"], function(t) {
                        var e = Wc.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        var n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6]
                            },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && -1 !== i) {
                            var r = n.nodeName.substring(i + 1); - 1 !== qc.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }),
                    findNode: function(t, e) {
                        if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            var n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n
                        }
                        if (t.children) {
                            var i = function(t) {
                                    for (var n = 0; n < t.length; n++) {
                                        var r = t[n];
                                        if (r.name === e || r.uuid === e) return r;
                                        var a = i(r.children);
                                        if (a) return a
                                    }
                                    return null
                                },
                                r = i(t.children);
                            if (r) return r
                        }
                        return null
                    }
                }), Object.assign(eu.prototype, {
                    _getValue_unavailable: function() {},
                    _setValue_unavailable: function() {},
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function(t, e) {
                        t[e] = this.node[this.propertyName]
                    }, function(t, e) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
                    }, function(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }, function(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }],
                    SetterByBindingTypeAndVersioning: [
                        [function(t, e) {
                            this.targetObject[this.propertyName] = t[e]
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                        }, function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                            this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e]
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty.fromArray(t, e)
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                        }]
                    ],
                    getValue: function(t, e) {
                        this.bind(), this.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        this.bind(), this.setValue(t, e)
                    },
                    bind: function() {
                        var t = this.node,
                            e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName,
                            r = e.propertyIndex;
                        if (t || (t = eu.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                            if (n) {
                                var a = e.objectIndex;
                                switch (n) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (var o = 0; o < t.length; o++)
                                            if (t[o].name === a) {
                                                a = o;
                                                break
                                            } break;
                                    default:
                                        if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[n]
                                }
                                if (void 0 !== a) {
                                    if (void 0 === t[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[a]
                                }
                            }
                            var s = t[i];
                            if (void 0 !== s) {
                                var c = this.Versioning.None;
                                this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                                var u = this.BindingType.Direct;
                                if (void 0 !== r) {
                                    if ("morphTargetInfluences" === i) {
                                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                        if (t.geometry.isBufferGeometry) {
                                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                            for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                                                if (t.geometry.morphAttributes.position[o].name === r) {
                                                    r = o;
                                                    break
                                                }
                                        } else {
                                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                            for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                                                if (t.geometry.morphTargets[o].name === r) {
                                                    r = o;
                                                    break
                                                }
                                        }
                                    }
                                    u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                                this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
                            } else {
                                var l = e.nodeName;
                                console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", t)
                            }
                        } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                    },
                    unbind: function() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(eu.prototype, {
                    _getValue_unbound: eu.prototype.getValue,
                    _setValue_unbound: eu.prototype.setValue
                }), Object.assign(function() {
                    this.uuid = De.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                    var t = {};
                    this._indicesByUUID = t;
                    for (var e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                    var i = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return i._objects.length
                            },
                            get inUse() {
                                return this.total - i.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return i._bindings.length
                        }
                    }
                }.prototype, {
                    isAnimationObjectGroup: !0,
                    add: function() {
                        for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = void 0, u = 0, l = arguments.length; u !== l; ++u) {
                            var h = arguments[u],
                                d = h.uuid,
                                p = i[d];
                            if (void 0 === p) {
                                p = e++, i[d] = p, t.push(h);
                                for (var f = 0, m = s; f !== m; ++f) o[f].push(new eu(h, r[f], a[f]))
                            } else if (p < n) {
                                c = t[p];
                                var v = --n,
                                    g = t[v];
                                i[g.uuid] = p, t[p] = g, i[d] = v, t[v] = h;
                                for (f = 0, m = s; f !== m; ++f) {
                                    var y = o[f],
                                        x = y[v],
                                        b = y[p];
                                    y[p] = x, void 0 === b && (b = new eu(h, r[f], a[f])), y[v] = b
                                }
                            } else t[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = n
                    },
                    remove: function() {
                        for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, a = 0, o = arguments.length; a !== o; ++a) {
                            var s = arguments[a],
                                c = s.uuid,
                                u = n[c];
                            if (void 0 !== u && u >= e) {
                                var l = e++,
                                    h = t[l];
                                n[h.uuid] = u, t[u] = h, n[c] = l, t[l] = s;
                                for (var d = 0, p = r; d !== p; ++d) {
                                    var f = i[d],
                                        m = f[l],
                                        v = f[u];
                                    f[u] = m, f[l] = v
                                }
                            }
                        }
                        this.nCachedObjects_ = e
                    },
                    uncache: function() {
                        for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                            var c = arguments[o].uuid,
                                u = i[c];
                            if (void 0 !== u)
                                if (delete i[c], u < n) {
                                    var l = --n,
                                        h = t[l],
                                        d = t[g = --e];
                                    i[h.uuid] = u, t[u] = h, i[d.uuid] = l, t[l] = d, t.pop();
                                    for (var p = 0, f = a; p !== f; ++p) {
                                        var m = (y = r[p])[l],
                                            v = y[g];
                                        y[u] = m, y[l] = v, y.pop()
                                    }
                                } else {
                                    var g;
                                    i[(d = t[g = --e]).uuid] = u, t[u] = d, t.pop();
                                    for (p = 0, f = a; p !== f; ++p) {
                                        var y;
                                        (y = r[p])[u] = y[g], y.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = n
                    },
                    subscribe_: function(t, e) {
                        var n = this._bindingsIndicesByPath,
                            i = n[t],
                            r = this._bindings;
                        if (void 0 !== i) return r[i];
                        var a = this._paths,
                            o = this._parsedPaths,
                            s = this._objects,
                            c = s.length,
                            u = this.nCachedObjects_,
                            l = new Array(c);
                        i = r.length, n[t] = i, a.push(t), o.push(e), r.push(l);
                        for (var h = u, d = s.length; h !== d; ++h) {
                            var p = s[h];
                            l[h] = new eu(p, t, e)
                        }
                        return l
                    },
                    unsubscribe_: function(t) {
                        var e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            var i = this._paths,
                                r = this._parsedPaths,
                                a = this._bindings,
                                o = a.length - 1,
                                s = a[o];
                            e[t[o]] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                        }
                    }
                }), Object.assign(nu.prototype, {
                    play: function() {
                        return this._mixer._activateAction(this), this
                    },
                    stop: function() {
                        return this._mixer._deactivateAction(this), this.reset()
                    },
                    reset: function() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    },
                    isRunning: function() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    },
                    isScheduled: function() {
                        return this._mixer._isActiveAction(this)
                    },
                    startAt: function(t) {
                        return this._startTime = t, this
                    },
                    setLoop: function(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    },
                    setEffectiveWeight: function(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    },
                    getEffectiveWeight: function() {
                        return this._effectiveWeight
                    },
                    fadeIn: function(t) {
                        return this._scheduleFading(t, 0, 1)
                    },
                    fadeOut: function(t) {
                        return this._scheduleFading(t, 1, 0)
                    },
                    crossFadeFrom: function(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            var i = this._clip.duration,
                                r = t._clip.duration,
                                a = r / i,
                                o = i / r;
                            t.warp(1, a, e), this.warp(o, 1, e)
                        }
                        return this
                    },
                    crossFadeTo: function(t, e, n) {
                        return t.crossFadeFrom(this, e, n)
                    },
                    stopFading: function() {
                        var t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    setEffectiveTimeScale: function(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    },
                    getEffectiveTimeScale: function() {
                        return this._effectiveTimeScale
                    },
                    setDuration: function(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    },
                    syncWith: function(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    },
                    halt: function(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    },
                    warp: function(t, e, n) {
                        var i = this._mixer,
                            r = i.time,
                            a = this._timeScaleInterpolant,
                            o = this.timeScale;
                        null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
                        var s = a.parameterPositions,
                            c = a.sampleValues;
                        return s[0] = r, s[1] = r + n, c[0] = t / o, c[1] = e / o, this
                    },
                    stopWarping: function() {
                        var t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    getMixer: function() {
                        return this._mixer
                    },
                    getClip: function() {
                        return this._clip
                    },
                    getRoot: function() {
                        return this._localRoot || this._mixer._root
                    },
                    _update: function(t, e, n, i) {
                        if (this.enabled) {
                            var r = this._startTime;
                            if (null !== r) {
                                var a = (t - r) * n;
                                if (a < 0 || 0 === n) return;
                                this._startTime = null, e = n * a
                            }
                            e *= this._updateTimeScale(t);
                            var o = this._updateTime(e),
                                s = this._updateWeight(t);
                            if (s > 0)
                                for (var c = this._interpolants, u = this._propertyBindings, l = 0, h = c.length; l !== h; ++l) c[l].evaluate(o), u[l].accumulate(i, s)
                        } else this._updateWeight(t)
                    },
                    _updateWeight: function(t) {
                        var e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            var n = this._weightInterpolant;
                            if (null !== n) {
                                var i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    },
                    _updateTimeScale: function(t) {
                        var e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            var n = this._timeScaleInterpolant;
                            if (null !== n) e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                        return this._effectiveTimeScale = e, e
                    },
                    _updateTime: function(t) {
                        var e = this.time + t,
                            n = this._clip.duration,
                            i = this.loop,
                            r = this._loopCount,
                            a = 2202 === i;
                        if (0 === t) return -1 === r ? e : a && 1 == (1 & r) ? n - e : e;
                        if (2200 === i) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (e >= n) e = n;
                                else {
                                    if (!(e < 0)) break t;
                                    e = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), e >= n || e < 0) {
                                var o = Math.floor(e / n);
                                e -= n * o, r += Math.abs(o);
                                var s = this.repetitions - r;
                                if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === s) {
                                        var c = t < 0;
                                        this._setEndings(c, !c, a)
                                    } else this._setEndings(!1, !1, a);
                                    this._loopCount = r, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: o
                                    })
                                }
                            }
                            if (a && 1 == (1 & r)) return this.time = e, n - e
                        }
                        return this.time = e, e
                    },
                    _setEndings: function(t, e, n) {
                        var i = this._interpolantSettings;
                        n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : xe : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : xe : 2402)
                    },
                    _scheduleFading: function(t, e, n) {
                        var i = this._mixer,
                            r = i.time,
                            a = this._weightInterpolant;
                        null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
                        var o = a.parameterPositions,
                            s = a.sampleValues;
                        return o[0] = r, s[0] = e, o[1] = r + t, s[1] = n, this
                    }
                }), iu.prototype = Object.assign(Object.create(i.prototype), {
                    constructor: iu,
                    _bindAction: function(t, e) {
                        var n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            a = t._propertyBindings,
                            o = t._interpolants,
                            s = n.uuid,
                            c = this._bindingsByRootAndName,
                            u = c[s];
                        void 0 === u && (u = {}, c[s] = u);
                        for (var l = 0; l !== r; ++l) {
                            var h = i[l],
                                d = h.name,
                                p = u[d];
                            if (void 0 !== p) a[l] = p;
                            else {
                                if (void 0 !== (p = a[l])) {
                                    null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                    continue
                                }
                                var f = e && e._propertyBindings[l].binding.parsedPath;
                                ++(p = new zc(eu.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), a[l] = p
                            }
                            o[l].resultBuffer = p.buffer
                        }
                    },
                    _activateAction: function(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                var e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                                var s = r[a];
                                0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    },
                    _deactivateAction: function(t) {
                        if (this._isActiveAction(t)) {
                            for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                                var r = e[n];
                                0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                            }
                            this._takeBackAction(t)
                        }
                    },
                    _initMemoryManager: function() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        var t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function(t) {
                        var e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    },
                    _addInactiveAction: function(t, e, n) {
                        var i = this._actions,
                            r = this._actionsByClip,
                            a = r[e];
                        if (void 0 === a) a = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, r[e] = a;
                        else {
                            var o = a.knownActions;
                            t._byClipCacheIndex = o.length, o.push(t)
                        }
                        t._cacheIndex = i.length, i.push(t), a.actionByRoot[n] = t
                    },
                    _removeInactiveAction: function(t) {
                        var e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                        var r = t._clip.uuid,
                            a = this._actionsByClip,
                            o = a[r],
                            s = o.knownActions,
                            c = s[s.length - 1],
                            u = t._byClipCacheIndex;
                        c._byClipCacheIndex = u, s[u] = c, s.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(t)
                    },
                    _removeInactiveBindingsForAction: function(t) {
                        for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                            var r = e[n];
                            0 == --r.referenceCount && this._removeInactiveBinding(r)
                        }
                    },
                    _lendAction: function(t) {
                        var e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _takeBackAction: function(t) {
                        var e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _addInactiveBinding: function(t, e, n) {
                        var i = this._bindingsByRootAndName,
                            r = i[e],
                            a = this._bindings;
                        void 0 === r && (r = {}, i[e] = r), r[n] = t, t._cacheIndex = a.length, a.push(t)
                    },
                    _removeInactiveBinding: function(t) {
                        var e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            a = this._bindingsByRootAndName,
                            o = a[i],
                            s = e[e.length - 1],
                            c = t._cacheIndex;
                        s._cacheIndex = c, e[c] = s, e.pop(), delete o[r];
                        t: {
                            for (var u in o) break t;delete a[i]
                        }
                    },
                    _lendBinding: function(t) {
                        var e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _takeBackBinding: function(t) {
                        var e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    },
                    _lendControlInterpolant: function() {
                        var t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++,
                            n = t[e];
                        return void 0 === n && ((n = new es(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
                    },
                    _takeBackControlInterpolant: function(t) {
                        var e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1),
                    clipAction: function(t, e) {
                        var n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? hs.findByName(n, t) : t,
                            a = null !== r ? r.uuid : t,
                            o = this._actionsByClip[a],
                            s = null;
                        if (void 0 !== o) {
                            var c = o.actionByRoot[i];
                            if (void 0 !== c) return c;
                            s = o.knownActions[0], null === r && (r = s._clip)
                        }
                        if (null === r) return null;
                        var u = new nu(this, r, e);
                        return this._bindAction(u, s), this._addInactiveAction(u, a, i), u
                    },
                    existingAction: function(t, e) {
                        var n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? hs.findByName(n, t) : t,
                            a = r ? r.uuid : t,
                            o = this._actionsByClip[a];
                        return void 0 !== o && o.actionByRoot[i] || null
                    },
                    stopAllAction: function() {
                        var t = this._actions,
                            e = this._nActiveActions,
                            n = this._bindings,
                            i = this._nActiveBindings;
                        this._nActiveActions = 0, this._nActiveBindings = 0;
                        for (var r = 0; r !== e; ++r) t[r].reset();
                        for (r = 0; r !== i; ++r) n[r].useCount = 0;
                        return this
                    },
                    update: function(t) {
                        t *= this.timeScale;
                        for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                            e[o]._update(i, t, r, a)
                        }
                        var s = this._bindings,
                            c = this._nActiveBindings;
                        for (o = 0; o !== c; ++o) s[o].apply(a);
                        return this
                    },
                    getRoot: function() {
                        return this._root
                    },
                    uncacheClip: function(t) {
                        var e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                                var c = a[o];
                                this._deactivateAction(c);
                                var u = c._cacheIndex,
                                    l = e[e.length - 1];
                                c._cacheIndex = null, c._byClipCacheIndex = null, l._cacheIndex = u, e[u] = l, e.pop(), this._removeInactiveBindingsForAction(c)
                            }
                            delete i[n]
                        }
                    },
                    uncacheRoot: function(t) {
                        var e = t.uuid,
                            n = this._actionsByClip;
                        for (var i in n) {
                            var r = n[i].actionByRoot[e];
                            void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                        }
                        var a = this._bindingsByRootAndName[e];
                        if (void 0 !== a)
                            for (var o in a) {
                                var s = a[o];
                                s.restoreOriginalState(), this._removeInactiveBinding(s)
                            }
                    },
                    uncacheAction: function(t, e) {
                        var n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }), ru.prototype.clone = function() {
                    return new ru(void 0 === this.value.clone ? this.value : this.value.clone())
                }, au.prototype = Object.assign(Object.create(Hn.prototype), {
                    constructor: au,
                    isInstancedBufferGeometry: !0,
                    copy: function(t) {
                        return Hn.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    }
                }), ou.prototype = Object.assign(Object.create(ua.prototype), {
                    constructor: ou,
                    isInstancedInterleavedBuffer: !0,
                    copy: function(t) {
                        return ua.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), su.prototype = Object.assign(Object.create(On.prototype), {
                    constructor: su,
                    isInstancedBufferAttribute: !0,
                    copy: function(t) {
                        return On.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Object.assign(function(t, e, n, i) {
                    this.ray = new ui(t, e), this.near = n || 0, this.far = i || 1 / 0, this.params = {
                        Mesh: {},
                        Line: {},
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }, Object.defineProperties(this.params, {
                        PointCloud: {
                            get: function() {
                                return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                            }
                        }
                    })
                }.prototype, {
                    linePrecision: 1,
                    set: function(t, e) {
                        this.ray.set(t, e)
                    },
                    setFromCamera: function(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(t, e, n) {
                        var i = n || [];
                        return uu(t, this, i, e), i.sort(cu), i
                    },
                    intersectObjects: function(t, e, n) {
                        var i = n || [];
                        if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                        for (var r = 0, a = t.length; r < a; r++) uu(t[r], this, i, e);
                        return i.sort(cu), i
                    }
                }), Object.assign(function(t, e, n) {
                    return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
                }.prototype, {
                    set: function(t, e, n) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    },
                    makeSafe: function() {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, n) {
                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(De.clamp(e / this.radius, -1, 1))), this
                    }
                }), Object.assign(function(t, e, n) {
                    return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
                }.prototype, {
                    set: function(t, e, n) {
                        return this.radius = t, this.theta = e, this.y = n, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, n) {
                        return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                    }
                }), Object.assign(lu.prototype, {
                    set: function(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    },
                    setFromPoints: function(t) {
                        this.makeEmpty();
                        for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    },
                    setFromCenterAndSize: function() {
                        var t = new je;
                        return function(e, n) {
                            var i = t.copy(n).multiplyScalar(.5);
                            return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    },
                    makeEmpty: function() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    },
                    isEmpty: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    getSize: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    },
                    expandByPoint: function(t) {
                        return this.min.min(t), this.max.max(t), this
                    },
                    expandByVector: function(t) {
                        return this.min.sub(t), this.max.add(t), this
                    },
                    expandByScalar: function(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    },
                    containsPoint: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    },
                    containsBox: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    },
                    getParameter: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new je), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    },
                    intersectsBox: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    },
                    clampPoint: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new je), e.copy(t).clamp(this.min, this.max)
                    },
                    distanceToPoint: function() {
                        var t = new je;
                        return function(e) {
                            return t.copy(e).clamp(this.min, this.max).sub(e).length()
                        }
                    }(),
                    intersect: function(t) {
                        return this.min.max(t.min), this.max.min(t.max), this
                    },
                    union: function(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    },
                    translate: function(t) {
                        return this.min.add(t), this.max.add(t), this
                    },
                    equals: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }), Object.assign(hu.prototype, {
                    set: function(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new ze), t.addVectors(this.start, this.end).multiplyScalar(.5)
                    },
                    delta: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new ze), t.subVectors(this.end, this.start)
                    },
                    distanceSq: function() {
                        return this.start.distanceToSquared(this.end)
                    },
                    distance: function() {
                        return this.start.distanceTo(this.end)
                    },
                    at: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new ze), this.delta(e).multiplyScalar(t).add(this.start)
                    },
                    closestPointToPointParameter: (Yc = new ze, Zc = new ze, function(t, e) {
                        Yc.subVectors(t, this.start), Zc.subVectors(this.end, this.start);
                        var n = Zc.dot(Zc),
                            i = Zc.dot(Yc) / n;
                        return e && (i = De.clamp(i, 0, 1)), i
                    }),
                    closestPointToPoint: function(t, e, n) {
                        var i = this.closestPointToPointParameter(t, e);
                        return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new ze), this.delta(n).multiplyScalar(i).add(this.start)
                    },
                    applyMatrix4: function(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    },
                    equals: function(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                }), du.prototype = Object.create(Sn.prototype), du.prototype.constructor = du, du.prototype.isImmediateRenderObject = !0, pu.prototype = Object.create(xa.prototype), pu.prototype.constructor = pu, pu.prototype.update = function() {
                    var t = new ze,
                        e = new ze,
                        n = new Be;
                    return function() {
                        var i = ["a", "b", "c"];
                        this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                        var r = this.object.matrixWorld,
                            a = this.geometry.attributes.position,
                            o = this.object.geometry;
                        if (o && o.isGeometry)
                            for (var s = o.vertices, c = o.faces, u = 0, l = 0, h = c.length; l < h; l++)
                                for (var d = c[l], p = 0, f = d.vertexNormals.length; p < f; p++) {
                                    var m = s[d[i[p]]],
                                        v = d.vertexNormals[p];
                                    t.copy(m).applyMatrix4(r), e.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), a.setXYZ(u, t.x, t.y, t.z), u += 1, a.setXYZ(u, e.x, e.y, e.z), u += 1
                                } else if (o && o.isBufferGeometry) {
                                    var g = o.attributes.position,
                                        y = o.attributes.normal;
                                    for (u = 0, p = 0, f = g.count; p < f; p++) t.set(g.getX(p), g.getY(p), g.getZ(p)).applyMatrix4(r), e.set(y.getX(p), y.getY(p), y.getZ(p)), e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), a.setXYZ(u, t.x, t.y, t.z), u += 1, a.setXYZ(u, e.x, e.y, e.z), u += 1
                                } a.needsUpdate = !0
                    }
                }(), fu.prototype = Object.create(Sn.prototype), fu.prototype.constructor = fu, fu.prototype.dispose = function() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }, fu.prototype.update = function() {
                    var t = new ze;
                    return function() {
                        this.light.updateMatrixWorld();
                        var e = this.light.distance ? this.light.distance : 1e3,
                            n = e * Math.tan(this.light.angle);
                        this.cone.scale.set(n, n, e), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }(), mu.prototype = Object.create(xa.prototype), mu.prototype.constructor = mu, mu.prototype.updateMatrixWorld = function() {
                    var t = new ze,
                        e = new Ne,
                        n = new Ne;
                    return function(i) {
                        var r = this.bones,
                            a = this.geometry,
                            o = a.getAttribute("position");
                        n.getInverse(this.root.matrixWorld);
                        for (var s = 0, c = 0; s < r.length; s++) {
                            var u = r[s];
                            u.parent && u.parent.isBone && (e.multiplyMatrices(n, u.matrixWorld), t.setFromMatrixPosition(e), o.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(n, u.parent.matrixWorld), t.setFromMatrixPosition(e), o.setXYZ(c + 1, t.x, t.y, t.z), c += 2)
                        }
                        a.getAttribute("position").needsUpdate = !0, Sn.prototype.updateMatrixWorld.call(this, i)
                    }
                }(), vu.prototype = Object.create(di.prototype), vu.prototype.constructor = vu, vu.prototype.dispose = function() {
                    this.geometry.dispose(), this.material.dispose()
                }, vu.prototype.update = function() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }, gu.prototype = Object.create(ya.prototype), gu.prototype.constructor = gu, gu.prototype.update = function() {
                    if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
                    else {
                        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                        var t = this.material.color,
                            e = Math.max(t.r, t.g, t.b);
                        e > 1 && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)
                    }
                }, gu.prototype.dispose = function() {
                    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, yu.prototype = Object.create(Sn.prototype), yu.prototype.constructor = yu, yu.prototype.dispose = function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, yu.prototype.update = function() {
                    var t = new ze,
                        e = new hn,
                        n = new hn;
                    return function() {
                        var i = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            var r = i.geometry.getAttribute("color");
                            e.copy(this.light.color), n.copy(this.light.groundColor);
                            for (var a = 0, o = r.count; a < o; a++) {
                                var s = a < o / 2 ? e : n;
                                r.setXYZ(a, s.r, s.g, s.b)
                            }
                            r.needsUpdate = !0
                        }
                        i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }(), xu.prototype = Object.create(xa.prototype), xu.prototype.constructor = xu, bu.prototype = Object.create(xa.prototype), bu.prototype.constructor = bu, _u.prototype = Object.create(xa.prototype), _u.prototype.constructor = _u, _u.prototype.update = function() {
                    var t = new ze,
                        e = new ze,
                        n = new Be;
                    return function() {
                        this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                        for (var i = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, s = a.faces, c = 0, u = 0, l = s.length; u < l; u++) {
                            var h = s[u],
                                d = h.normal;
                            t.copy(o[h.a]).add(o[h.b]).add(o[h.c]).divideScalar(3).applyMatrix4(i), e.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), r.setXYZ(c, t.x, t.y, t.z), c += 1, r.setXYZ(c, e.x, e.y, e.z), c += 1
                        }
                        r.needsUpdate = !0
                    }
                }(), wu.prototype = Object.create(Sn.prototype), wu.prototype.constructor = wu, wu.prototype.dispose = function() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }, wu.prototype.update = function() {
                    var t = new ze,
                        e = new ze,
                        n = new ze;
                    return function() {
                        t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(e, t), this.lightPlane.lookAt(e), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(e), this.targetLine.scale.z = n.length()
                    }
                }(), Mu.prototype = Object.create(xa.prototype), Mu.prototype.constructor = Mu, Mu.prototype.update = function() {
                    var t, e, n = new ze,
                        i = new Wr;

                    function r(r, a, o, s) {
                        n.set(a, o, s).unproject(i);
                        var c = e[r];
                        if (void 0 !== c)
                            for (var u = t.getAttribute("position"), l = 0, h = c.length; l < h; l++) u.setXYZ(c[l], n.x, n.y, n.z)
                    }
                    return function() {
                        t = this.geometry, e = this.pointMap;
                        i.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                }(), Tu.prototype = Object.create(xa.prototype), Tu.prototype.constructor = Tu, Tu.prototype.update = function() {
                    var t = new $e;
                    return function(e) {
                        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                            var n = t.min,
                                i = t.max,
                                r = this.geometry.attributes.position,
                                a = r.array;
                            a[0] = i.x, a[1] = i.y, a[2] = i.z, a[3] = n.x, a[4] = i.y, a[5] = i.z, a[6] = n.x, a[7] = n.y, a[8] = i.z, a[9] = i.x, a[10] = n.y, a[11] = i.z, a[12] = i.x, a[13] = i.y, a[14] = n.z, a[15] = n.x, a[16] = i.y, a[17] = n.z, a[18] = n.x, a[19] = n.y, a[20] = n.z, a[21] = i.x, a[22] = n.y, a[23] = n.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                        }
                    }
                }(), Tu.prototype.setFromObject = function(t) {
                    return this.object = t, this.update(), this
                }, Tu.prototype.copy = function(t) {
                    return xa.prototype.copy.call(this, t), this.object = t.object, this
                }, Tu.prototype.clone = function() {
                    return (new this.constructor).copy(this)
                }, Su.prototype = Object.create(xa.prototype), Su.prototype.constructor = Su, Su.prototype.updateMatrixWorld = function(t) {
                    var e = this.box;
                    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Sn.prototype.updateMatrixWorld.call(this, t))
                }, Eu.prototype = Object.create(ya.prototype), Eu.prototype.constructor = Eu, Eu.prototype.updateMatrixWorld = function(t) {
                    var e = -this.plane.constant;
                    Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? M : w, this.lookAt(this.plane.normal), Sn.prototype.updateMatrixWorld.call(this, t)
                }, Au.prototype = Object.create(Sn.prototype), Au.prototype.constructor = Au, Au.prototype.setDirection = ($c = new ze, function(t) {
                    t.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : ($c.set(t.z, 0, -t.x).normalize(), Qc = Math.acos(t.y), this.quaternion.setFromAxisAngle($c, Qc))
                }), Au.prototype.setLength = function(t, e, n) {
                    void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
                }, Au.prototype.setColor = function(t) {
                    this.line.material.color.copy(t), this.cone.material.color.copy(t)
                }, Au.prototype.copy = function(t) {
                    return Sn.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                }, Au.prototype.clone = function() {
                    return (new this.constructor).copy(this)
                }, Lu.prototype = Object.create(xa.prototype), Lu.prototype.constructor = Lu;

            function Pu(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Os.call(this, t), this.type = "catmullrom"
            }
            ws.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ws.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(Fs.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var e = new Pn, n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        e.vertices.push(new ze(r.x, r.y, r.z || 0))
                    }
                    return e
                }
            }), Object.assign(Hs.prototype, {
                fromPoints: function(t) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), Object.create(Os.prototype), Object.create(Os.prototype), Pu.prototype = Object.create(Os.prototype), Object.assign(Pu.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), xu.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, mu.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(xc.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ic(t)
                }
            }), Object.assign(oc.prototype, {
                setTexturePath: function(t) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                }
            }), Object.assign(lu.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign($e.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), hu.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Object.assign(De, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), De.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), De.ceilPowerOfTwo(t)
                }
            }), Object.assign(Be.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(Ne.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    var t;
                    return function() {
                        return void 0 === t && (t = new ze), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, n, i, r, a) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, a)
                }
            }), en.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, ke.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(ui.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign(li.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                },
                normal: function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                },
                plane: function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }
            }), Object.assign(li, {
                barycoordFromPoint: function(t, e, n, i, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), li.getBarycoord(t, e, n, i, r)
                },
                normal: function(t, e, n, i) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), li.getNormal(t, e, n, i)
                }
            }), Object.assign(Vs.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new yo(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Oo(this, t)
                }
            }), Object.assign(je.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(ze.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ye.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Pn.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(Sn.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(Sn.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(pa.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(ma.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), fa.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(ws.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), qr.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(Ws.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(On.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            }), Object.assign(Hn.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addDrawCall: function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(Hn.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(xo.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(ru.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(si.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new hn
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                    }
                }
            }), Object.defineProperties(Wo.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(ci.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(aa.prototype, {
                clearTarget: function(t, e, n, i) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
                },
                animate: function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }
            }), Object.defineProperties(aa.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Ur.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Ze.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(ia.prototype, {
                standing: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                },
                userHeight: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.")
                    }
                }
            }), jc.prototype.load = function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var e = this;
                return (new Cc).load(t, function(t) {
                    e.setBuffer(t)
                }), this
            }, kc.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Rc.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            };
            We.crossOrigin = void 0, We.loadTexture = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new _s;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(t, n, void 0, i);
                return e && (a.mapping = e), a
            }, We.loadTextureCube = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new bs;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(t, n, void 0, i);
                return e && (a.mapping = e), a
            }, We.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, We.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        },
        WwFo: function(t, e, n) {
            var i = n("juv8"),
                r = n("7GkX");
            t.exports = function(t, e) {
                return t && i(e, r(e), t)
            }
        },
        XWtR: function(t, e, n) {
            var i = n("5T2Y").parseInt,
                r = n("oc46").trim,
                a = n("5pKv"),
                o = /^[-+]?0[xX]/;
            t.exports = 8 !== i(a + "08") || 22 !== i(a + "0x16") ? function(t, e) {
                var n = r(String(t), 3);
                return i(n, e >>> 0 || (o.test(n) ? 16 : 10))
            } : i
        },
        XYm9: function(t, e, n) {
            var i = n("+K+b");
            t.exports = function(t, e) {
                var n = e ? i(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.byteLength)
            }
        },
        Xi7e: function(t, e, n) {
            var i = n("KMkd"),
                r = n("adU4"),
                a = n("tMB7"),
                o = n("+6XX"),
                s = n("Z8oC");

            function c(t) {
                var e = -1,
                    n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n;) {
                    var i = t[e];
                    this.set(i[0], i[1])
                }
            }
            c.prototype.clear = i, c.prototype.delete = r, c.prototype.get = a, c.prototype.has = o, c.prototype.set = s, t.exports = c
        },
        YESw: function(t, e, n) {
            var i = n("Cwc5")(Object, "create");
            t.exports = i
        },
        YuTi: function(t, e) {
            t.exports = function(t) {
                return t.webpackPolyfill || (t.deprecate = function() {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                    enumerable: !0,
                    get: function() {
                        return t.l
                    }
                }), Object.defineProperty(t, "id", {
                    enumerable: !0,
                    get: function() {
                        return t.i
                    }
                }), t.webpackPolyfill = 1), t
            }
        },
        Z0cm: function(t, e) {
            var n = Array.isArray;
            t.exports = n
        },
        Z8oC: function(t, e, n) {
            var i = n("y1pI");
            t.exports = function(t, e) {
                var n = this.__data__,
                    r = i(n, t);
                return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
            }
        },
        adU4: function(t, e, n) {
            var i = n("y1pI"),
                r = Array.prototype.splice;
            t.exports = function(t) {
                var e = this.__data__,
                    n = i(e, t);
                return !(n < 0 || (n == e.length - 1 ? e.pop() : r.call(e, n, 1), --this.size, 0))
            }
        },
        b2z7: function(t, e) {
            var n = /\w*$/;
            t.exports = function(t) {
                var e = new t.constructor(t.source, n.exec(t));
                return e.lastIndex = t.lastIndex, e
            }
        },
        b80T: function(t, e, n) {
            var i = n("UNi/"),
                r = n("03A+"),
                a = n("Z0cm"),
                o = n("DSRE"),
                s = n("wJg7"),
                c = n("c6wG"),
                u = Object.prototype.hasOwnProperty;
            t.exports = function(t, e) {
                var n = a(t),
                    l = !n && r(t),
                    h = !n && !l && o(t),
                    d = !n && !l && !h && c(t),
                    p = n || l || h || d,
                    f = p ? i(t.length, String) : [],
                    m = f.length;
                for (var v in t) !e && !u.call(t, v) || p && ("length" == v || h && ("offset" == v || "parent" == v) || d && ("buffer" == v || "byteLength" == v || "byteOffset" == v) || s(v, m)) || f.push(v);
                return f
            }
        },
        c6wG: function(t, e, n) {
            var i = n("dD9F"),
                r = n("sEf8"),
                a = n("mdPL"),
                o = a && a.isTypedArray,
                s = o ? r(o) : i;
            t.exports = s
        },
        dD9F: function(t, e, n) {
            var i = n("NykK"),
                r = n("shjB"),
                a = n("ExA7"),
                o = {};
            o["[object Float32Array]"] = o["[object Float64Array]"] = o["[object Int8Array]"] = o["[object Int16Array]"] = o["[object Int32Array]"] = o["[object Uint8Array]"] = o["[object Uint8ClampedArray]"] = o["[object Uint16Array]"] = o["[object Uint32Array]"] = !0, o["[object Arguments]"] = o["[object Array]"] = o["[object ArrayBuffer]"] = o["[object Boolean]"] = o["[object DataView]"] = o["[object Date]"] = o["[object Error]"] = o["[object Function]"] = o["[object Map]"] = o["[object Number]"] = o["[object Object]"] = o["[object RegExp]"] = o["[object Set]"] = o["[object String]"] = o["[object WeakMap]"] = !1, t.exports = function(t) {
                return a(t) && r(t.length) && !!o[i(t)]
            }
        },
        dEVD: function(t, e, n) {
            var i = n("Y7ZC"),
                r = n("XWtR");
            i(i.G + i.F * (parseInt != r), {
                parseInt: r
            })
        },
        dTAl: function(t, e, n) {
            var i = n("GoyQ"),
                r = Object.create,
                a = function() {
                    function t() {}
                    return function(e) {
                        if (!i(e)) return {};
                        if (r) return r(e);
                        t.prototype = e;
                        var n = new t;
                        return t.prototype = void 0, n
                    }
                }();
            t.exports = a
        },
        e4Nc: function(t, e, n) {
            var i = n("fGT3"),
                r = n("k+1r"),
                a = n("JHgL"),
                o = n("pSRY"),
                s = n("H8j4");

            function c(t) {
                var e = -1,
                    n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n;) {
                    var i = t[e];
                    this.set(i[0], i[1])
                }
            }
            c.prototype.clear = i, c.prototype.delete = r, c.prototype.get = a, c.prototype.has = o, c.prototype.set = s, t.exports = c
        },
        ebwN: function(t, e, n) {
            var i = n("Cwc5")(n("Kz5y"), "Map");
            t.exports = i
        },
        ekgI: function(t, e, n) {
            var i = n("YESw"),
                r = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                var e = this.__data__;
                return i ? void 0 !== e[t] : r.call(e, t)
            }
        },
        fGT3: function(t, e, n) {
            var i = n("4kuk"),
                r = n("Xi7e"),
                a = n("ebwN");
            t.exports = function() {
                this.size = 0, this.__data__ = {
                    hash: new i,
                    map: new(a || r),
                    string: new i
                }
            }
        },
        "fR/l": function(t, e, n) {
            var i = n("CH3K"),
                r = n("Z0cm");
            t.exports = function(t, e, n) {
                var a = e(t);
                return r(t) ? a : i(a, n(t))
            }
        },
        fmRc: function(t, e, n) {
            var i = n("Xi7e"),
                r = n("77Zs"),
                a = n("L8xA"),
                o = n("gCq4"),
                s = n("VaNO"),
                c = n("0Cz8");

            function u(t) {
                var e = this.__data__ = new i(t);
                this.size = e.size
            }
            u.prototype.clear = r, u.prototype.delete = a, u.prototype.get = o, u.prototype.has = s, u.prototype.set = c, t.exports = u
        },
        gCq4: function(t, e) {
            t.exports = function(t) {
                return this.__data__.get(t)
            }
        },
        gFfm: function(t, e) {
            t.exports = function(t, e) {
                for (var n = -1, i = null == t ? 0 : t.length; ++n < i && !1 !== e(t[n], n, t););
                return t
            }
        },
        hypo: function(t, e, n) {
            var i = n("O0oS");
            t.exports = function(t, e, n) {
                "__proto__" == e && i ? i(t, e, {
                    configurable: !0,
                    enumerable: !0,
                    value: n,
                    writable: !0
                }) : t[e] = n
            }
        },
        "j+vE": function(t, e, n) {
            t.exports = n("SRBb")
        },
        juv8: function(t, e, n) {
            var i = n("MrPd"),
                r = n("hypo");
            t.exports = function(t, e, n, a) {
                var o = !n;
                n || (n = {});
                for (var s = -1, c = e.length; ++s < c;) {
                    var u = e[s],
                        l = a ? a(n[u], t[u], u, n, t) : void 0;
                    void 0 === l && (l = t[u]), o ? r(n, u, l) : i(n, u, l)
                }
                return n
            }
        },
        "k+1r": function(t, e, n) {
            var i = n("QkVE");
            t.exports = function(t) {
                var e = i(this, t).delete(t);
                return this.size -= e ? 1 : 0, e
            }
        },
        kekF: function(t, e) {
            t.exports = function(t, e) {
                return function(n) {
                    return t(e(n))
                }
            }
        },
        lSCD: function(t, e, n) {
            var i = n("NykK"),
                r = n("GoyQ"),
                a = "[object AsyncFunction]",
                o = "[object Function]",
                s = "[object GeneratorFunction]",
                c = "[object Proxy]";
            t.exports = function(t) {
                if (!r(t)) return !1;
                var e = i(t);
                return e == o || e == s || e == a || e == c
            }
        },
        ljhN: function(t, e) {
            t.exports = function(t, e) {
                return t === e || t != t && e != e
            }
        },
        mTTR: function(t, e, n) {
            var i = n("b80T"),
                r = n("QcOe"),
                a = n("MMmD");
            t.exports = function(t) {
                return a(t) ? i(t, !0) : r(t)
            }
        },
        mdPL: function(t, e, n) {
            (function(t) {
                var i = n("WFqU"),
                    r = e && !e.nodeType && e,
                    a = r && "object" == typeof t && t && !t.nodeType && t,
                    o = a && a.exports === r && i.process,
                    s = function() {
                        try {
                            var t = a && a.require && a.require("util").types;
                            return t || o && o.binding && o.binding("util")
                        } catch (e) {}
                    }();
                t.exports = s
            }).call(this, n("YuTi")(t))
        },
        nmnc: function(t, e, n) {
            var i = n("Kz5y").Symbol;
            t.exports = i
        },
        "oCl/": function(t, e, n) {
            var i = n("CH3K"),
                r = n("LcsW"),
                a = n("MvSz"),
                o = n("0ycA"),
                s = Object.getOwnPropertySymbols ? function(t) {
                    for (var e = []; t;) i(e, a(t)), t = r(t);
                    return e
                } : o;
            t.exports = s
        },
        oc46: function(t, e, n) {
            var i = n("Y7ZC"),
                r = n("Jes0"),
                a = n("KUxP"),
                o = n("5pKv"),
                s = "[" + o + "]",
                c = RegExp("^" + s + s + "*"),
                u = RegExp(s + s + "*$"),
                l = function(t, e, n) {
                    var r = {},
                        s = a(function() {
                            return !!o[t]() || "​" != "​" [t]()
                        }),
                        c = r[t] = s ? e(h) : o[t];
                    n && (r[n] = c), i(i.P + i.F * s, "String", r)
                },
                h = l.trim = function(t, e) {
                    return t = String(r(t)), 1 & e && (t = t.replace(c, "")), 2 & e && (t = t.replace(u, "")), t
                };
            t.exports = l
        },
        "otv/": function(t, e, n) {
            var i = n("nmnc"),
                r = i ? i.prototype : void 0,
                a = r ? r.valueOf : void 0;
            t.exports = function(t) {
                return a ? Object(a.call(t)) : {}
            }
        },
        oyjb: function(t, e, n) {
            "use strict";
            t.exports = {
                createId: function() {
                    return Math.random().toString(36).substr(2, 9)
                }
            }
        },
        pSRY: function(t, e, n) {
            var i = n("QkVE");
            t.exports = function(t) {
                return i(this, t).has(t)
            }
        },
        qZTm: function(t, e, n) {
            var i = n("fR/l"),
                r = n("MvSz"),
                a = n("7GkX");
            t.exports = function(t) {
                return i(t, a, r)
            }
        },
        sEf8: function(t, e) {
            t.exports = function(t) {
                return function(e) {
                    return t(e)
                }
            }
        },
        sEfC: function(t, e, n) {
            var i = n("GoyQ"),
                r = n("QIyF"),
                a = n("tLB3"),
                o = "Expected a function",
                s = Math.max,
                c = Math.min;
            t.exports = function(t, e, n) {
                var u, l, h, d, p, f, m = 0,
                    v = !1,
                    g = !1,
                    y = !0;
                if ("function" != typeof t) throw new TypeError(o);

                function x(e) {
                    var n = u,
                        i = l;
                    return u = l = void 0, m = e, d = t.apply(i, n)
                }

                function b(t) {
                    var n = t - f;
                    return void 0 === f || n >= e || n < 0 || g && t - m >= h
                }

                function _() {
                    var t = r();
                    if (b(t)) return w(t);
                    p = setTimeout(_, function(t) {
                        var n = e - (t - f);
                        return g ? c(n, h - (t - m)) : n
                    }(t))
                }

                function w(t) {
                    return p = void 0, y && u ? x(t) : (u = l = void 0, d)
                }

                function M() {
                    var t = r(),
                        n = b(t);
                    if (u = arguments, l = this, f = t, n) {
                        if (void 0 === p) return function(t) {
                            return m = t, p = setTimeout(_, e), v ? x(t) : d
                        }(f);
                        if (g) return p = setTimeout(_, e), x(f)
                    }
                    return void 0 === p && (p = setTimeout(_, e)), d
                }
                return e = a(e) || 0, i(n) && (v = !!n.leading, h = (g = "maxWait" in n) ? s(a(n.maxWait) || 0, e) : h, y = "trailing" in n ? !!n.trailing : y), M.cancel = function() {
                    void 0 !== p && clearTimeout(p), m = 0, u = f = l = p = void 0
                }, M.flush = function() {
                    return void 0 === p ? d : w(r())
                }, M
            }
        },
        shjB: function(t, e) {
            var n = 9007199254740991;
            t.exports = function(t) {
                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= n
            }
        },
        tLB3: function(t, e, n) {
            var i = n("GoyQ"),
                r = n("/9aa"),
                a = NaN,
                o = /^\s+|\s+$/g,
                s = /^[-+]0x[0-9a-f]+$/i,
                c = /^0b[01]+$/i,
                u = /^0o[0-7]+$/i,
                l = parseInt;
            t.exports = function(t) {
                if ("number" == typeof t) return t;
                if (r(t)) return a;
                if (i(t)) {
                    var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                    t = i(e) ? e + "" : e
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = t.replace(o, "");
                var n = c.test(t);
                return n || u.test(t) ? l(t.slice(2), n ? 2 : 8) : s.test(t) ? a : +t
            }
        },
        tMB7: function(t, e, n) {
            var i = n("y1pI");
            t.exports = function(t) {
                var e = this.__data__,
                    n = i(e, t);
                return n < 0 ? void 0 : e[n][1]
            }
        },
        tadb: function(t, e, n) {
            var i = n("Cwc5")(n("Kz5y"), "DataView");
            t.exports = i
        },
        u8Dt: function(t, e, n) {
            var i = n("YESw"),
                r = "__lodash_hash_undefined__",
                a = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                var e = this.__data__;
                if (i) {
                    var n = e[t];
                    return n === r ? void 0 : n
                }
                return a.call(e, t) ? e[t] : void 0
            }
        },
        uekQ: function(t, e, n) {
            n("dEVD"), t.exports = n("WEpk").parseInt
        },
        v5Dd: function(t, e, n) {
            var i = n("NsO/"),
                r = n("vwuL").f;
            n("zn7N")("getOwnPropertyDescriptor", function() {
                return function(t, e) {
                    return r(i(t), e)
                }
            })
        },
        "w/wX": function(t, e, n) {
            var i = n("QqLw"),
                r = n("ExA7"),
                a = "[object Set]";
            t.exports = function(t) {
                return r(t) && i(t) == a
            }
        },
        wJg7: function(t, e) {
            var n = 9007199254740991,
                i = /^(?:0|[1-9]\d*)$/;
            t.exports = function(t, e) {
                var r = typeof t;
                return !!(e = null == e ? n : e) && ("number" == r || "symbol" != r && i.test(t)) && t > -1 && t % 1 == 0 && t < e
            }
        },
        wrZu: function(t, e, n) {
            var i = n("+K+b"),
                r = n("XYm9"),
                a = n("b2z7"),
                o = n("otv/"),
                s = n("yP5f"),
                c = "[object Boolean]",
                u = "[object Date]",
                l = "[object Map]",
                h = "[object Number]",
                d = "[object RegExp]",
                p = "[object Set]",
                f = "[object String]",
                m = "[object Symbol]",
                v = "[object ArrayBuffer]",
                g = "[object DataView]",
                y = "[object Float32Array]",
                x = "[object Float64Array]",
                b = "[object Int8Array]",
                _ = "[object Int16Array]",
                w = "[object Int32Array]",
                M = "[object Uint8Array]",
                T = "[object Uint8ClampedArray]",
                S = "[object Uint16Array]",
                E = "[object Uint32Array]";
            t.exports = function(t, e, n) {
                var A = t.constructor;
                switch (e) {
                    case v:
                        return i(t);
                    case c:
                    case u:
                        return new A(+t);
                    case g:
                        return r(t, n);
                    case y:
                    case x:
                    case b:
                    case _:
                    case w:
                    case M:
                    case T:
                    case S:
                    case E:
                        return s(t, n);
                    case l:
                        return new A;
                    case h:
                    case f:
                        return new A(t);
                    case d:
                        return a(t);
                    case p:
                        return new A;
                    case m:
                        return o(t)
                }
            }
        },
        xmKf: function(t, e, n) {
            "use strict";
            var i = n("Cg2A"),
                r = n.n(i),
                a = n("9Jkg"),
                o = n.n(a),
                s = n("0iUn"),
                c = n("sLSF"),
                u = n("Womt"),
                l = n("p46w"),
                h = n("NzGn"),
                d = n("HlzF"),
                p = n("MI3g"),
                f = n("a7VT"),
                m = n("Tit0"),
                v = function() {
                    function t(e, n) {
                        Object(s.default)(this, t), this.manager = e, this.objects = [], this.numObjects = n, this.createObjects()
                    }
                    return Object(c.default)(t, [{
                        key: "createObjects",
                        value: function() {
                            for (var t = 0; t < this.numObjects; t++) this.objects.push(this.createObject())
                        }
                    }, {
                        key: "createObject",
                        value: function() {}
                    }, {
                        key: "geometry",
                        value: function() {
                            return new u.j(1, 1)
                        }
                    }, {
                        key: "getObject",
                        value: function() {
                            var t = this.objects.pop();
                            return t || (t = createObject()), t.visible = !0, t
                        }
                    }, {
                        key: "returnObject",
                        value: function(t) {
                            t && (t.visible = !1, this.objects.push(t))
                        }
                    }]), t
                }(),
                g = function(t) {
                    function e(t, n) {
                        return Object(s.default)(this, e), Object(p.default)(this, Object(f.default)(e).call(this, t, n))
                    }
                    return Object(m.default)(e, t), Object(c.default)(e, [{
                        key: "createObject",
                        value: function() {
                            var t = new u.h({
                                    color: new u.b(11184810),
                                    transparent: !0,
                                    opacity: .1,
                                    alphaMap: this.manager.textures.particleAlpha,
                                    alphaTest: .1
                                }),
                                e = new u.m(t);
                            return e.scale.set(1, 1, 1), e.position.set(1e4, 0, 1e4), e.rotation.set(-Math.PI / 2, 0, 0), e.visible = !1, this.manager.scene.add(e), e
                        }
                    }]), e
                }(v),
                y = function(t) {
                    function e(t, n) {
                        return Object(s.default)(this, e), Object(p.default)(this, Object(f.default)(e).call(this, t, n))
                    }
                    return Object(m.default)(e, t), Object(c.default)(e, [{
                        key: "createObject",
                        value: function() {
                            var t = new u.h({
                                    color: 16777215,
                                    alphaMap: this.manager.textures.blasterBulletAlpha,
                                    transparent: !0,
                                    alphaTest: .1
                                }),
                                e = new u.g(this.geometry(), t);
                            return e.visible = !1, this.manager.scene.add(e), e
                        }
                    }]), e
                }(v),
                x = function(t) {
                    function e(t, n) {
                        return Object(s.default)(this, e), Object(p.default)(this, Object(f.default)(e).call(this, t, n))
                    }
                    return Object(m.default)(e, t), Object(c.default)(e, [{
                        key: "createObject",
                        value: function() {
                            var t = new u.h({
                                    color: 16777215,
                                    alphaMap: this.manager.textures.particleAlpha,
                                    transparent: !0,
                                    alphaTest: .1
                                }),
                                e = new u.g(this.geometry(), t);
                            return e.rotation.set(-Math.PI / 2, 0, 0), e.visible = !1, this.manager.scene.add(e), e
                        }
                    }]), e
                }(v);
            n.d(e, "a", function() {
                return _
            });
            var b = n("KsUC"),
                _ = function() {
                    function t(e, n, i, r, a) {
                        Object(s.default)(this, t), this.gameId = e, this.userId = r, this.ui = n, this.replay = i, this.map = null, this.ships = [], this.obstacles = [], this.boxes = [], this.abilityObjects = [], this.particles = [], this.player = null, this.ping = 50, this.pings = [], this.serverTimeOffset = 0, this.renderDelays = [0], this.lastPingCheck = null, this.timeBetweenSyncs = 0, this.clientTickSum = 0, this.clientTickNum = 0, this.renderTickSum = 0, this.renderTickNum = 0, this.gameStartTime = null, this.deltaTime = 0, this.tickStartTime = 0, this.user = a, this.textures = {}, this.sounds = {}, this.loadTextures(), this.loadSounds(), this.createSlicerSpikesGeometry(), this.createSmasherSpikesGeometry(), this.setup(), this.particleBucket = new g(this, 200), this.blasterBulletBucket = new y(this, 100), this.explosionBucket = new x(this, 100), this.tick(), this.render()
                    }
                    return Object(c.default)(t, [{
                        key: "loadTextures",
                        value: function() {
                            this.textures.obstacleAoAlpha = (new u.n).load("/static/textures/obstacleAoAlpha.jpg"), this.textures.playerColor = (new u.n).load("/static/textures/playerColor.jpg"), this.textures.shipColor = (new u.n).load("/static/textures/shipColor.jpg"), this.textures.turretColor = (new u.n).load("/static/textures/turretColor.jpg"), this.textures.particleAlpha = (new u.n).load("/static/textures/particleAlpha.jpg"), this.textures.pillarColor = (new u.n).load("/static/textures/pillarColor.jpg"), this.textures.bg = (new u.n).load("/static/textures/bg.jpg"), this.textures.forceFieldAlpha = (new u.n).load("/static/textures/forceFieldAlpha.jpg"), this.textures.blasterBulletAlpha = (new u.n).load("/static/textures/blasterBulletAlpha.jpg"), this.textures.mineAlpha = (new u.n).load("/static/textures/mineAlpha.jpg"), this.textures.shipGunColor = (new u.n).load("/static/textures/shipGunColor.png"), this.textures.groundColor = (new u.n).load("/static/textures/groundColor.jpg")
                        }
                    }, {
                        key: "loadSounds",
                        value: function() {
                            this.sounds.blaster = new d.Howl({
                                src: ["/static/sounds/Blaster_02.wav"],
                                volume: .4
                            }), this.sounds.boost = new d.Howl({
                                src: ["/static/sounds/Boost.wav"]
                            }), this.sounds.bulletTime = new d.Howl({
                                src: ["/static/sounds/Bullet_Time.wav"]
                            }), this.sounds.cannon = new d.Howl({
                                src: ["/static/sounds/Cannon.wav"],
                                volume: .3
                            }), this.sounds.charging = new d.Howl({
                                src: ["/static/sounds/Charging_LOOP.wav"],
                                loop: !0,
                                volume: .5
                            }), this.sounds.countdown = new d.Howl({
                                src: ["/static/sounds/Countdown_Beep.wav"],
                                volume: .4
                            }), this.sounds.emp = new d.Howl({
                                src: ["/static/sounds/EMP.wav"]
                            }), this.sounds.forceField = new d.Howl({
                                src: ["/static/sounds/Force_Field.wav"]
                            }), this.sounds.gameOver = new d.Howl({
                                src: ["/static/sounds/Game_Over.wav"]
                            }), this.sounds.gameStart = new d.Howl({
                                src: ["/static/sounds/Game_Start.wav"]
                            }), this.sounds.explosionLarge = new d.Howl({
                                src: ["/static/sounds/Large_Explosion.wav"]
                            }), this.sounds.mineDropper = new d.Howl({
                                src: ["/static/sounds/Mine_Dropper.wav"]
                            }), this.sounds.rage = new d.Howl({
                                src: ["/static/sounds/Rage.wav"]
                            }), this.sounds.shieldRecharge = new d.Howl({
                                src: ["/static/sounds/Shield_Recharge_LOOP.wav"],
                                loop: !0,
                                volume: .2
                            }), this.sounds.silencer = new d.Howl({
                                src: ["/static/sounds/Silencer.wav"]
                            }), this.sounds.slam = new d.Howl({
                                src: ["/static/sounds/Slam.wav"]
                            }), this.sounds.explosionSmall = new d.Howl({
                                src: ["/static/sounds/Small_Explosion_02.wav"],
                                volume: .6
                            }), this.sounds.smasher = new d.Howl({
                                src: ["/static/sounds/Smasher.wav"]
                            }), this.sounds.stunGun = new d.Howl({
                                src: ["/static/sounds/Stun_Gun.wav"]
                            }), this.sounds.teleport = new d.Howl({
                                src: ["/static/sounds/Teleport.wav"]
                            }), this.sounds.turret = new d.Howl({
                                src: ["/static/sounds/Turret.wav"]
                            }), this.sounds.vacuum = new d.Howl({
                                src: ["/static/sounds/Vacuum_LOOP.wav"],
                                loop: !0
                            }), this.sounds.stunned = new d.Howl({
                                src: ["/static/sounds/Stun_LOOP.wav"],
                                loop: !0,
                                volume: .5
                            })
                        }
                    }, {
                        key: "sendToServer",
                        value: function(t) {
                            this.ui.ws && this.ui.ws.readyState === this.ui.ws.OPEN && this.ui.ws.send(o()(t))
                        }
                    }, {
                        key: "checkPing",
                        value: function(t) {
                            this.replay || (!this.lastPingCheck || t - this.lastPingCheck > 5e3) && (this.ui.ws && 1 == this.ui.ws.readyState && (this.pingStart = t, this.ui.ws.send(o()({
                                t: "ping"
                            }))), this.lastPingCheck = t)
                        }
                    }, {
                        key: "setup",
                        value: function() {
                            var t = window.innerWidth;
                            window.innerHeight < t && (t = window.innerHeight), this.cameraZoom = t / 1e3, this.scene = new u.k, this.camera = new u.i(-window.innerWidth / this.cameraZoom, window.innerWidth / this.cameraZoom, window.innerHeight / this.cameraZoom, -window.innerHeight / this.cameraZoom, 1, 200), this.renderer = new u.p({
                                antialias: !0
                            }), this.renderer.setSize(window.innerWidth, window.innerHeight), this.renderer.setClearColor(1780018, 1), this.camera.position.y = 100, this.camera.rotation.x = u.e.degToRad(-90), document.getElementById("game").appendChild(this.renderer.domElement), window.addEventListener("resize", this, !1), this.replay ? this.startReplay() : this.sendJoinGameMessage()
                        }
                    }, {
                        key: "renderDelay",
                        value: function() {
                            return this.renderDelays.reduce(function(t, e) {
                                return t + e
                            }) / this.renderDelays.length
                        }
                    }, {
                        key: "startReplay",
                        value: function() {
                            if (this.replayJson = JSON.parse(this.replay.json), this.replayJson) {
                                this.replayJson.sort(function(t, e) {
                                    return new Date(t.t) - new Date(e.t)
                                }), this.serverTimeOffset = r()() - this.replayJson[0].t;
                                var t = document.getElementById("loading");
                                t && (t.style.display = "none"), this.playStart = r()(), this.replayStart = this.replayJson[0].t, this.replayNextEvent()
                            }
                        }
                    }, {
                        key: "replayNextEvent",
                        value: function() {
                            var t = this;
                            if (this.replayJson && this.replayJson.length) {
                                var e = this.replayJson.shift(),
                                    n = !1;
                                this.skipReplayToGameStart && this.gameStartTime && (n = !0, e.t >= this.gameStartTime && (this.skipReplayToGameStart = !1, n = !1));
                                var i = r()() - this.playStart,
                                    a = e.t - this.replayStart,
                                    o = Math.max(0, a - i);
                                n && (o = 0), o ? this.replayTimeoutHandle = setTimeout(function() {
                                    h.a[e.j.t](e.j, t, null, t.ui), t.replayNextEvent()
                                }, o) : (h.a[e.j.t](e.j, this, null, this.ui), this.replayNextEvent())
                            } else this.ui.addToLog("Replay ended.")
                        }
                    }, {
                        key: "sendJoinGameMessage",
                        value: function() {
                            var t;
                            this.user && (t = this.user.username), t && t.length || (t = l.get("name")), t && (t = t.replace(/[^0-9a-zA-Z_\s]/g, "").trim()), t && t.length || (t = "Noname_" + Math.round(1e3 * Math.random()));
                            for (var e = [], n = [], i = function() {
                                    var t = l.get("abilityType" + r);
                                    b.abilityTypes.find(function(e) {
                                        return e.id == t
                                    }) || (t = b.abilityTypeDefaults[r]), n[r] = t, e[r] = t
                                }, r = 0; r <= b.numAbilities; r++) i();
                            this.ui.setState({
                                abilityTypes: e
                            });
                            for (var a = {
                                    t: "joinGame",
                                    gameId: this.gameId,
                                    name: t,
                                    userId: this.userId,
                                    abilityTypes: []
                                }, o = 0; o < b.numAbilities; o++) a.abilityTypes[o] = n[o];
                            this.sendToServer(a);
                            var s = document.getElementById("loading");
                            s && (s.style.display = "none")
                        }
                    }, {
                        key: "tick",
                        value: function() {
                            var t = this;
                            setTimeout(function() {
                                t.tick()
                            }, 16.666);
                            var e = r()();
                            this.checkPing(e), this.deltaTime = performance.now() - this.tickStartTime, this.tickStartTime = performance.now();
                            for (var n = 0; n < this.ships.length; n++) this.ships[n].tick(e);
                            for (var i = 0; i < this.obstacles.length; i++) this.obstacles[i].tick(e);
                            for (var a = 0; a < this.boxes.length; a++) this.boxes[a].tick(e);
                            for (var o = 0; o < this.abilityObjects.length; o++) this.abilityObjects[o].tick(e);
                            for (var s = 0; s < this.particles.length; s++) this.particles[s].tick(e);
                            if (this.clientTickSum += performance.now() - this.tickStartTime, this.clientTickNum++, this.clientTickNum > 200) {
                                var c = document.getElementById("clientTickTime");
                                c && (c.innerHTML = Math.round(this.clientTickSum / this.clientTickNum * 100) / 100), this.clientTickSum = 0, this.clientTickNum = 0
                            }
                        }
                    }, {
                        key: "render",
                        value: function() {
                            if (this.startTime = performance.now(), requestAnimationFrame(this.render.bind(this)), this.renderer.render(this.scene, this.camera), this.renderTickSum += performance.now() - this.startTime, this.renderTickNum++, this.renderTickNum > 200) {
                                var t = document.getElementById("renderTickTime");
                                t && (t.innerHTML = Math.round(this.renderTickSum / this.renderTickNum * 100) / 100), this.renderTickSum = 0, this.renderTickNum = 0
                            }
                        }
                    }, {
                        key: "handleEvent",
                        value: function(t) {
                            switch (t.type) {
                                case "resize":
                                    this.onWindowResize()
                            }
                        }
                    }, {
                        key: "onWindowResize",
                        value: function() {
                            this.camera.left = -window.innerWidth / this.cameraZoom, this.camera.right = window.innerWidth / this.cameraZoom, this.camera.top = window.innerHeight / this.cameraZoom, this.camera.bottom = -window.innerHeight / this.cameraZoom, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight), this.map && this.map.updateUI()
                        }
                    }, {
                        key: "createSmasherSpikesGeometry",
                        value: function() {
                            for (var t = new u.l, e = 2 * Math.PI / 20, n = !1, i = 0 * e, r = 0; r < 20; r++) i = e * r, n ? t.lineTo(1 * Math.cos(i) * .5, 1 * Math.sin(i) * .5) : t.moveTo(1 * Math.cos(i), 1 * Math.sin(i)), n = !n;
                            this.smasherSpikesGeometry = new u.d(t, {
                                steps: 1,
                                depth: .1,
                                bevelEnabled: !1
                            })
                        }
                    }, {
                        key: "createSlicerSpikesGeometry",
                        value: function() {
                            for (var t = new u.l, e = 2 * Math.PI / 14, n = !1, i = 0 * e, r = 0; r < 14; r++) i = e * r, n ? t.lineTo(1 * Math.cos(i) * .5, 1 * Math.sin(i) * .5) : t.moveTo(1 * Math.cos(i), 1 * Math.sin(i)), n = !n;
                            this.slicerSpikesGeometry = new u.d(t, {
                                steps: 1,
                                depth: .1,
                                bevelEnabled: !1
                            })
                        }
                    }]), t
                }()
        },
        y1pI: function(t, e, n) {
            var i = n("ljhN");
            t.exports = function(t, e) {
                for (var n = t.length; n--;)
                    if (i(t[n][0], e)) return n;
                return -1
            }
        },
        yGk4: function(t, e, n) {
            var i = n("Cwc5")(n("Kz5y"), "Set");
            t.exports = i
        },
        yHx3: function(t, e) {
            var n = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                var e = t.length,
                    i = new t.constructor(e);
                return e && "string" == typeof t[0] && n.call(t, "index") && (i.index = t.index, i.input = t.input), i
            }
        },
        yLpj: function(t, e) {
            var n;
            n = function() {
                return this
            }();
            try {
                n = n || new Function("return this")()
            } catch (i) {
                "object" == typeof window && (n = window)
            }
            t.exports = n
        },
        yP5f: function(t, e, n) {
            var i = n("+K+b");
            t.exports = function(t, e) {
                var n = e ? i(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.length)
            }
        },
        zEVN: function(t, e, n) {
            var i = n("Gi0A"),
                r = n("sEf8"),
                a = n("mdPL"),
                o = a && a.isMap,
                s = o ? r(o) : i;
            t.exports = s
        }
    },
    [
        ["07wX", 1, 0]
    ]
]);
